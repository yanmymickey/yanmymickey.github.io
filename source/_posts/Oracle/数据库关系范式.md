---
title: 数据库关系范式
date: 2019-12-17
tags: [Note,oracle]
categories:
- [Note,Oracle]
comments: false
---

# 数据库关系范式

## 数据依赖

**关系模式中的各属性之间相互依赖、相互制约的联系称为数据依赖**

- 函数依赖
- 多值依赖
- 连接依赖
<!-- more -->
## 关系模式应满足的基本要求

- 数据库中的数据冗余应该尽可能的少
- 关系数据库不能因为数据更新操作而引起数据不一致的问题
- 插入数据时，不能产生插入异常现象
- 删除数据时，不能产生删除异常现象
- 数据库设计应考虑查询要求，数据组织应合理

## 完全函数依赖和部分函数依赖

(Sno,Cno)->Grade(完全函数依赖)

学号和课程号组成集合才能一定推出唯一的成绩，所以(Sno,Cno)为决定因素

因为Sno->Age所以(Sno,Cno)->Age(部分函数依赖)

学号是学号和课程号组成集合的子集,而学号就可以推出年龄,所以年龄部分函数依赖于(Sno,Cno)这个集合

**说明**

- 只用当决定因素是组合属性时，讨论部分函数依赖才有意义
- 当决定是单属性时，只能是完全函数依赖
- 例如，在关系模式S（SNO，SN，AGE，DEPT），决定因素为单属性SNO，有SNO->（SN，AGE，DEPT），不存在部分函数依赖。

## 范式

- **基本思想：**消除关系模式中的数据冗余，消除数据依赖中的不合适的部分，解决数据插入、删除时发生异常现象
- **范式：**把关系数据库设计出来的关系模式要满足一定的条件。
- **第一范式：**满足基本规范要求的关系模式
- **第二范式：**在第一范式中进一步满足一些要求
- **第三范式：**以此类推产生了第三范式等概念
- **注意：**每个范式都规定了一些限制条件

### 第一范式

- **定义：**如果一个关系模式R中的所有属性都是不可分的最小数据项，则R∈1NF
- 注意：
  - NF是关系模式的一个最起码的要求
  - 不满足1NF的数据库模式不能称之为关系数据库
  - 但满足1NF的关系模式不一定是好的关系模式

### 第二范式

- **定义：**如果关系模式R∈1NF，且R中每一个非主属性完全函数依赖于码，则R∈2NF
- 结论：
  1. 从1NF关系中消除非主属性对关系键的部分函数依赖，则可得到2NF关系
  2. 如果R的关系为单属性，或R的全体属性均为主属性，则R∈2NF
- 2NF规范化
  - 2NF规范化是指把1NF关系模式通过投影分解转换成2NF关系模式的集合
  - 分解时遵循的基本原则就是“一事一地”，让一个关系只描述一个实体或者实体间的联系。如果多于一个实体或联系，则进行投影分解

### 第三范式

- **定义：**如果关系模式R∈2NF，且R中每个非主属性都不传递依赖于码，则R∈3NF
- 3NF规范化：
  - 3NF是指把2NF关系模式通过投影分解转换成3NF关系模式的集合
  - 和2NF规范化时遵循的原则相同，即“一事一地”，让一个关系只描述一个实体或者实体间的联系

### BC范式

- **定义：**关系模式R(U,F)∈1NF，若对R的每个函数依赖x->y，有x必含候选码，则R∈BCNF
- 优点：
  - 数据冗余降低
  - 不存在插入异常
  - 不存在删除异常
  - 不存在更新异常
- 性质：
  - 若R∈BCNF，则R∈2NF
  - 若R∈BCNF，则R∈3NF
  - 若R∈3NF，则R不一定是BCNF
  - 若R∈3NF，且候选码唯一，则R是BCNF

### 第四范式

- **定义：**关系模式R(U,D)∈1NF，U是属性全集，x，y是U的子集，D是R上的数据依赖集，如果对R的每个非平凡多值依赖X->->y，x都含候选码，则R∈4NF。
- 

```
(1) R是BCNF。R候选关键字为XY，F中只有一个函数依赖，而该函数依赖的左部包含了R的候选关键字。

   (2) R是3NF。R候选关键字为X Y和XZ，R中所有属性都是主属性，不存在非主属性对候选关键字的传递依赖。

   (3) R是BCNF。R候选关键字为X和Y，因为X→YZ，所以X→Y，X→Z，由于F中有Y→Z，Y→X，因此Z是直接函数依赖于X，而不是传递依赖于X。又因为F的每一函数依赖的左部都包含了任一候选关键字，所以R是BCNF。

   (4) R是BCNF。R候选关键字为X，而且F中每一个函数依赖的左部包含了候选关键字X。

   (5) R是1NF。R候选关键字为WX，则Y，Z为非主属性，又由于X→Z，因此F中存在非主属性对候选关键字的部分函数依赖
```